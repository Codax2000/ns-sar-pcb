{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PCB Design for a Noise-Shaping SAR This has several goals: 1) Understand, design, and build a mixed-signal PCB using SMD components 1) Go through the process of FPGA design and synthesis, including asynchronous RTL design 1) Become better at reading datasheets for discrete components 1) Build a UVM testbench that includes real-number modeling. 1) Using IEEE SystemRDL to describe a register model. 1) Design an analog/mixed-signal circuit using LTSpice, instead of my usual Spectre. 1) Implement a system that includes some kind of bus communication protocol, likely i2c or SPI. Theory TODO: insert simulations here Architecture Technology","title":"Home"},{"location":"#pcb-design-for-a-noise-shaping-sar","text":"This has several goals: 1) Understand, design, and build a mixed-signal PCB using SMD components 1) Go through the process of FPGA design and synthesis, including asynchronous RTL design 1) Become better at reading datasheets for discrete components 1) Build a UVM testbench that includes real-number modeling. 1) Using IEEE SystemRDL to describe a register model. 1) Design an analog/mixed-signal circuit using LTSpice, instead of my usual Spectre. 1) Implement a system that includes some kind of bus communication protocol, likely i2c or SPI.","title":"PCB Design for a Noise-Shaping SAR"},{"location":"#theory","text":"TODO: insert simulations here","title":"Theory"},{"location":"#architecture","text":"","title":"Architecture"},{"location":"#technology","text":"","title":"Technology"},{"location":"hdl/","text":"Digital Logic ADCs need digital logic. This means a register interface for CSRs (control and status registers) and a main state machine to control the conversion. It therefore means closing timing and rigorous verification. RTL Verification Noise-Shaping SAR ADC \u2013 Verification Regression Test Plan 1. Smoke / Sanity Tests (Per-Commit) smoke_reset Assert reset during idle and mid-conversion Verify registers return to defaults Ensure no X/Z propagation smoke_reg_access Write/read all control registers Check illegal accesses Boundary value testing smoke_clock_div Sweep clock divider Verify timing scales correctly 2. Functional Correctness Tests ramp_monotonicity Slow ramp input No missing codes Monotonic output Correct SAR latency dc_levels Multiple DC inputs Check gain and offset error step_response Large step input Verify settling and transient response 3. Spectral / Performance Tests snr_nominal Full-scale sine input Measure SNR and ENOB Assert SNR > spec thd_nominal Near full-scale sine Measure THD and SFDR Assert harmonics < spec osr_sweep Sweep OSR Verify 2nd-order noise shaping slope (~15 dB/octave) dem_on_off_compare Compare spectra with DEM on vs off Verify harmonic reduction 4. Mode Coverage Tests incremental_vs_continuous Compare both operating modes Validate behavior vs theory filter_coeff_sweep Sweep 2nd-order filter coefficients Check stability and overflow 5. Boundary & Stress Tests analog_digital_boundary_stress Inject jitter / metastability modeling Verify no lockup or corruption spi_mid_conversion Modify registers mid-conversion Verify graceful handling warmup_behavior Ensure warmup samples are discarded properly 6. Randomized Tests random_reg_sequence Randomized mode and OSR switching Constrained random register access random_input_waveform Random sine amplitude/frequency/phase Verify stability 7. Long-Run Stability long_run_stability Extended simulation duration Verify no drift or state corruption Regression Tiers Per-Commit (Fast): - smoke_reset - smoke_reg_access - ramp_monotonicity - dc_levels Nightly: - snr_nominal - thd_nominal - osr_sweep - dem_on_off_compare - filter_coeff_sweep Weekly / Extended: - analog_digital_boundary_stress - random_reg_sequence - long_run_stability FPGA Implementation Timing FPGA Resources","title":"HDL"},{"location":"hdl/#digital-logic","text":"ADCs need digital logic. This means a register interface for CSRs (control and status registers) and a main state machine to control the conversion. It therefore means closing timing and rigorous verification.","title":"Digital Logic"},{"location":"hdl/#rtl","text":"","title":"RTL"},{"location":"hdl/#verification","text":"","title":"Verification"},{"location":"hdl/#noise-shaping-sar-adc-verification-regression-test-plan","text":"","title":"Noise-Shaping SAR ADC \u2013 Verification Regression Test Plan"},{"location":"hdl/#1-smoke-sanity-tests-per-commit","text":"smoke_reset Assert reset during idle and mid-conversion Verify registers return to defaults Ensure no X/Z propagation smoke_reg_access Write/read all control registers Check illegal accesses Boundary value testing smoke_clock_div Sweep clock divider Verify timing scales correctly","title":"1. Smoke / Sanity Tests (Per-Commit)"},{"location":"hdl/#2-functional-correctness-tests","text":"ramp_monotonicity Slow ramp input No missing codes Monotonic output Correct SAR latency dc_levels Multiple DC inputs Check gain and offset error step_response Large step input Verify settling and transient response","title":"2. Functional Correctness Tests"},{"location":"hdl/#3-spectral-performance-tests","text":"snr_nominal Full-scale sine input Measure SNR and ENOB Assert SNR > spec thd_nominal Near full-scale sine Measure THD and SFDR Assert harmonics < spec osr_sweep Sweep OSR Verify 2nd-order noise shaping slope (~15 dB/octave) dem_on_off_compare Compare spectra with DEM on vs off Verify harmonic reduction","title":"3. Spectral / Performance Tests"},{"location":"hdl/#4-mode-coverage-tests","text":"incremental_vs_continuous Compare both operating modes Validate behavior vs theory filter_coeff_sweep Sweep 2nd-order filter coefficients Check stability and overflow","title":"4. Mode Coverage Tests"},{"location":"hdl/#5-boundary-stress-tests","text":"analog_digital_boundary_stress Inject jitter / metastability modeling Verify no lockup or corruption spi_mid_conversion Modify registers mid-conversion Verify graceful handling warmup_behavior Ensure warmup samples are discarded properly","title":"5. Boundary &amp; Stress Tests"},{"location":"hdl/#6-randomized-tests","text":"random_reg_sequence Randomized mode and OSR switching Constrained random register access random_input_waveform Random sine amplitude/frequency/phase Verify stability","title":"6. Randomized Tests"},{"location":"hdl/#7-long-run-stability","text":"long_run_stability Extended simulation duration Verify no drift or state corruption","title":"7. Long-Run Stability"},{"location":"hdl/#regression-tiers","text":"Per-Commit (Fast): - smoke_reset - smoke_reg_access - ramp_monotonicity - dc_levels Nightly: - snr_nominal - thd_nominal - osr_sweep - dem_on_off_compare - filter_coeff_sweep Weekly / Extended: - analog_digital_boundary_stress - random_reg_sequence - long_run_stability","title":"Regression Tiers"},{"location":"hdl/#fpga-implementation","text":"","title":"FPGA Implementation"},{"location":"hdl/#timing","text":"","title":"Timing"},{"location":"hdl/#fpga-resources","text":"","title":"FPGA Resources"},{"location":"ndocs/","text":"NaturalDocs Placeholder","title":"Code"},{"location":"ndocs/#naturaldocs","text":"Placeholder","title":"NaturalDocs"},{"location":"pcb/","text":"Mixed-Signal PCB Design This was the part of the project where I designed the analog part of the ADC, ran SPICE simulations to validate the HDL model, and designed it using KiCAD. Analog Design SHA CDAC Double-Tail Comparator PCB Design","title":"PCB"},{"location":"pcb/#mixed-signal-pcb-design","text":"This was the part of the project where I designed the analog part of the ADC, ran SPICE simulations to validate the HDL model, and designed it using KiCAD.","title":"Mixed-Signal PCB Design"},{"location":"pcb/#analog-design","text":"","title":"Analog Design"},{"location":"pcb/#sha","text":"","title":"SHA"},{"location":"pcb/#cdac","text":"","title":"CDAC"},{"location":"pcb/#double-tail-comparator","text":"","title":"Double-Tail Comparator"},{"location":"pcb/#pcb-design","text":"","title":"PCB Design"},{"location":"style_guide/","text":"Codax2000 Engineering Style Guide Revision: 1.0 Core Philosophy: Documentation is a contract. If code and comments diverge, the code is the truth, but the comments are a liability. Prefer automated documentation (NaturalDocs) and readable logic over \"clouds of text.\" In short, comments are no substitute for illegible code. 1. SystemVerilog Style Guide All SystemVerilog files must utilize NaturalDocs headers. Comments should explain the why (architectural intent), while the code should be readable enough to explain the what at a glance. 1.1 RTL (Synthesizable) Assignments: Sequential logic must use non-blocking assignments ( <= ). Resets: Use active-high synchronous resets with the name rst where possible. They should be synchronized on-chip if they are asynchronous coming in. This is mainly because Xilinx has active-high, synchronous resets, so this cuts down on utilization, but there are cases where async reset is necessary (like in SPI with csb). Automation: Never manually code register banks. Use PeakRDL to generate RTL from the .rdl specification to ensure a single source of truth. 1.2 Behavioral Modeling (Analog/Mixed-Signal) Signal Types: Use real for continuous signals (voltages, currents) in behavioral models. Precision: Every behavioral file must include a local `timescale . Partitioning: Models should mimic the physical PCB floorplan. If an integrator is discrete on the board, it should be a standalone module in the simulation. This also helps with block-level validation in SPICE, since we can't do co-simulation without some kind of sim engine. 1.3 Design Verification (DV) File Names * Package files should end with _pkg.sv . All other UVM class files should be defined as header files, using .svh . Modules should always end in .sv . Naming: * Classes: snake_case (e.g., adc_scoreboard , spi_monitor ). Member Variables: m_ prefix if an instance of an object that extends a UVM type (e.g., m_env_cfg ) Exceptions for an agent, in which case the driver, monitor, sequencer should be called driver , monitor , sequencer . Virtual Interfaces: No direct RTL hierarchy references. Use uvm_config_db to pass virtual interfaces ( vif ). Reporting: Use uvm_ms_info , uvm_ms_warning , and uvm_ms_error macros to ensure analog-bridge signals are logged correctly within the UVM environment. When you no longer need a particular uvm_info , don't delete it; just turn up the verbosity to UVM_HIGH or UVM_DEBUG . If you had it there to start, chances are it's for a reason, so keep it. Variables: * If something is Vivado-incompliant (e.g. real-type coverpoints), use a workaround and add ifdef s using the VIVADO define. 2. Python Style Guide Python is the \"automation glue\" of the project. It must be as reliable as the hardware it generates. 2.1 Linting & Standards Linter: flake8 is mandatory. Code must pass with zero warnings. Docstrings: Use NaturalDocs for documentation. Python help still works, but docstrings have to be above the function. This sucks, but we want our documentation in one place. 2.2 Project-Specific Rules No Hard-Coding: Scripts must pull parameters (bit-widths, memory depths) from the design source where possible. Diagrammatic Integrity: Technical diagrams must be generated via schemdraw in scripts/diagrams.py . Manual edits to images are a pain, just update the script so Git can see the changes. 3. General \"Clean Code\" Principles Meaningful Names: If you need a comment to explain a variable name, the name is probably wrong. We comment variables in NaturalDocs so a user knows how to use them from the documentation, not to explain poor naming. Small Functions: Functions should do one thing. Stale Comments are Bugs: Delete self-evident comments. Document the decisions , not the syntax .","title":"Codax2000 Engineering Style Guide"},{"location":"style_guide/#codax2000-engineering-style-guide","text":"Revision: 1.0 Core Philosophy: Documentation is a contract. If code and comments diverge, the code is the truth, but the comments are a liability. Prefer automated documentation (NaturalDocs) and readable logic over \"clouds of text.\" In short, comments are no substitute for illegible code.","title":"Codax2000 Engineering Style Guide"},{"location":"style_guide/#1-systemverilog-style-guide","text":"All SystemVerilog files must utilize NaturalDocs headers. Comments should explain the why (architectural intent), while the code should be readable enough to explain the what at a glance.","title":"1. SystemVerilog Style Guide"},{"location":"style_guide/#11-rtl-synthesizable","text":"Assignments: Sequential logic must use non-blocking assignments ( <= ). Resets: Use active-high synchronous resets with the name rst where possible. They should be synchronized on-chip if they are asynchronous coming in. This is mainly because Xilinx has active-high, synchronous resets, so this cuts down on utilization, but there are cases where async reset is necessary (like in SPI with csb). Automation: Never manually code register banks. Use PeakRDL to generate RTL from the .rdl specification to ensure a single source of truth.","title":"1.1 RTL (Synthesizable)"},{"location":"style_guide/#12-behavioral-modeling-analogmixed-signal","text":"Signal Types: Use real for continuous signals (voltages, currents) in behavioral models. Precision: Every behavioral file must include a local `timescale . Partitioning: Models should mimic the physical PCB floorplan. If an integrator is discrete on the board, it should be a standalone module in the simulation. This also helps with block-level validation in SPICE, since we can't do co-simulation without some kind of sim engine.","title":"1.2 Behavioral Modeling (Analog/Mixed-Signal)"},{"location":"style_guide/#13-design-verification-dv","text":"File Names * Package files should end with _pkg.sv . All other UVM class files should be defined as header files, using .svh . Modules should always end in .sv . Naming: * Classes: snake_case (e.g., adc_scoreboard , spi_monitor ). Member Variables: m_ prefix if an instance of an object that extends a UVM type (e.g., m_env_cfg ) Exceptions for an agent, in which case the driver, monitor, sequencer should be called driver , monitor , sequencer . Virtual Interfaces: No direct RTL hierarchy references. Use uvm_config_db to pass virtual interfaces ( vif ). Reporting: Use uvm_ms_info , uvm_ms_warning , and uvm_ms_error macros to ensure analog-bridge signals are logged correctly within the UVM environment. When you no longer need a particular uvm_info , don't delete it; just turn up the verbosity to UVM_HIGH or UVM_DEBUG . If you had it there to start, chances are it's for a reason, so keep it. Variables: * If something is Vivado-incompliant (e.g. real-type coverpoints), use a workaround and add ifdef s using the VIVADO define.","title":"1.3 Design Verification (DV)"},{"location":"style_guide/#2-python-style-guide","text":"Python is the \"automation glue\" of the project. It must be as reliable as the hardware it generates.","title":"2. Python Style Guide"},{"location":"style_guide/#21-linting-standards","text":"Linter: flake8 is mandatory. Code must pass with zero warnings. Docstrings: Use NaturalDocs for documentation. Python help still works, but docstrings have to be above the function. This sucks, but we want our documentation in one place.","title":"2.1 Linting &amp; Standards"},{"location":"style_guide/#22-project-specific-rules","text":"No Hard-Coding: Scripts must pull parameters (bit-widths, memory depths) from the design source where possible. Diagrammatic Integrity: Technical diagrams must be generated via schemdraw in scripts/diagrams.py . Manual edits to images are a pain, just update the script so Git can see the changes.","title":"2.2 Project-Specific Rules"},{"location":"style_guide/#3-general-clean-code-principles","text":"Meaningful Names: If you need a comment to explain a variable name, the name is probably wrong. We comment variables in NaturalDocs so a user knows how to use them from the documentation, not to explain poor naming. Small Functions: Functions should do one thing. Stale Comments are Bugs: Delete self-evident comments. Document the decisions , not the syntax .","title":"3. General \"Clean Code\" Principles"},{"location":"theory/","text":"Noise-Shaping ADCs Motivation Controls Additional Issues Results","title":"ADC Theory"},{"location":"theory/#noise-shaping-adcs","text":"","title":"Noise-Shaping ADCs"},{"location":"theory/#motivation","text":"","title":"Motivation"},{"location":"theory/#controls","text":"","title":"Controls"},{"location":"theory/#additional-issues","text":"","title":"Additional Issues"},{"location":"theory/#results","text":"","title":"Results"}]}