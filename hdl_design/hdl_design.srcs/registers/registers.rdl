addrmap adc_regs {
    desc = "SAR ADC PCB register map";
    default regwidth=16;
    default accesswidth=8;
    default sw=rw;
    default hw=r;
    default reset=0x0;

    enum input_mode_e {
        SINGLE_ENDED = 0;
        DIFFERENTIAL = 1;
    };

    // describe "active" and "passive" cycles of some ADC operation
    reg active_passive_reg {
        field {
            desc="Number of ADC clock cycles during which target will be active.";
            reset=0x1;
        } N_ACTIVE_CYCLES [7:0];
        field {
            desc="Number of ADC clock cycles during which target will be inactive.";
        } N_PASSIVE_CYCLES [15:8];
    };
    
    active_passive_reg SH_CTRL;
    active_passive_reg INT1_CTRL;
    active_passive_reg INT2_CTRL;

    

    reg {
        field {
            desc="OSR power - configures ADC to have an oversampling ratio of 2^OSR_POWER. This allows an OSR of up to 128.";
        } OSR_POWER [2:0];
        field {
            desc="FFT power. When taking FFT samples, the ADC will take 2^NFFT_POWER samples. There are only 2^14 samples available in memory, so if in continuous mode, then OSR*NFFT <= 2^14. If in incremental mode, then up-counters will deal with OSR, so NFFT_POWER<=14.";
        } NFFT_POWER [6:3];
        field {
            desc="If 1, runs the ADC in incremental mode, meaning that the reset will be applied and the output will be filtered (up-counted). Else, runs in delta-sigma mode, and there will be no filtering at the output.";
        } INCREMENTAL_MODE_EN [7:7];
        field {
            desc="If 0, run an NFFT conversion with SAR quantizer only. If 1, run with noise-shaping.";
        } NOISE_SHAPING_EN [8:8];
        field {
            desc="Number of bits to quantize, minus one. That is, the SAR will quantize N_QUANTIZER_BITS + 1.";
        } N_QUANTIZER_BITS [10:9];
        field {
            desc="If 1, enables DWA during FFT conversion. Else, there will be no DEM whatsoever.";
        } DWA_EN [11:11];
        field {
            desc="SAR asynchronous delay control. Higher values will lead to longer SAR clock periods.";
        } DELAY_LINE_CTRL [15:12];
    } FFT_CTRL;

    reg {
        donttest;
        field {
            hwclr;
            desc="When a 1 is written, starts an NFFT conversion. When read, a 1 means the NFFT conversion is running, and a 0 means it is not. If a 0 is written while the conversion is running, terminates the conversion early and sets state machine back to ready state.";
        } START_CONVERSION [0:0];
        field {
            sw=r;
            hw=w;
            desc="Readback of the internal synchronous reset.";
        } SYNC_RESET_RB [1:1];
        field {
            sw=r;
            hw=w;
            desc="Readback of the current status of the main state machine.";
        } MAIN_STATE_RB [5:2];
    } ADC_CTRL;

    reg {
        default sw=r;
        default hw=w;
        donttest;

        field {
            desc="The number of valid entries in ADC memory, from the last conversion. Again, this can only be 2^14.";
        } N_VALID_SAMPLES [14:0];
        field {
            desc="If 1, means that the conversion settings were changed during the last conversion.";
        } PREVIOUS_CONVERSION_CORRUPTED [15:15];
    } CONVERSION_FLAGS;

    `ifdef XILINX
    // xilinx CLKGEN DRP registers
    reg {
        donttest;

        field {
            desc="Read enable bit for CLKGEN xip";
        } CLKGEN_DRP_RD_EN [0:0];
        field {
            desc="Write enable bit for CLKGEN xip";
        } CLKGEN_DRP_WR_EN [1:1];
        field {
            desc="Data enable bit for CLKGEN xip";
        } CLKGEN_DRP_DEN [2:2];
        field {
            desc="Read/Write address for CLKGEN xip";
        } CLKGEN_DRP_DADDR [9:3];
    } CLKGEN_DRP_CONFIG;

    reg {
        donttest;
        regwidth=16;
        field {
            desc="Data input for CLKGEN xip";
        } data [15:0];
    } CLKGEN_DI;

    reg {
        donttest;
        regwidth=16;
        field {
            sw=r;
            hw=w;
            desc="Data output for CLKGEN xip";
        } data [15:0];
    } CLKGEN_DO;
    `endif

    mem {
        sw=r;
        memwidth=16;
        
        mementries=0x4000;
    } external adc_output_mem @ 0x8000;

};