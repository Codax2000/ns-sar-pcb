addrmap adc_regs {
    desc = "SAR ADC PCB register map";
    default regwidth=16;
    default sw=rw;
    default hw=r;
    default reset=0x0;

    enum input_mode_e {
        SINGLE_ENDED = 0;
        DIFFERENTIAL = 1;
    };

    reg {
        field {
            desc="OSR power - configures ADC to have an oversampling ratio of 2^OSR_POWER. This allows an OSR of up to 256.";
        } OSR_POWER [7:0];
    } OSR;

    // describe "active" and "passive" cycles of some ADC operation
    reg active_passive_reg {
        field {
            desc="Number of ADC clock cycles during which target will be active.";
            reset=0x1;
        } N_ACTIVE_CYCLES [7:0];
        field {
            desc="Number of ADC clock cycles during which target will be inactive.";
        } N_PASSIVE_CYCLES [15:8];
    };
    
    active_passive_reg SH_CTRL;
    active_passive_reg INT1_CTRL;
    active_passive_reg INT2_CTRL;

    reg {
        field {
            desc="SAR asynchronous delay control. Higher values will lead to longer SAR clock periods.";
        } DELAY_LINE_CTRL [3:0];
        field {
            desc="Number of bits to quantize, minus one. That is, the SAR will quantize N_QUANTIZER_BITS + 1.";
        } N_QUANTIZER_BITS [5:4];
        field {
            desc="If 1, enables DWA during FFT conversion. Else, there will be no DEM whatsoever.";
        } DWA_EN [6:6];

        field {
            hwclr;
            desc="When a 1 is written, starts an NFFT conversion. When read, a 1 means the NFFT conversion is running, and a 0 means it is not. If a 0 is written while the conversion is running, terminates the conversion early and sets state machine back to ready state.";
        } START_CONVERSION [8:8];
        field {
            desc="If 1, runs the ADC in incremental mode, meaning that the reset will be applied and the output will be filtered (up-counted). Else, runs in delta-sigma mode, and there will be no filtering at the output.";
        } INCREMENTAL_MODE_EN [9:9];
        field {
            desc="If 0, run an NFFT conversion with SAR quantizer only. If 1, run with noise-shaping.";
        } NOISE_SHAPING_EN [10:10];
        field {
            desc="FFT power (8 LSB bits). When taking FFT samples, the ADC will take 2^NFFT_POWER samples. Should be at most 14, since memory has an address space of 14 bits, so it can't store any more samples than that. Should be entirely sufficient for this project, though 2^16 would be ideal.";
        } NFFT_POWER [14:11];
    } ADC_CTRL;

    reg {
        default sw=r;
        default hw=w;
        donttest;
        field {
            sw=r;
            hw=w;
            desc="Readback of the current status of the main state machine.";
        } MAIN_STATE_RB [3:0];
        field {
            sw=r;
            hw=w;
            desc="Readback of the internal synchronous reset.";
        } SYNC_RESET_RB [4:4];
    } STATUS_RB_1;

    reg {
        default sw=r;
        default hw=w;
        donttest;

        field {
            desc="The number of valid entries in ADC memory, from the last conversion.";
        } N_VALID_SAMPLES [14:0];
    } STATUS_RB_2;

    `ifdef XILINX
    // xilinx CLKGEN DRP registers
    reg {
        donttest;

        field {
            desc="Read enable bit for CLKGEN xip";
        } CLKGEN_DRP_RD_EN [0:0];
        field {
            desc="Write enable bit for CLKGEN xip";
        } CLKGEN_DRP_WR_EN [1:1];
        field {
            desc="Data enable bit for CLKGEN xip";
        } CLKGEN_DRP_DEN [2:2];
        field {
            desc="Read/Write address for CLKGEN xip";
        } CLKGEN_DRP_DADDR [9:3];
    } CLKGEN_DRP_CONFIG;

    reg {
        donttest;
        regwidth=16;
        field {
            desc="Data input for CLKGEN xip";
        } data [15:0];
    } CLKGEN_DI;

    reg {
        donttest;
        regwidth=16;
        field {
            sw=r;
            hw=w;
            desc="Data output for CLKGEN xip";
        } data [15:0];
    } CLKGEN_DO;
    `endif

    mem {
        sw=r;
        memwidth=16;
        
        mementries=0x2000;
    } external adc_output_mem @ 0x4000;

};