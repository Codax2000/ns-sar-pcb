
// This file was autogenerated by PeakRDL-uvm
package adc_regs_pkg;
    `include "uvm_macros.svh"
    import uvm_pkg::*;
    
    // reg - adc_regs::OSR
    class adc_regs__OSR extends uvm_reg;
        `uvm_object_utils(adc_regs__OSR)
        rand uvm_reg_field OSR_POWER;

        function new(string name = "adc_regs__OSR");
            super.new(name, 16, UVM_NO_COVERAGE);
        endfunction : new

        virtual function void build();
            this.OSR_POWER = uvm_reg_field::type_id::create("OSR_POWER");
            this.OSR_POWER.configure(this, 8, 0, "RW", 0, 'h0, 1, 1, 0);
        endfunction : build
    endclass : adc_regs__OSR

    // reg - adc_regs::active_passive_reg
    class adc_regs__active_passive_reg extends uvm_reg;
        `uvm_object_utils(adc_regs__active_passive_reg)
        rand uvm_reg_field N_ACTIVE_CYCLES;
        rand uvm_reg_field N_PASSIVE_CYCLES;

        function new(string name = "adc_regs__active_passive_reg");
            super.new(name, 16, UVM_NO_COVERAGE);
        endfunction : new

        virtual function void build();
            this.N_ACTIVE_CYCLES = uvm_reg_field::type_id::create("N_ACTIVE_CYCLES");
            this.N_ACTIVE_CYCLES.configure(this, 8, 0, "RW", 0, 'h1, 1, 1, 0);
            this.N_PASSIVE_CYCLES = uvm_reg_field::type_id::create("N_PASSIVE_CYCLES");
            this.N_PASSIVE_CYCLES.configure(this, 8, 8, "RW", 0, 'h0, 1, 1, 0);
        endfunction : build
    endclass : adc_regs__active_passive_reg

    // reg - adc_regs::ADC_CTRL
    class adc_regs__ADC_CTRL extends uvm_reg;
        `uvm_object_utils(adc_regs__ADC_CTRL)
        rand uvm_reg_field DELAY_LINE_CTRL;
        rand uvm_reg_field N_QUANTIZER_BITS;
        rand uvm_reg_field DWA_EN;
        rand uvm_reg_field START_CONVERSION;
        rand uvm_reg_field INCREMENTAL_MODE_EN;
        rand uvm_reg_field NOISE_SHAPING_EN;
        rand uvm_reg_field NFFT_POWER;

        function new(string name = "adc_regs__ADC_CTRL");
            super.new(name, 16, UVM_NO_COVERAGE);
        endfunction : new

        virtual function void build();
            this.DELAY_LINE_CTRL = uvm_reg_field::type_id::create("DELAY_LINE_CTRL");
            this.DELAY_LINE_CTRL.configure(this, 4, 0, "RW", 0, 'h0, 1, 1, 0);
            this.N_QUANTIZER_BITS = uvm_reg_field::type_id::create("N_QUANTIZER_BITS");
            this.N_QUANTIZER_BITS.configure(this, 2, 4, "RW", 0, 'h0, 1, 1, 0);
            this.DWA_EN = uvm_reg_field::type_id::create("DWA_EN");
            this.DWA_EN.configure(this, 1, 6, "RW", 0, 'h0, 1, 1, 0);
            this.START_CONVERSION = uvm_reg_field::type_id::create("START_CONVERSION");
            this.START_CONVERSION.configure(this, 1, 8, "RW", 1, 'h0, 1, 1, 0);
            this.INCREMENTAL_MODE_EN = uvm_reg_field::type_id::create("INCREMENTAL_MODE_EN");
            this.INCREMENTAL_MODE_EN.configure(this, 1, 9, "RW", 0, 'h0, 1, 1, 0);
            this.NOISE_SHAPING_EN = uvm_reg_field::type_id::create("NOISE_SHAPING_EN");
            this.NOISE_SHAPING_EN.configure(this, 1, 10, "RW", 0, 'h0, 1, 1, 0);
            this.NFFT_POWER = uvm_reg_field::type_id::create("NFFT_POWER");
            this.NFFT_POWER.configure(this, 4, 11, "RW", 0, 'h0, 1, 1, 0);
        endfunction : build
    endclass : adc_regs__ADC_CTRL

    // reg - adc_regs::STATUS_RB_1
    class adc_regs__STATUS_RB_1 extends uvm_reg;
        `uvm_object_utils(adc_regs__STATUS_RB_1)
        rand uvm_reg_field MAIN_STATE_RB;
        rand uvm_reg_field SYNC_RESET_RB;

        function new(string name = "adc_regs__STATUS_RB_1");
            super.new(name, 16, UVM_NO_COVERAGE);
        endfunction : new

        virtual function void build();
            this.MAIN_STATE_RB = uvm_reg_field::type_id::create("MAIN_STATE_RB");
            this.MAIN_STATE_RB.configure(this, 4, 0, "RO", 1, 'h0, 1, 1, 0);
            this.SYNC_RESET_RB = uvm_reg_field::type_id::create("SYNC_RESET_RB");
            this.SYNC_RESET_RB.configure(this, 1, 4, "RO", 1, 'h0, 1, 1, 0);
        endfunction : build
    endclass : adc_regs__STATUS_RB_1

    // reg - adc_regs::STATUS_RB_2
    class adc_regs__STATUS_RB_2 extends uvm_reg;
        `uvm_object_utils(adc_regs__STATUS_RB_2)
        rand uvm_reg_field N_VALID_SAMPLES;

        function new(string name = "adc_regs__STATUS_RB_2");
            super.new(name, 16, UVM_NO_COVERAGE);
        endfunction : new

        virtual function void build();
            this.N_VALID_SAMPLES = uvm_reg_field::type_id::create("N_VALID_SAMPLES");
            this.N_VALID_SAMPLES.configure(this, 15, 0, "RO", 1, 'h0, 1, 1, 0);
        endfunction : build
    endclass : adc_regs__STATUS_RB_2

    // mem - adc_regs::adc_output_mem
    class adc_regs__adc_output_mem extends uvm_reg_block;
        `uvm_object_utils(adc_regs__adc_output_mem)
        rand uvm_mem m_mem;
        
        function new(string name = "adc_regs__adc_output_mem");
            super.new(name);
        endfunction : new

        virtual function void build();
            this.default_map = create_map("reg_map", 0, 2.0, UVM_NO_ENDIAN);
            this.m_mem = new("m_mem", 16384, 16, "RO");
            this.m_mem.configure(this);
            this.default_map.add_mem(this.m_mem, 0);
        endfunction : build
    endclass : adc_regs__adc_output_mem

    // addrmap - adc_regs
    class adc_regs extends uvm_reg_block;
        `uvm_object_utils(adc_regs)
        rand adc_regs__OSR OSR;
        rand adc_regs__active_passive_reg SH_CTRL;
        rand adc_regs__active_passive_reg INT1_CTRL;
        rand adc_regs__active_passive_reg INT2_CTRL;
        rand adc_regs__ADC_CTRL ADC_CTRL;
        rand adc_regs__STATUS_RB_1 STATUS_RB_1;
        rand adc_regs__STATUS_RB_2 STATUS_RB_2;
        rand adc_regs__adc_output_mem adc_output_mem;

        function new(string name = "adc_regs");
            super.new(name);
        endfunction : new

        virtual function void build();
            this.default_map = create_map("reg_map", 0, 2, UVM_NO_ENDIAN);
            this.OSR = adc_regs__OSR::type_id::create("OSR");
            this.OSR.configure(this);

            this.OSR.build();
            this.default_map.add_reg(this.OSR, 'h0);
            this.SH_CTRL = adc_regs__active_passive_reg::type_id::create("SH_CTRL");
            this.SH_CTRL.configure(this);

            this.SH_CTRL.build();
            this.default_map.add_reg(this.SH_CTRL, 'h2);
            this.INT1_CTRL = adc_regs__active_passive_reg::type_id::create("INT1_CTRL");
            this.INT1_CTRL.configure(this);

            this.INT1_CTRL.build();
            this.default_map.add_reg(this.INT1_CTRL, 'h4);
            this.INT2_CTRL = adc_regs__active_passive_reg::type_id::create("INT2_CTRL");
            this.INT2_CTRL.configure(this);

            this.INT2_CTRL.build();
            this.default_map.add_reg(this.INT2_CTRL, 'h6);
            this.ADC_CTRL = adc_regs__ADC_CTRL::type_id::create("ADC_CTRL");
            this.ADC_CTRL.configure(this);

            this.ADC_CTRL.build();
            this.default_map.add_reg(this.ADC_CTRL, 'h8);
            this.STATUS_RB_1 = adc_regs__STATUS_RB_1::type_id::create("STATUS_RB_1");
            this.STATUS_RB_1.configure(this);

            this.STATUS_RB_1.build();
            this.default_map.add_reg(this.STATUS_RB_1, 'ha);
            this.STATUS_RB_2 = adc_regs__STATUS_RB_2::type_id::create("STATUS_RB_2");
            this.STATUS_RB_2.configure(this);

            this.STATUS_RB_2.build();
            this.default_map.add_reg(this.STATUS_RB_2, 'hc);
            this.adc_output_mem = adc_regs__adc_output_mem::type_id::create("adc_output_mem");
            this.adc_output_mem.configure(this);
            this.adc_output_mem.build();
            this.default_map.add_submap(this.adc_output_mem.default_map, 'h8000);
        endfunction : build
    endclass : adc_regs

endpackage: adc_regs_pkg
