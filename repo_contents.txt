'''
Alex Knowlton
4/1/2025

Class definition for modeling a noise-shaping SAR ADC
using the Silva-Steensgard architecture, with an
optional reset
'''

from scipy.signal import windows
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import pdb

class NSSAR:

    def __init__(self, n_quantizer_bits=3, cap_mismatch_sigma=0.05, \
                 vdd=1.0, vss=0, max_nfft=2**20, max_osr=256):
        '''
        set class with hardware constraints and initialize register fields
        with default functions
        '''
        self._reg = {
            'nfft': 2**12,
            'osr': 32,
            'fs': 100e6,
            'do_dwa': True,
            'reset_dwa': True
        }
        self._cp = np.random.normal(1, cap_mismatch_sigma, \
                                    2 ** n_quantizer_bits)
        self._cn = np.random.normal(1, cap_mismatch_sigma, \
                                    2 ** n_quantizer_bits)
        self._generate_loop_arrays()
        self._result_memory = np.zeros(max_nfft, dtype=int)
        self._max_osr = max_osr
        self._vrefp = vdd
        self._vrefn = vss

    def convert(self, signal_specs):
        '''
        Converts a list of dictionaries of the type below and stores them
        in memory
        {
            'amplitude': a_in,
            'frequency': f_in
            'phase': phi_in
        }
        '''
        print('Beginning DSM Loop')
        self._generate_control_signals()
        self._generate_input_signals(signal_specs)
        nfft_derived = self._reg['nfft'] * self._reg['osr']
        for i in range(nfft_derived):
            self._calculate_integrator_to_quantizer(i)
            self._calculate_sample_to_quantizer(i)
            self._quantize(i)
            self._update_dwa(i)
            self._update_analog_integrators(i)
            self._update_incremental_integrators(i)
        self._write_data_to_memory()

    def write_register_value(self, key, value):
        '''
        writes a register value if the key is valid and if the value is valid
        if the key is not valid, throws an UnfoundRegisterError
        if the value is not valid, throws an IllegalRegisterValueError
        '''
        self._validate_register_write_value(key, value)
        self._reg[key] = value
        self._generate_loop_arrays()

    def read_register_value(self, key):
        '''
        if the register exists, return the value
        if the register does not exist, throw an UnfoundRegisterError
        '''
        self._validate_register_read_value(key)
        return self._reg[key]

    def read_output_data(self):
        '''
        Return nfft values from device memory as a Pandas Series
        with time-series indices
        '''
        return pd.Series(self._result_memory[:self._reg['nfft']], self._t) 

    def read_conversion_data(self):
        '''
        Return osr * (nfft + n_offset) values from the conversion as a Pandas
        DataFrame with time-series index
        '''
        output = pd.DataFrame()
        output['t'] = self._t
        output['U'] = self._u
        output['Qin_sample'] = self._qin_sample
        output['Qin_integ'] = self._qin_integ
        output['v_inp'] = self._vinp
        output['v_inn'] = self._vinn
        output['v_intp'] = self._vintp
        output['v_intn'] = self._vintn
        output['E'] = self._error
        output['I1'] = self._i1
        output['I2'] = self._i2
        output['V'] = self._v
        output['D1_inc'] = self._d1_incremental
        output['D2_inc'] = self._d2_incremental
        output['reset'] = self._reset
        output['sample_output'] = self._sample_output
        output['DWA_pointer'] = self._dwa_pointer
        output = output.set_index('t')
        return output

    def plot_output_fft(self, ax=None, color=None, label=None):
        '''
        Plot the FFT of the output and return a handle of the figure object
        on which it's plotted. If ax is none, create and set up a new figure
        and return it. If ax is not none, assume it's already set up and plot
        on that
        '''
        color = 'k' if color is None else color
        q_data = self._get_windowed_fft_data()
        T = self._reg['osr'] / self._reg['fs']
        freqs = np.fft.fftfreq(self._reg['nfft'], T)[1:1+(self._reg['nfft'] // 2)]
        freqs[-1] *= -1
        fft_pow = np.real(q_data * np.conj(q_data))
        i_max_pow = np.argmax(fft_pow[3:]) + 3  # bin smearing due to Blackman
        fft_pow /= fft_pow[i_max_pow]
        fft_pow_db = 10 * np.log10(fft_pow)
        if ax is None:
            fig, ax = plt.subplots()
            # ax.set_xscale('log')
            ax.set_xlabel('Input Frequency')
            ax.set_ylabel('Output PSD')
            ax.set_title('Output FFT')
        else:
            fig = ax.get_figure()
        if label is None:
            ax.plot(freqs[2:], fft_pow_db[2:], color, linewidth=0.5, \
                    alpha=0.5)
        else:
            ax.plot(freqs[2:], fft_pow_db[2:], color, linewidth=0.5, \
                    label=label, alpha=0.5)
        return fig

    def plot_quantizer_fft(self, ax=None):
        '''
        Plot the FFT of the output and return a handle of the figure object
        on which it's plotted. If ax is none, create and set up a new figure
        and return it. If ax is not none, assume it's already set up and plot
        on that
        '''
        q_data = self._get_windowed_fft_data(True)
        T = 1 / self._reg['fs']
        nfft_derived = self._reg['nfft'] * self._reg['osr']
        freqs = np.fft.fftfreq(nfft_derived, T)[1:1+(nfft_derived // 2)]
        freqs[-1] *= -1
        fft_pow = np.real(q_data * np.conj(q_data))
        i_max_pow = np.argmax(fft_pow[3:]) + 3  # bin smearing due to Blackman
        fft_pow /= fft_pow[i_max_pow]
        fft_pow_db = 10 * np.log10(fft_pow)
        if ax is None:
            fig, ax = plt.subplots()
            ax.set_xscale('log')
            ax.set_xlabel('Input Frequency')
            ax.set_ylabel('Quantizer PSD')
            ax.set_title('Quantizer FFT')
        else:
            fig = ax.get_figure()
        ax.plot(freqs[2:], fft_pow_db[2:])
        critical_frequency = self._reg['fs'] / (2 * self._reg['osr'])
        ax.axvline(x=critical_frequency, color='red', linestyle='--')
        return fig

    def plot_output_data(self, n_samples, ax=None):
        '''
        plots the output data in the interval (n_offset, n_offset + n_samples)
        on the given axis and returns a handle to the figure on which it is
        plotted
        '''
        plot_data = self._result_memory[:n_samples]
        plot_time = self._t[self._sample_output]
        plot_time = plot_time[-self._reg['nfft']:]
        plot_time = plot_time[:n_samples]
        if ax is None:
            fig, ax = plt.subplots()
            ax.set_xlabel('Sample Time [s]')
            ax.set_ylabel('ADC Output')
        else:
            fig = ax.get_figure()
        ax.plot(plot_time, plot_data)
        return fig

    def get_sndr(self):
        '''
        Returns the SNDR of the last conversion. If no conversion has been
        done yet, return 0
        '''
        fft_data = self._get_windowed_fft_data()[2:]  # filter out DC data
        fft_pow = np.real(fft_data * np.conj(fft_data))
        i_max_power = np.argmax(fft_pow)
        signal_slice = np.arange(i_max_power-2, i_max_power+3)
        filt = np.zeros(fft_pow.shape[0], dtype=bool)
        filt[signal_slice] = True
        is_signal_indices = filt
        signal_power = np.sum(fft_pow[is_signal_indices])
        noise_power = np.sum(fft_pow[~is_signal_indices])
        sndr = signal_power / noise_power
        sndr_db = 10 * np.log10(sndr)
        return sndr_db

    def get_sfdr(self):
        '''
        Returns the SFDR of the last conversion. If no conversion has been
        done yet, return 0
        '''
        fft_data = self._get_windowed_fft_data()[2:]  # filter out DC data
        fft_pow = np.real(fft_data * np.conj(fft_data))
        i_max_power = np.argmax(fft_pow)
        noise_slice_to_signal = np.arange(i_max_power-2)
        noise_signal_to_fs = np.arange(i_max_power+3, fft_pow.shape[0])
        indices = np.zeros(fft_pow.shape[0], dtype=bool)
        is_noise_slice_low = indices
        is_noise_slice_low[noise_slice_to_signal] = True
        is_noise_slice_high = indices
        is_noise_slice_low[noise_signal_to_fs] = True
        signal_power = fft_pow[i_max_power]
        noise_power_low = fft_pow[is_noise_slice_low]
        noise_power_high = fft_pow[is_noise_slice_high]
        max_pow_low = np.max(noise_power_low)
        max_pow_high = np.max(noise_power_high)
        noise_power = np.max((max_pow_high, max_pow_low))
        sfdr = signal_power / noise_power
        sfdr_db = 10 * np.log10(sfdr)
        return sfdr_db

    def _fp_quantize(self, value):
        '''
        quantizes the input value to the internal (N, R) values
        '''
        N = self._n_fixed_point_bits
        R = self._n_fractional_bits
        max_value = 2 ** (N - 1) - 1
        min_value = -(2 ** (N - 1))
        value = value * (2 ** R)
        value = np.floor(value).astype(int)
        is_over_max = value > max_value
        is_under_min = value < min_value
        value[is_over_max] = max_value
        value[is_under_min] = min_value
        return value
    
    def _fp_add(self, a, b):
        pass

    def _fp_mult(self, a, b):
        pass

    def _generate_loop_arrays(self):
        '''
        generates loop arrays for IADC and DSM conversion
        '''
        # derived parameters
        T = 1 / self._reg['fs']
        n_total_samples = self._reg['nfft'] * self._reg['osr']
        self._t = np.arange(n_total_samples) * T
        self._error = np.zeros(self._t.shape)
        self._i1 = np.zeros(self._t.shape)
        self._i2 = np.zeros(self._t.shape)
        self._d1_incremental = np.zeros(self._t.shape)
        self._d2_incremental = np.zeros(self._t.shape)
        self._qin_sample = np.zeros(self._t.shape)
        self._qin_integ = np.zeros(self._t.shape)
        self._dwa_pointer = np.zeros(self._t.shape, dtype=int)
        self._v = np.zeros(self._t.shape, dtype=int)
        self._dac_output = np.zeros(self._t.shape)
        self._vinp = np.zeros(self._t.shape)
        self._vinn = np.zeros(self._t.shape)
        self._vintp = np.zeros(self._t.shape)
        self._vintn = np.zeros(self._t.shape)

    def _generate_control_signals(self):
        '''
        Generate reset and sample_output signals
        '''
        osr = self._reg['osr']
        n_samples = self._reg['nfft'] * osr
        i = np.arange(n_samples)
        self._reset = (i % osr == 0)
        self._sample_output = (i % osr) == (osr - 1)


    def _generate_input_signals(self, data):
        '''
        Generates input signal U and stores as a class variable
        '''
        self._u = self._t * 0
        for d in data:
            u = d['amplitude'] * \
                np.cos(2 * np.pi * d['frequency'] * self._t + d['phase'])
            self._u += u

    def _calculate_integrator_to_quantizer(self, i):
        '''
        calculate vintp and vintn to the quantizer
        '''
        vcm = (self._vrefp + self._vrefn) / 2
        if self._reset[i]:
            self._qin_integ[i] = 0
        else:
            self._qin_integ[i] = 2 * self._i1[i - 1] + self._i2[i - 1]
        self._vintp[i] = vcm + self._qin_integ[i] / 2
        self._vintn[i] = vcm - self._qin_integ[i] / 2

    def _calculate_sample_to_quantizer(self, i):
        '''
        calculate vinp and vinn to the quantizer
        '''
        self._qin_sample[i] = self._u[i]
        vcm = (self._vrefp + self._vrefn) / 2
        self._vinp[i] = vcm + self._qin_sample[i] / 2
        self._vinn[i] = vcm - self._qin_sample[i] / 2

    def _quantize(self, i):
        '''
        quantizer input with DWA, if applicable
        '''
        not_using_dwa = (i == 0) or (not self._reg['do_dwa'])
        reset_dwa_pointer = self._reset[i] and self._reg['do_dwa'] and \
            self._reg['reset_dwa']
        if (not_using_dwa or reset_dwa_pointer):
            pointer = 0
        else:
            pointer = self._dwa_pointer[i - 1]
        self._v[i], self._dac_output[i] = self._run_sar(i, pointer)
        self._error[i] = self._dac_output[i]

    def _update_dwa(self, i):
        '''
        Update DWA pointer by adding the last quantizer value
        '''
        pointer = self._dwa_pointer[i - 1]
        pointer += self._v[i]
        max_pointer_value = self._cp.shape[0]
        self._dwa_pointer[i] = pointer % max_pointer_value

    def _update_analog_integrators(self, i):
        if self._reset[i]:
            self._i1[i] = self._error[i]
            self._i2[i] = 0
        else:
            self._i1[i] = self._error[i] + self._i1[i - 1]
            self._i2[i] = self._i1[i - 1] + self._i2[i - 1]

    def _update_incremental_integrators(self, i):
        if self._reset[i]:
            self._d1_incremental[i] = self._v[i]
            self._d2_incremental[i] = self._d1_incremental[i]
        else:
            self._d1_incremental[i] = self._v[i] + self._d1_incremental[i - 1]
            self._d2_incremental[i] = self._d1_incremental[i] + \
                self._d2_incremental[i - 1]

    def _write_data_to_memory(self):
        adc_data = self._d2_incremental[self._sample_output]
        self._result_memory[:self._reg['nfft']] = adc_data[-self._reg['nfft']:]

    def _get_fft_frequencies(self, use_quantizer_data=False):
        '''
        Return frequencies of fft as frequency, not normalized to fs. If using
        quantizer, go up to fs / 2, else only go up to fs / (2 * osr)
        '''
        if use_quantizer_data:
            top_nfft_num = self._reg['osr'] * self._reg['nfft']
        else:
            top_nfft_num = self._reg['nfft']
        top_nfft_num = top_nfft_num // 2
        freqs = np.arange(top_nfft_num) + 1
        return self._reg['fs'] * freqs / (2 * top_nfft_num)

    def _get_windowed_fft_data(self, use_quantizer_data=False):
        '''
        Return windowed fft data, using the Blackman window,
        as power normalized to the fundamental tone(s)
        if not use_quantizer_data, use the output data
        '''
        if use_quantizer_data:
            top_nfft_num = self._reg['osr'] * self._reg['nfft']
            data = self._v[-top_nfft_num:]
        else:
            top_nfft_num = self._reg['nfft']
            data = self._result_memory[:top_nfft_num]
        fft_window = windows.blackman(top_nfft_num)
        windowed_data = fft_window * data
        return np.fft.fft(windowed_data)[1:(1 + top_nfft_num // 2)]
    
    def _run_sar(self, j, pointer):
        '''
        Actually runs SAR adc loop
        '''
        cp = self._cp
        cn = self._cn
        n_bits = int(np.log2(len(cp)))

        # roll capacitor values if using DWA
        cp = np.roll(cp, -pointer)
        cn = np.roll(cn, -pointer)

        # residue voltage for all conversions, at all points in conversion
        vresp = np.zeros(n_bits + 1)
        vresn = np.zeros(n_bits + 1)
        bits = np.zeros(n_bits, dtype=int)

        vcm = (self._vrefp + self._vrefn) / 2

        cap_values = np.zeros(2**n_bits) + vcm
        vresp[0] = self._vrefp - self._vinp[j]
        vresn[0] = self._vrefp - self._vinn[j]
        for i in range(n_bits):
            filt = self._vintp[j] + vresn[i] >= self._vintn[j] + vresp[i]
            bits[i] = 1 * filt
            cap_values = self._update_cap_values(cap_values, i, filt)
            inverted_cap_values = 1 - cap_values
            qp = np.sum(cp * (cap_values)) + np.sum(cp) * (vresp[0] - vcm)
            qn = np.sum(cn * (inverted_cap_values)) + np.sum(cn) * (vresn[0] - vcm)
            vresp[i + 1] = qp / np.sum(cp)
            vresn[i + 1] = qn / np.sum(cn)
        bits_calc = n_bits - 1
        positive_bits = bits_calc - np.where(bits == 1)[0]
        return np.sum(np.power(2, positive_bits)), vresn[n_bits] - vresp[n_bits]

    def _update_cap_values(self, cap_values, i, bit):
        '''
        Update capacitor voltages to either 1 or 0 depending on the SAR conversion
        '''
        # calculate slice to update
        n_bits = int(np.log2(cap_values.shape[0]))
        n_update_bits = 2**(n_bits - (i + 1))
        update_slice = np.where(cap_values == 0.5)[0]
        if bit:
            cap_values[update_slice[:n_update_bits]] = 1
        else:
            cap_values[update_slice[-(n_update_bits + 1):-1]] = 0
        return cap_values

    class UnfoundRegisterError(Exception):
        def __init__(self, register_name):
            super().__init__(f'Register name \'{register_name}\' not found')

    class IllegalRegisterValueError(Exception):
        def __init__(self, key, value):
            super().__init__(f'Value {value} illegal for register {key}')

    def _validate_register_write_value(self, key, value):
        '''
        Check that register write values are legal. If the key is not found,
        raise a new UnfoundRegisterError. If the value is not legal, raise a
        new IllegalRegisterValueError
        '''
        self._validate_register_key(key)
        is_legal_nfft_value = (key == 'nfft') and \
            (type(value) == type(1)) and \
            (value <= self._result_memory.shape[0])
        is_legal_osr_value = (key == 'osr') and (value <= self._max_osr)
        is_legal_fs = (key == 'fs') and (type(value) == type(1))
        is_legal_boolean_value = type(value) == type(True)
        is_legal_register_value = is_legal_nfft_value or is_legal_osr_value \
            or is_legal_fs or is_legal_boolean_value
        if not is_legal_register_value:
            raise IllegalRegisterValueError(key, value)
        
    def _validate_register_key(self, key):
        '''
        Check that register read value is legal. If the key is not found,
        raise a new UnfoundRegisterError.
        '''
        if key not in self._reg.keys():
            raise UnfoundRegisterError(key)'''
Alex Knowlton
3/24/2025

Simulation for a noise-shaping 2nd order SAR ADC with 1st-order DEM
'''


import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import iirfilter, lfilter, windows
from scipy.fft import fft
import pdb


def adc_loop():
    '''
    Main simulation loop
    '''
    # circuit/testing parameters
    quantizer_bits = 3
    sigma = 0.02
    use_mismatch = False
    fs = 10**8 # 100 MHz for now
    prime = 97
    vdd = 1
    vss = 0
    vcm = (vdd - vss) / 2

    # control registers
    osr = 16
    nfft = 2**12
    incremental_mode = True
    use_dwa = True
    reset_dwa = True
    n_offset = 10000 if not incremental_mode else 0

    # derived parameters
    T = 1 / fs
    nfft_derived = nfft * osr
    fin = fs * prime / nfft_derived
    a_in = 0.4  # vdd * 10 ** (-6 / 20)

    # calculate filter coefficients
    normalized_fc = 1 / (osr)
    b, a = iirfilter(4, normalized_fc, btype='lowpass', output='ba', ftype='butter')

    # calculate mismatched capacitor arrays if using mismatch, all 1 otherwise
    cp = get_cap_array(quantizer_bits, sigma, use_mismatch)
    cn = get_cap_array(quantizer_bits, sigma, use_mismatch)
    pdb.set_trace()

    # time signal
    t = T * np.arange(n_offset + nfft_derived)

    # input signal
    U = a_in * np.cos(2 * np.pi * fin * t)
    # U = U * 0 + 0.8
    E = np.zeros(t.shape)

    # analog integrators
    I1 = np.zeros(t.shape)
    I2 = np.zeros(t.shape)

    # digital integrators
    D1_continuous = np.zeros(t.shape, dtype=int)
    D1_incremental = np.zeros(t.shape, dtype=int)
    D2_incremental = np.zeros(t.shape, dtype=int)

    # SAR quantizer inputs
    Qin_sample = np.zeros(t.shape)
    Qin_integ = np.zeros(t.shape)

    # boolean signals, useful for logic development later
    reset = np.zeros(t.shape, dtype=bool)
    sample_output = np.zeros(t.shape, dtype=bool)
    dwa_pointer = np.zeros(t.shape, dtype=int)  # don't use this yet

    # quantizer output
    V = np.zeros(t.shape)
    dac_output = np.zeros(t.shape)

    # differential input signals
    vinp = np.zeros(t.shape)
    vinn = np.zeros(t.shape)
    vintp = np.zeros(t.shape)
    vintn = np.zeros(t.shape)
    # IADC loop
    for i in range(t.shape[0]):
        # sample input
        reset[i] = ((i % osr) == 0 and incremental_mode) or (i == 0)
        sample_output[i] = (i % osr) == (osr - 1)
        Qin_sample[i] = U[i]

        # calculate integrator input to quantizer
        if (reset[i] or (i == 0)):
            Qin_integ[i] = 0
        else:
            Qin_integ[i] = 2 * I1[i - 1] + I2[i - 1]
        
        # convert to differential voltages
        vintp[i] = vcm + Qin_integ[i] / 2 
        vintn[i] = vcm - Qin_integ[i] / 2
        vinp[i] = vcm + Qin_sample[i] / 2
        vinn[i] = vcm - Qin_sample[i] / 2
        
        # quantize with DWA
        if ((i == 0) or (not use_dwa) or (reset[i] and use_dwa and reset_dwa)):
            pointer = 0
        else:
            pointer = dwa_pointer[i - 1]
        V[i], dac_output[i] = sar_quantize(vinp[i], vinn[i], vintp[i], vintn[i], cp, cn, pointer)
        E[i] = dac_output[i]
        pointer += V[i]
        dwa_pointer[i] = pointer % (2 ** quantizer_bits)
        # pdb.set_trace()
        # V[i] = quantize(vinp[i], vinn[i], vintp[i], vintn[i])
        # E[i] = U[i] - V[i]
        # update analog integrators
        if (reset[i] or (i == 0)):
            I1[i] = E[i]
            I2[i] = 0
        else:
            I1[i] = E[i] + I1[i - 1]
            I2[i] = I1[i - 1] + I2[i - 1]
        
        # update digital integrators
        if (reset[i] or (i == 0)):
            D1_incremental[i] = V[i]
            D2_incremental[i] = D1_incremental[i]
        else:
            D1_incremental[i] = V[i] + D1_incremental[i - 1]
            D2_incremental[i] = D1_incremental[i] + D2_incremental[i - 1]

    incremental_out = D2_incremental[sample_output] * 1 / (2 * osr * (osr + 1)) - ((2 ** quantizer_bits - 1) / (2 ** quantizer_bits))
    plt.figure()
    plt.subplot(2, 1, 1)
    plt.plot(incremental_out[-nfft:], linewidth=0.5)
    plt.subplot(2, 1, 2)
    fft_vals = fft(incremental_out[-nfft:])
    fft_pow = np.real(fft_vals * np.conj(fft_vals))
    fft_pow_trimmed = fft_pow[1:1 + (nfft // 2)]
    fft_pow_trimmed[-1] /= 2
    fft_pow_db = 10 * np.log10(fft_pow_trimmed)
    freq = np.arange(1, (nfft // 2) + 1) * fs / nfft
    plt.plot(freq, fft_pow_db, linewidth=0.5)
    plt.figure()
    V = V - (2 ** quantizer_bits - 1) / 2
    vfilt = lfilter(b, a, V[-nfft_derived:], axis=0)
    continuous_out = vfilt[sample_output[-nfft_derived:]]
    plt.subplot(3, 1, 1)
    fft_window = windows.hann(nfft_derived)
    fft_data = fft_window * vfilt
    plt.loglog(np.abs(fft(V[-nfft_derived:])))
    plt.subplot(3, 1, 2)
    fft_window = windows.blackman(nfft_derived)
    fft_data = fft_window * vfilt[-nfft_derived:]
    plt.loglog(np.abs(fft(fft_data)))
    plt.subplot(3, 1, 3)
    vfilt_out = vfilt[-nfft_derived:]
    vfilt_out = vfilt_out[sample_output[-nfft_derived:]]
    fft_window = windows.blackman(nfft)
    fft_data = fft_window * vfilt_out
    fft_to_plot = np.abs(fft(fft_data))
    plt.loglog(fft_to_plot[:(nfft//2)])
    pdb.set_trace()


def get_cap_array(n_bits, sigma, use_mismatch):
    '''
    Returns an array of 2^n_bits capacitor values drawn from a
    normal distribution with a standard deviation of sigma
    '''
    if use_mismatch:
        return np.random.normal(1, sigma, 2**n_bits)
    else:
        return np.ones(2**n_bits)


def quantize(vip, vin, vintp, vintn):
    '''
    single-bit quantizer function
    '''
    U = vip - vin
    W = vintp - vintn
    V = 1 if (U + W) > 0 else -1
    return V


def sar_quantize(vip, vin, vintp, vintn, cp, cn, dwa_pointer=0):
    '''
    SAR quantizer function using two integrators and cap update functions
    also uses positive and negative reference voltages for more accurate numbers
    additionally, user can set the DWA pointer to shift the update voltages
    for DEM
    '''
    n_bits = int(np.log2(len(cp)))
    vrefp = 1
    vrefn = 0

    # roll capacitor values if using DWA
    cp = np.roll(cp, -dwa_pointer)
    cn = np.roll(cn, -dwa_pointer)

    # residue voltage for all conversions, at all points in conversion
    vresp = np.zeros(n_bits + 1)
    vresn = np.zeros(n_bits + 1)
    bits = np.zeros(n_bits, dtype=int)

    vcm = (vrefp + vrefn) / 2

    cap_values = np.zeros(2**n_bits) + vcm
    vresp[0] = vrefp - vip
    vresn[0] = vrefp - vin
    for i in range(n_bits):
        filt = vintp + vresn[i] >= vintn + vresp[i]
        bits[i] = 1 * filt
        cap_values = update_cap_values(cap_values, i, filt)
        inverted_cap_values = 1 - cap_values
        qp = np.sum(cp * (cap_values)) + np.sum(cp) * (vresp[0] - vcm)
        qn = np.sum(cn * (inverted_cap_values)) + np.sum(cn) * (vresn[0] - vcm)
        vresp[i + 1] = qp / np.sum(cp)
        vresn[i + 1] = qn / np.sum(cn)
    bits_calc = n_bits - 1
    positive_bits = bits_calc - np.where(bits == 1)[0]
    return np.sum(np.pow(2, positive_bits)), vresn[n_bits] - vresp[n_bits]


def update_cap_values(cap_values, i, bit):
    '''
    Update capacitor voltages to either 1 or 0 depending on the SAR conversion
    '''
    # calculate slice to update
    n_bits = int(np.log2(cap_values.shape[0]))
    n_update_bits = 2**(n_bits - (i + 1))
    update_slice = np.where(cap_values == 0.5)[0]
    if bit:
        cap_values[update_slice[:n_update_bits]] = 1
    else:
        cap_values[update_slice[-(n_update_bits + 1):-1]] = 0
    return cap_values


def plot_sar_conversion():
    vin = np.arange(-1, 1.001, 0.001)
    vres = np.zeros(vin.shape)
    dout = np.zeros(vin.shape)
    vcm = 0.5
    caps = np.ones(8)
    for i in range(len(vin)):
        vp = vin[i] / 2 + vcm
        vn = -vin[i] / 2 + vcm
        d, v = sar_quantize(vp, vn, 0, 0, caps, caps, 0)
        dout[i] = d
        vres[i] = v
    plt.figure()
    plt.subplot(2, 1, 1)
    plt.plot(vin, dout)
    plt.grid()
    plt.title('SAR Quantization Across Voltage')
    plt.ylabel('Digital Output')
    plt.subplot(2, 1, 2)
    plt.plot(vin, vres)
    plt.xlabel('$V_{in}$')
    plt.ylabel('$V_{res}$')
    plt.grid()


def main():
    '''
    Main loop
    '''
    plot_sar_conversion()
    adc_loop()
    plt.show()


if __name__ == '__main__':
    main()from nssar import NSSAR
import pdb
import numpy as np


def test_fft_plots():
    sar = NSSAR(cap_mismatch_sigma=0.1)
    sar.write_register_value('do_dwa', False)
    fs = 100e6
    prime = 97
    nfft = 2**12
    signal_specs = [
        {
            'amplitude': 0.4,
            'frequency': fs * prime / (16 * nfft),
            'phase': 0
        }
    ]
    sar.convert(signal_specs)
    fig_data = sar.plot_output_data(1000)
    fig_fft = sar.plot_quantizer_fft()
    fig_output_fft = sar.plot_output_fft()
    fig_data.savefig('./img/quantizer_data.png')
    fig_fft.savefig('./img/quantizer_fft.png')
    fig_output_fft.savefig('./img/output_fft.png')
    sndr = sar.get_sndr()
    sfdr = sar.get_sfdr()
    print(f'SAR SNDR: {np.round(sndr, 2)} dB')
    print(f'SAR SFDR: {np.round(sfdr, 2)} dB')


def test_dwa():
    sar = NSSAR(cap_mismatch_sigma=0.1)
    fs = 100e6
    prime = 997
    nfft = 2**15
    signal_specs = [
        {
            'amplitude': 0.4,
            'frequency': fs * prime / (16 * nfft),
            'phase': 0
        }
    ]
    sndr = list()
    sfdr = list()
    sar.convert(signal_specs)
    sndr.append(sar.get_sndr())
    sfdr.append(sar.get_sfdr())
    fig = sar.plot_output_fft(label='DWA w/Reset')
    ax = fig.get_axes()[0]
    sar.write_register_value('reset_dwa', False)
    sar.convert(signal_specs)
    sndr.append(sar.get_sndr())
    sfdr.append(sar.get_sfdr())
    sar.plot_output_fft(ax, color='b', label='DWA w/o Reset')
    sar.write_register_value('do_dwa', False)
    sar.convert(signal_specs)
    sar.plot_output_fft(ax, color='r', label='No DWA')
    ax.legend()
    sndr.append(sar.get_sndr())
    sfdr.append(sar.get_sfdr())
    print(sndr)
    print(sfdr)
    fig.savefig('./img/dwa_compare.png')


def main():
    test_fft_plots()
    test_dwa()


if __name__ == '__main__':
    main()'''
Script: gen_registers.py

Generates the following for the ADC registers:

- HTML description page
- UVM register package
- SystemVerilog RTL using <OBI: https://github.com/openhwgroup/obi> as a
  register interface
- A synchronizer that goes from the SPI clock to the system clock, if necessary
'''


import sys
import argparse
from systemrdl import RDLCompiler, RDLCompileError
from peakrdl_uvm import UVMExporter
from peakrdl_html import HTMLExporter
from peakrdl_regblock import RegblockExporter
from peakrdl_regblock.cpuif.obi import OBI_Cpuif
from peakrdl_regblock.udps import ALL_UDPS
from synchronizer_exporter import RTLSyncExporter


# Variable: DEFAULT_RDL_SPEC
# Defines the default path to the RDL register spec file
DEFAULT_RDL_SPEC = './hdl_design/hdl_design.srcs/registers/registers.rdl'

# Variable: DEFAULT_HTML_PATH
# Defines the default path to the directory in which the HTML documentation
# will be stored
DEFAULT_HTML_PATH = './adc_regs'

# Variable: DEFAULT_UVM_PKG_PATH
# Defines the default path to the file which will contain UVM registers
DEFAULT_UVM_PKG_PATH = \
    './hdl_design/hdl_design.srcs/dv/reg_env/adc_regs_pkg.svh'

# Variable: DEFAULT_REG_RTL_PATH
# Path to the directory in which the RTL package and path will be stored
DEFAULT_REG_RTL_PATH = './hdl_design/hdl_design.srcs/rtl/registers'

# Variable: DEFAULT_REG_SYNC_PATH
# Path to the file in which the ADC register synchronizer will be stored,
# if it's used
DEFAULT_REG_SYNC_PATH = \
    './hdl_design/hdl_design.srcs/rtl/registers/adc_reg_sync.sv'


'''
Function: parse_input_arguments

Parse the given keyword arguments using argparse. Use

--- Code
python registers.py --help
---

for more information about keyword args.
'''
def parse_input_arguments():
    parser = argparse.ArgumentParser()

    parser.add_argument('-s', '--spec', type=str, default=DEFAULT_RDL_SPEC,
                        help=f"RDL Spec path, default {DEFAULT_RDL_SPEC}")
    parser.add_argument('--html', type=str, default=DEFAULT_HTML_PATH,
                        help=f"Output HTML directory, default {
                            DEFAULT_HTML_PATH}")
    parser.add_argument('--uvmpkg', type=str, default=DEFAULT_UVM_PKG_PATH,
                        help=f'Output UVM register package path, default {
                            DEFAULT_UVM_PKG_PATH}')
    parser.add_argument('--rtl', type=str, default=DEFAULT_REG_RTL_PATH,
                        help=f'Output register RTL path, default {
                            DEFAULT_REG_RTL_PATH}')
    parser.add_argument('--sync', type=str, default=DEFAULT_REG_SYNC_PATH,
                        help=f'Output synchronizer path, default {
                            DEFAULT_REG_SYNC_PATH}')

    return parser.parse_args()


'''
Function: compile_rdl

Compile the RDL from the given RDL spec file and return the RDL Compiler object
that can be used for export.

Parameters:
    path - relative path from invocation to the RDL spec file

Returns:
    The elaborated RDL Compiler
'''
def compile_rdl(path):
    rdlc = RDLCompiler()

    for udp in ALL_UDPS:
        rdlc.register_udp(udp)

    try:
        rdlc.compile_file(path)
        root = rdlc.elaborate()
    except RDLCompileError:
        sys.exit(1)

    return root


'''
Function: gen_uvm_pkg

Generate UVM register model for the given RDL.

Parameters:
    root - the RDL compiler elaborated object used for export
    filename - the path to the desired file
'''
def gen_uvm_pkg(root, filename, **kwargs):
    exporter = UVMExporter(**kwargs)
    exporter.export(root, filename)


'''
Function: gen_html

Generate HTML documentation for the given RDL.

Parameters:
    root - the RDL compiler elaborated object used for export
    filename - the path to the desired HTML directory
'''
def gen_html(root, filename, **kwargs):
    exporter = HTMLExporter(**kwargs)
    exporter.export(root, filename)


'''
Function: gen_rtl

Generate SystemVerilog RTL for the given RTL

Parameters:
    root - the RDL compiler elaborated object used for export
    filename - the path to the desired RTL directory
'''
def gen_rtl(root, filename, **kwargs):
    exporter = RegblockExporter(**kwargs)
    exporter.export(root, filename, cpuif_cls=OBI_Cpuif,
                    default_reset_activelow=True, generate_hwif_report=True)


'''
Function: gen_sync

Generate SystemVerilog RTL for synchronizers to the interface clock

Parameters:
    root - the RDL compiler elaborated object used for export
    filename - the path to the desired RTL directory. Must end in .sv
'''
def gen_sync(root, filename, **kwargs):
    exporter = RTLSyncExporter(**kwargs)
    exporter.export(root, filename)


'''
Function: main

Runs RDL compiler and generates register export files.
'''
def main():
    args = parse_input_arguments()
    root = compile_rdl(args.spec)
    gen_uvm_pkg(root, args.uvmpkg)
    gen_html(root, args.html)
    gen_rtl(root, args.rtl)
    gen_sync(root, args.sync)


if __name__ == '__main__':
    main()
'''
Script: synchronizer_exporter

PeakRDL-compliant exporter for generating CDC synchronizers for generated
hardware interfaces from the interface clock and back again. Contains
the <RTLSyncExporter> class, which runs the export itself, and the
<RTLSyncExporterPlugin> class, which should run with the PeakRDL command-line
tool.
'''
from typing import TYPE_CHECKING
from peakrdl.plugins.exporter import ExporterSubcommandPlugin
from systemrdl.node import Node, AddrmapNode
from systemrdl.walker import RDLSimpleWalker
from systemrdl.walker import RDLListener
if TYPE_CHECKING:
    import argparse


'''
Class: RTLSyncExporter

For each field in the hardware interface, generates a CDC synchronizer that
goes ifclk -> sysclk if the field is hardware-readable, and sysclk -> ifclk if
the field is hardware-writeable. These two should be mutually exclusive.
'''
class RTLSyncExporter:

    '''
    Class: _SyncFieldListener

    Listener for a traversal of the top node that will generate a file at the
    initializer path when walked.
    '''
    class _SyncFieldListener(RDLListener):

        '''
        Function: __init__

        Parameters:
            path - the relative path at which the listener will create the
            output RTL.
        '''
        def __init__(self, path: str):
            super().__init__()

            last_path = path.split('.')[-1]
            if (last_path != 'sv'):
                raise ValueError('Path must point to a file ending in .sv')
            self.path = path

        '''
        Function: enter_Addrmap

        Defines what to do when an Addrmap node is first encountered. In this
        case, declares the {addrmap_name}_reg_sync module declaration.
        '''
        def enter_Addrmap(self, node):
            self.f = open(self.path, 'w')
            name = node.inst_name

            n_sync_stages = 2
            print(f'// Class: {name}_reg_sync', file=self.f)
            print('// Instantiates CDC synchronizers for the CSR registers.',
                  file=self.f)
            print(
                '// Automatically generated from registers.rdl using PeakRDL.',
                file=self.f)
            print('module #(', file=self.f)
            print(f'\tparameter N_SYNC_STAGES={n_sync_stages},', file=self.f)
            print(f'\tparameter SRC_INPUT_REG={0}', file=self.f)
            print(f') {name}_reg_sync (', file=self.f)
            print(f'\t{name}__in_t hwif_in_sysclk,', file=self.f)
            print(f'\t{name}__in_t hwif_in_ifclk,', file=self.f)
            print(f'\t{name}__out_t hwif_out_sysclk,', file=self.f)
            print(f'\t{name}__out_t hwif_out_ifclk,', file=self.f)
            print('\tinput logic sysclk,', file=self.f)
            print('\tinput logic ifclk\n);\n', file=self.f)

        '''
        Function: enter_Field

        Defines what to do when a Field node is first encountered. In this
        case, instantiates an instance of <sync_nstage> for that field. If the
        field is hw=r, then the synchronizer goes ifclk -> sysclk, otherwise
        sysclk -> ifclk.
        '''
        def enter_Field(self, node):
            # Print some stuff about the field
            sw_access_str = f"hw={node.get_property('hw').name}"
            hwif_path = node.get_path().split('.')[1:]
            hwif_path = '.'.join(hwif_path)
            if node.get_property('hw').name == 'r':
                hwif_name = 'hwif_out'
                hwif_value = 'value'
                hwif_srcclk = 'ifclk'
                hwif_destclk = 'sysclk'
            else:
                hwif_name = 'hwif_in'
                hwif_value = 'next'
                hwif_srcclk = 'ifclk'
                hwif_destclk = 'sysclk'

            hwif_in_path = f'{hwif_name}_{hwif_srcclk}.{
                hwif_path}.{hwif_value}'
            hwif_out_path = f'{hwif_name}_{hwif_destclk}.{
                hwif_path}.{hwif_value}'

            print('\tsync_nstage #(', file=self.f)
            print('\t\t.N_SYNC_STAGES(N_SYNC_STAGES),', file=self.f)
            print('\t\t.SRC_INPUT_REG(SRC_INPUT_REG),', file=self.f)
            print(f"\t\t.N_BITS({node.width})", file=self.f)
            print(f"\t) sync_{
                '.'.join(hwif_path.split('.')[1:3]).replace('.', '_')
                } (", file=self.f)
            print(f'\t\t.src_clk({hwif_srcclk}),', file=self.f)
            print(f'\t\t.dest_clk({hwif_destclk}),', file=self.f)
            print(f'\t\t.src_data({hwif_in_path}),', file=self.f)
            print(f'\t\t.dest_data({hwif_out_path})', file=self.f)
            print('\t);\n', file=self.f)

        '''
        Function: exit_Addrmap

        Defines the last thing to do when an Addrmap node is encountered. In
        this case, terminates the module and closes the RTL file.
        '''
        def exit_Addrmap(self, node):
            print(f'endmodule : {node.inst_name}_reg_sync', file=self.f)
            self.f.close()

    '''
    Function: export

    Export the fields in the given node to the given synchronizer file.

    Parameters:
        node - toplevel Root or Addrmap node.
        path - relative string path to the synchronizer file. Must end in ".sv"
    '''
    def export(self, node: Node, path: str, **kwargs):
        walker = RDLSimpleWalker(unroll=True)
        listener = self._SyncFieldListener(path)
        walker.walk(node, listener)


'''
Class: RTLSyncExporterPlugin

PeakRDL-compliant (hopefully) wrapper around the RTLSyncExporter. Should be
usable with the PeakRDL CLI.
'''
class RTLSyncExporterPlugin(ExporterSubcommandPlugin):
    short_desc = 'Plugin for the RTL Synchronizer exporter'
    long_desc = 'Generates synthesizeable RTL for synchronizing registers to system clock and interface clock'

    '''
    Function: add_exporter_arguments

    Adds the --path argument to the command-line arguments. Defaults to ./cdc_sync.sv.
    '''
    def add_exporter_arguments(self, arg_group: 'argparse.ArgumentParser') -> None:
        arg_group.add_argument('--path', type=str, default='./cdc_sync.sv',
                               help='Path to generated synchronizer RTL, default ./cdc_sync.sv. Must end in .sv.')

    '''
    Function: do_export

    Exports the given top node with the given command-line options.
    '''
    def do_export(self, top_node: 'AddrmapNode', options: 'argparse.Namespace') -> None:
        exporter = RTLSyncExporter()
        exporter.export(top_node, options.path)
/**
Class: oscillator_agent

Instantiates monitor, sequencer, and driver for driving oscillator packets.
*/
class oscillator_agent extends uvm_agent;

    // Variable: m_agent_cfg
    // Agent configuration that must be set for this agent's uvm_config_db:cfg variable,
    // or the agent will throw a UVM_FATAL. Critical, since it contains the virtual interface,
    // among other things like whether this agent is active or passive.
    oscillator_agent_cfg m_agent_cfg;

    // Variable: m_coverage_collector
    // Created if the config coverage collection is enabled. Collects default coverage on the
    // packets received via this monitor.
    oscillator_coverage_collector m_coverage_collector;

    oscillator_driver driver;
    oscillator_monitor monitor;
    uvm_sequencer #(oscillator_packet) sequencer;

    `uvm_component_utils(oscillator_agent)

    function new (string name, uvm_component parent);
        super.new(name, parent);
    endfunction

    virtual function void build_phase (uvm_phase phase);
        super.build_phase(phase);

        if (!uvm_config_db #(oscillator_agent_cfg)::get(this, "", "cfg", cfg))
            `uvm_fatal(get_full_name(), "Could not attach agent config");

        uvm_config_db #(virtual oscillator_if)::set(this, "driver", "vif", cfg.vif);
        uvm_config_db #(virtual oscillator_if)::set(this, "monitor", "vif", cfg.vif);
        uvm_config_db #(real)::set(this, "monitor", "frequency_threshold", cfg.frequency_threshold);
        uvm_config_db #(uvm_active_passive_enum)::set(this, "", "is_active", cfg.is_active);

        monitor = oscillator_monitor::type_id::create("monitor", this);
        if (cfg.is_active) begin
            driver = spi_driver::type_id::create("driver", this);
            sequencer = uvm_sequencer #(spi_packet)::type_id::create("sequencer", this);
        end
        if (cfg.coverage_enable)
            m_coverage_collector = oscillator_coverage_collector::type_id::create("m_coverage_collector", this);

    endfunction

    virtual function void connect_phase (uvm_phase phase);
        if (cfg.is_active)
            driver.seq_item_port.connect(sequencer.seq_item_export);
        if (cfg.coverage_enable)
            monitor.mon_analysis_port.connect(m_coverage_collector.analysis_export);
    endfunction

endclass/**
Class: oscillator_agent_cfg

Config for the digial-only oscillator agent. Contains the threshold for changes
in frequency to be reported.
*/
class oscillator_agent_cfg extends uvm_object;

    // Variable: vif
    // Virtual interface the agent will use
    virtual oscillator_if vif;

    // Variable: is_active
    // If set to UVM_ACTIVE, agent will instantiate driver and sequencer with the assumption
    // that they will be used to drive signals.
    uvm_active_passive_enum is_active;

    // Variable: checks_enable
    // Boilerplate variable that, if 1, will enable any internal checks that the agent has.
    bit checks_enable;

    // Variable: coverage_enable
    // If 1, the agent will instantiate a uvm_subscriber that will collect coverage data
    // on received packets.
    bit coverage_enable;

    // Variable: frequency_threshold
    // Threshold below which frequency differences from the current observed
    // frequency will not be reported, i.e. allowable frequency mismatch.
    real frequency_threshold;

    `uvm_object_utils_begin(oscillator_agent_cfg)
        `uvm_field_int(checks_enable)
        `uvm_field_int(coverage_enable)
        `uvm_field_real(frequency_threshold)
    `uvm_object_utils_end

    function new(string name = "oscillator_agent_cfg");
        super.new(name);
    endfunction

endclass/**
Package: oscillator_agent_pkg

Contains all the necessary classes for the oscillator agent. Users must also
make sure that the oscillator interface, <oscillator_if>, is compiled.

Necessary classes:

    - <oscillator_packet>
    - <oscillator_single_packet_seq>
    - <oscillator_driver>
    - <oscillator_monitor>
    - <oscillator_coverage_collector>
    - <oscillator_agent>
*/
package oscillator_agent_pkg;

    import uvm_pkg::*;
    `include "uvm_macros.svh"

    `include "oscillator_packet.svh"
    `include "oscillator_seq_lib.svh"
    `include "oscillator_driver.svh"
    `include "oscillator_monitor.svh"
    `include "oscillator_coverage_collector.svh"
    `include "oscillator_agent.svh"

endpackage/**
Class: oscillator_coverage_collector

Collects coverage on received packets. By default, crosses frequency with enabled state and
crosses enable with disabled state. Samples coverage on write.
*/
class oscillator_coverage_collector extends uvm_subscriber #(oscillator_packet);

    `uvm_component_utils(oscillator_coverage_collector)

    bit enable;
    real frequency;
    bit disabled_state;

    covergroup oscillator_cov;

        cp_frequency : coverpoint frequency iff (enable) {
            bins low_freq    = {[100.0 : 1e3]};
            bins mid_freq    = {[1e3   : 1e6]};
            bins high_freq   = {[1e6   : 1e9]};
        }

        cp_disabled_state : coverpoint disbled_state iff (!enable)

    endgroup


    function new (string name, uvm_component parent);
        super.new(name, parent);
        oscillator_cov = new();
    endfunction

    virtual function void write (oscillator_packet t);
        enable = t.enabled;
        frequency = t.frequency;
        disabled_state = t.disabled_state;
        oscillator_cov.sample();
    endfunction

endclass/**
Class: oscillator_driver

Drives <oscillator_packet>s onto the oscillator interface.
*/
class oscillator_driver extends uvm_driver #(oscillator_packet);

    `uvm_component_utils(oscillator_driver)

    oscillator_packet req;

    virtual oscillator_if vif;

    function new (string name, uvm_component parent);
        super.new(name, parent);
    endfunction

    virtual function void build_phase(uvm_phase phase);
        if (!uvm_config_db #(virtual oscillator_if)::get(this, "", "vif", vif))
            `uvm_fatal("DRV", "Could not attach driver virtual interface")
    endfunction

    virtual task run_phase(uvm_phase phase);
        forever begin
            seq_item_port.get_next_item(req);
            drive_signals(req);
            seq_item_port.item_done(req);
        end
    endtask

    virtual task drive_signals(oscillator_packet req);
        if (req.enabled)
            vif.start_clock(req.frequency);
        else
            vif.stop_clock(req.disabled_state);
    endtask

endclass`timescale 1ns/1fs

/**
Interface: oscillator_if

Interface for frequency detection. Contains internal variables for clock
enabled and current observed frequency that should be used for any monitor.
*/
interface oscillator_if;

    // Group: Driver Values
    // Defines values and functions intended for use by the UVM driver.

    // Variable: clk_driven
    // The clock driven to the DUT.
    bit clk_driven;

    // Variable: clk_enable_driven
    // When 1, <clk_driven> will be set to begin oscillating.
    bit clk_enable_driven;

    // Variable: frequency_driven
    // The frequency in Hz that will be driven onto the output clock. Ignored
    // if <clk_enable_driven> is low.
    real frequency_driven;

    // Variable: disabled_state_driven
    // The disabled state that the clock will use when not oscillating
    bit disabled_state_driven;

    // Function: start_clock
    // Allows the user to start the clock going to the DUT with the given
    // frequency.
    //
    // Parameters:
    //   frequency - the frequency in Hz with which to drive the clock
    task start_clock(real frequency);
        frequency_driven = frequency;
        clk_enable_driven = 1;
    endtask

    // Function: stop_clock
    // Stop the output clock with the given disabled state.
    task stop_clock(bit disabled_state);
        disabled_state_driven = disabled_state;
        clk_enable_driven = 0;
    endtask

    always @(clk_enable_driven or disabled_state_driven) begin : dut_clock_gen
        while (clk_enable_driven) begin
            clk_driven = !clk_driven;
            #(1e-9 / (2.0 * frequency_driven));
        end
        clk_driven = disabled_state_driven;
    end

    // Group: Monitor Values
    // Defines values and functions intended for use by the UVM monitor.

    // Variable: clk_observed
    // The observed clock from the DUT
    bit clk_observed;

    // Variable: frequency_observed
    // The observed frequency from the DUT
    real frequency_observed;

    // Variable: clk_enable_observed
    // Whether the observed clock is believed to be enabled or disabled
    bit clk_enable_observed;

    // Variable: disabled_state_observed
    // The observed disabled state of the disabled clock
    bit disabled_state_observed;
    assign disabled_state_observed = enabled_state_observed ? 0 : clk_observed;
    
    // TODO: update this with some kind of intelligent sensing mechanism for disabled clocks
    assign enabled_state_observed = clk_enable_driven;
    
    real time_0;
    real time_1;

    initial time_0 = 0.0;
    initial time_1 = 0.0;

    always @(clk_observed) begin : calc_observed_frequency
        time_1 = $realtime() * 1e-9; // convert time to seconds from ns
        frequency_observed = 1 / (time_1 - time_0);
        time_0 = time_1;
    end

endinterface

/**
Class: oscillator_monitor

Monitors the oscillator interface and reports any changes in frequency or
enabled status.
*/
class oscillator_monitor extends uvm_monitor;

    `uvm_component_utils(oscillator_monitor)

    oscillator_packet pkt;
    virtual oscillator_if vif;
    uvm_analysis_port #(oscillator_packet) mon_analysis_port;
    real frequency_threshold;

    bit current_enable;
    real current_frequency;
    bit current_disabled_state;

    function new (string name, uvm_component parent);
        super.new(name, parent);
        mon_analysis_port = new("mon_analysis_port", this);
    endfunction

    virtual function void build_phase(uvm_phase phase);
        if (!uvm_config_db #(virtual if_spi)::get(this, "", "vif", vif))
            `uvm_fatal(get_full_name(), "Virtual interface not found")
        if (!uvm_config_db #(real)::get(this, "", "frequency_threshold", frequency_threshold))
            `uvm_fatal(get_full_name(), "Could not find frequency threshold")
    endfunction

    virtual task run_phase (uvm_phase phase);
        current_enable = 0;
        current_frequency = 0.0;
        current_disabled_state = 0;

        forever begin
            item = oscillator_packet::type_id::create("mon_packet", this);
            collect_transaction(item);
            publish_transaction_if_needed(item);
        end
    endtask

    virtual task collect_transaction(ref oscillator_packet item);
        @(vif.clk_enable_observed or vif.frequency_observed or vif.disabled_state_observed);
        item.enabled = vif.clk_enable_observed;
        item.frequency = vif.frequency_observed;
        item.disabled_state = vif.disabled_state_observed;
    endtask

    virtual task publish_transaction_if_needed (ref oscillator_packet item);
        real frequency_difference;

        if (item.enabled != current_enable) begin
            `uvm_info(get_full_name(), $sformatf("New oscillator packet based on enable: %s",
                                                 item.sprint()), UVM_HIGH)
            publish_item(item);
        end else if ((!item.enabled) && (item.disabled_state != current_disabled_state)) begin // both disabled, report new disabled state
            `uvm_info(get_full_name(), $sformatf("New oscillator packet based on disabled state: %s",
                                                 item.sprint()), UVM_HIGH)
            publish_item(item);
        end else if (item.enabled) begin
            frequency_difference = current_frequency - item.frequency;
            frequency_difference = frequency_difference < 0 ? -frequency_difference : frequency_difference;
            if (frequency_difference > frequency_threshold) begin
                `uvm_info(get_full_name(), $sformatf("New oscillator packet based on frequency with large delta: %s",
                                                 item.sprint()), UVM_HIGH)
                publish_item(item);
            end else
                `uvm_info(get_full_name(), $sformatf("No new oscillator packet because frequency delta is too small: %s",
                                                     item.sprint()), UVM_HIGH)
        end else
            `uvm_info(get_full_name(), "New packet but insufficient reason for oscillator_monitor to publish.", UVM_HIGH)
    endtask

    virtual task publish_item (oscillator_packet item);
        current_frequency = item.frequency;
        current_enable = item.enabled;
        current_disabled_state = item.disabled_state;
        mon_analysis_port.publish(item);
    endtask

endclass/**
Class: oscillator_packet

Represents the current state of an oscillator; frequency, enabled status, and
disabled state.
*/
class oscillator_packet extends uvm_sequence_item;

    // Variable: enabled
    // If 1, the clock is enabled with the given frequency. Else, the clock is
    // disabled with the packet disabled state.
    rand bit enabled;

    // Variable: frequency
    // Determines the frequency of an active clock
    rand real frequency;

    // Variable: disabled_state
    // Determines the disabled state of an inactive clock
    rand bit disabled_state;

    `uvm_object_utils_begin(oscillator_packet)
        `uvm_field_int(enabled, UVM_ALL_ON)
        `uvm_field_real(frequency, UVM_ALL_ON)
        `uvm_field_int(disabled_state, UVM_ALL_ON)
    `uvm_object_utils_end

    function new(string name = "oscillator_packet");
        super.new(name);
    endfunction

    constraint default_frequency_range {
        frequency <= 1e9;
        frequency >= 100.0;
    }

endclass/**
Class: oscillator_single_packet_seq

Represents a single oscillator packet. Randomizes a single packet with the
sequence enable state, frequency, and disabled state.
*/
class oscillator_single_packet_seq extends uvm_sequence #(oscillator_packet);

    // Variable: enabled
    // If 1, the clock is enabled with the given frequency. Else, the clock is
    // disabled with the packet disabled state.
    rand bit pkt_enabled;

    // Variable: frequency
    // Determines the frequency of an active clock
    rand real pkt_frequency;

    // Variable: disabled_state
    // Determines the disabled state of an inactive clock
    rand bit pkt_disabled_state;

    `uvm_object_utils_begin(oscillator_single_packet_seq)
        `uvm_field_int(enable)
        `uvm_field_real(frequency)
        `uvm_field_int(disabled_state)
    `uvm_object_utils_end

    constraint default_frequency_range {
        frequency <= 1e9;
        frequency >= 100.0;
    }

    function new (string name = "single_packet_seq");
        super.new(name);
    endfunction

    virtual task body();
        oscillator_packet pkt;

        pkt = oscillator_packet::type_id::create("pkt");

        pkt.randomize() with {
            enabled == pkt_enabled;
            frequency == pkt_frequency;
            disabled_state == pkt_disabled_state;
        };

        start_item(pkt);
        finish_item(pkt);
    endtask

endclass/**
Class: max_amp_packet

Extension of the sine packet that forces max amplitude.
*/
class max_amp_packet extends sine_packet;

    `uvm_object_utils(max_amp_packet)

    function new(string name = "max_amp_packet");
        super.new(name);
    endfunction

    constraint max_amplitude {
        amplitude == 0.5;
    }

endclass/**
Class: sine_agent

Provides configuration for driver and monitor, and also adds coverage collection
for mixed-signal sine waves instead of just normal ones.
*/
class sine_agent extends oscillator_agent;

    `uvm_component_utils(sine_agent)

    function new (string name, uvm_component parent);
        super.new(name, parent);
    endfunction

    sine_coverage_collector m_sine_coverage_collector;

    virtual function void build_phase(uvm_phase phase);
        // TODO: set type override to make sine collector instead of oscillator collector
    endfunction

endclass/**
Class: sine_agent_cfg

Extension of the <oscillator_agent_cfg> that contains the proxy necessary
for mixed-signal agents.
*/
class sine_agent_cfg extends oscillator_agent_cfg;

    // Variable: vproxy
    // Proxy used by the driver and monitor to configure mixed-signal values
    sine_proxy vproxy;

    // Variable: amplitude_threshold
    // Like frequency detection threshold, but with amplitude
    real amplitude_threshold;

    `uvm_object_utils_begin(sine_agent_cfg)
        `uvm_field_real(amplitude_threshold)
    `uvm_object_utils_end

    function new(string name = "sine_agent_cfg");
        super.new(name);
    endfunction

endclass/**
Class: sine_coverage_collector

Collects coverage of amplitude as well as everything else for oscillator coverage.
*/
class sine_coverage_collector extends oscillator_coverage_collector;

    `uvm_component_utils(sine_coverage_collector)

    real amplitude;
    sine_packet pkt;

    covergroup sine_cov;

        cp_frequency : coverpoint frequency iff (enable) {
            bins low_freq    = {[100.0 : 1e3]};
            bins mid_freq    = {[1e3   : 1e6]};
            bins high_freq   = {[1e6   : 1e9]};
        }

        cp_amplitude : coverpoint amplitude iff (enable) {
            bins small_amp  = {[0.0 : 0.1]};
            bins medium_amp = {[0.1 : 0.25]};
            bins large_amp  = {[0.25: 0.5]};
        }

        amp_x_freq : cross cp_frequency, cp_amplitude;

    endgroup

    function new (string name, uvm_component parent);
        super.new(name, parent);
        sine_cov = new();
    endfunction

    virtual function void write(oscillator_packet t);
        super.write(t);

        if ($cast(pkt, t)) begin
            amplitude = pkt.amplitude;
            sine_cov.sample();
        end else
            `uvm_warning(get_full_name(), "Incoming packet is not sine-packet but subscriber is a sine coverage collector. Coverage will not be sampled.")
    endfunction

endclass/**
Class: sine_driver

Oscillator agent capable of driving sine waves.
*/
class sine_driver extends oscillator_driver;

    `uvm_component_utils(sine_driver)

    sine_proxy vproxy;

    sine_packet ms_req;

    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction

    virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        if (! uvm_config_db #(sine_proxy)::get(this, "", "vproxy", vproxy))
            `uvm_fatal(get_full_name(), "Could not find driver proxy")
    endfunction

    virtual task drive_signals(oscillator_packet pkt);
        super.drive_signals(pkt);

        if ($cast(ms_req, pkt))
            vproxy.push(ms_req.amplitude);
    endtask

endclass/**
Class: sine_monitor

Monitor capable of reporting sine wave amplitudes as well as frequency and such.
*/
class sine_monitor extends oscillator_monitor;

    `uvm_component_utils(sine_monitor)

    sine_proxy vproxy;

    sine_packet ms_pkt;

    real amplitude_threshold;
    real current_amplitude;

    bit item_was_published;

    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction

    virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        if (! uvm_config_db #(sine_proxy)::get(this, "", "vproxy", vproxy))
            `uvm_fatal(get_full_name(), "Could not find proxy")
        if (! uvm_config_db #(real)::get(this, "", "amplitude_threshold", amplitude_threshold))
            `uvm_fatal(get_full_name(), "Could not find amplitude threshold")
    endfunction

    virtual task run_phase (uvm_phase phase);
        current_amplitude = 0.0;
        super.run_phase(phase);
    endtask

    virtual task collect_transaction(ref oscillator_packet item);
        if (! $cast(ms_pkt, item))
            `uvm_ms_fatal(get_full_name(), "Could not cast item to mixed-signal equivalent")

        @(vif.clk_enable_observed or vif.frequency_observed or vif.disabled_state_observed or vproxy.update_available);
        ms_pkt.enabled = vif.clk_enable_observed;
        ms_pkt.frequency = vif.frequency_observed;
        ms_pkt.disabled_state = vif.disabled_state_observed;

        vproxy.sample(ms_pkt.enabled, ms_pkt.amplitude);

        item = ms_pkt;
    endtask

    virtual task publish_transaction_if_needed(ref oscillator_packet item);
        real amplitude_difference;
        
        item_was_published = 0;
        super.publish_transaction_if_needed(item);

        if (! $cast(ms_pkt, item))
            `uvm_ms_fatal(get_full_name(), "Could not cast item to mixed-signal equivalent")

        amplitude_difference = ms_pkt.amplitude - current_amplitude;
        amplitude_difference = amplitude_difference < 0.0 ? -amplitude_difference : amplitude_difference;

        if ((!item_was_published) && (amplitude_difference > amplitude_threshold)) begin
            this.current_amplitude = ms_pkt.amplitude;
            publish_item(item);
        end
    endtask

    virtual task publish_item(oscillator_packet item);
        super.publish_item(item);
        item_was_published = 1;
    endtask

endclass



/**
Module: sine_ms_bridge

Bridge that converts oscillator inputs to sine waves. Also defines the proxy
necessary for UVM driver and monitor to configure during execution, but parametrized
so as to be able to work without them.

Works with an *internal* oscillator interface, so UVM testbenches will not have
to instantiate them.
*/
module sine_ms_bridge (
    // supply values, used to scale amplitude correctly
    input interconnect vdd,
    input interconnect vss,

    // driven clock, differential with Vcm = vdd / 2
    output interconnect voutp,
    output interconnect voutn,

    // observed clock
    input interconnect vinp,
    input interconnect vinn
);

    oscillator_if bridge_if ();

    class sine_ms_bridge_proxy extends sine_proxy;
        virtual function void push(real amplitude);

        endfunction

        virtual task sample (output real amplitude);
            
        endtask
    endclass

    sine_ms_bridge_proxy proxy = new();

    sine_ms_bridge_core_real (
        .vdd,
        .vss,

        .voutp,
        .voutn,

        .vinp,
        .vinn,

        .clk_observed(bridge_if.clk_observed),
        .clk_driven(bridge_if.clk_driven)
    );
endmodule
/**
Module: sine_ms_bridge_core_real

Converts differential signals to single-ended.
*/
module sine_ms_bridge_core_real (

);

endmodule/**
Class: sine_packet

Extension of <oscillator_packet> intended to be used to drive a sine wave.
*/
class sine_packet extends oscillator_packet;

    // Variable: amplitude
    // Represents the amplitude of the sine wave as a fraction of VDD. Must
    // not be greater than 0.5, and must be greater than 0.0.
    rand real amplitude;

    constraint legal_amplitude {
        amplitude <= 0.5;
        amplitude > 0.0;
    }

    `uvm_object_utils_begin(sine_packet)
        `uvm_field_real(amplitude, UVM_ALL_ON)
    `uvm_object_utils_end

    function new (string name = "sine_packet");
        super.new(name);
    endfunction

endclass/**
Class: sine_proxy

Proxy used by sine wave driver and monitor for AMS communication. Must be
implemented in the bridge.
*/
virtual class sine_proxy extends uvm_ms_proxy;

    // Group: Driver

    // Function: push
    // Send the given amplitude to be driven by the bridge
    virtual function void push(real amplitude);
        `uvm_ms_warning("SINE PROXY", "Function push not implemented")
    endfunction

    // Group: Monitor

    // Variable: update_available
    // Goes high when a new amplitude is available. Cleared at the end of sample.
    bit update_available;

    // Function: sample
    // Get the amplitude observed by the bridge, but after waiting for a peak
    // or trough if the clock is enabled. This is intended to allow for
    // changes in frequency as well as amplitude. If the clock is disabled,
    // wait for the wave to stabilize before sampling. Implementations of this
    // task should set <update_available> to 0 upon completion.
    //
    // Parameters:
    //   amplitude - output amplitude read by the task.
    virtual task sample(output real amplitude);
        `uvm_ms_warning("SINE PROXY", "Function sample not implemented")
    endtask
import uvm_pkg::*;
`include "uvm_macros.svh"

class spi_packet extends uvm_sequence_item;

    // relevant data for DUT
    rand logic        rd_en;
    rand logic [14:0] address;
    rand logic [15:0] write_data [$];
         logic [15:0] read_data [$]; // data out - monitor publishes multiple transactions
    
    // data for driver/monitor
    rand int        n_reads;
         bit        is_subsequent_transaction;

    constraint no_write_data_if_read {
        rd_en -> (write_data.size() == 0);
    }

    constraint short_reads {
        n_reads < 10;
        n_reads >= 0;
        if (rd_en) {
            n_reads > 0;
        }
        else {
            n_reads == 0;
        }
    }

    `uvm_object_utils_begin(spi_packet)
        `uvm_field_int(rd_en, UVM_ALL_ON)
        `uvm_field_int(address, UVM_ALL_ON)
        `uvm_field_queue_int(write_data, UVM_ALL_ON)
        `uvm_field_int(n_reads, UVM_ALL_ON)
        `uvm_field_queue_int(read_data, UVM_ALL_ON)
        `uvm_field_int(is_subsequent_transaction, UVM_ALL_ON)
    `uvm_object_utils_end

    function new (string name = "spi_packet");
        super.new(name);
        `uvm_info("PKT", "SPI packet created", "UVM_LOW")
    endfunction

endclassclass spi_packet_reg_extension extends uvm_object;

    `uvm_object_utils(spi_packet_reg_extension)

    rand logic [15:0] additional_write_data [$];
    rand int          n_additional_reads;
         bit          check_against_mirror;

    function new(string name = "spi_packet_reg_extension");
        super.new(name);
    endfunction

endclassinterface if_spi ();

    logic scl;
    logic mosi;
    logic csb;
    logic miso;

    initial begin
        scl = 1'b0;
        mosi = 1'b0;
        csb = 1'b1;
    end

endinterfaceimport spi_agent_pkg::*;

class reg2spi_adapter extends uvm_reg_adapter;

    `uvm_object_utils(reg2spi_adapter)

    function new (string name = "reg2spi_adapter");
        super.new(name);
        supports_byte_enable = 0;
        provides_responses = 0;
    endfunction

    virtual function uvm_sequence_item reg2bus(const ref uvm_reg_bus_op rw);
        spi_packet               pkt;
        uvm_reg_item             item;
        spi_packet_reg_extension ext;

        item = get_item();
        pkt = spi_packet::type_id::create("driver_spi_pkt");
        ext = spi_packet_reg_extension::type_id::create("ext");

        pkt.rd_en = rw.kind == UVM_READ;
        pkt.address = rw.addr;
        pkt.n_reads = rw.kind == UVM_READ ? 1 : 0;
        pkt.write_data.delete();
        pkt.read_data.delete();
        pkt.is_subsequent_transaction = 0;
        if (rw.kind == UVM_WRITE)
            pkt.write_data.push_back(rw.data);
        
        if (item.extension != null) begin
            if (! $cast(ext, item.extension))
                `uvm_fatal("ADAPTER", "Failed to cast item extension to SPI packet extension")
            while (ext.additional_write_data.size() > 0) begin
                pkt.write_data.push_back(ext.additional_write_data[0]);
                ext.additional_write_data.pop_front();
            end
            if (rw.kind == UVM_READ)
                pkt.n_reads += ext.n_additional_reads;
        end
        
        `uvm_info ("ADAPTER",
                   $sformatf ("reg2bus addr=0x%0h data=0x%0h kind=%s",
                              rw.addr, rw.data, rw.kind.name()),
                   UVM_HIGH)
        return pkt;
    endfunction

    virtual function void bus2reg(uvm_sequence_item bus_item, ref uvm_reg_bus_op rw);
        spi_packet pkt;

        if (! $cast (pkt, bus_item))
            `uvm_fatal("reg2spi_adapter", "Failed to cast bus item to SPI packet");
            
        rw.kind = pkt.rd_en ? UVM_READ : UVM_WRITE ;
        rw.addr = pkt.address;
        rw.data = pkt.rd_en ? pkt.read_data[0] : pkt.write_data[0];
        rw.status = UVM_IS_OK;

        `uvm_info ("ADAPTER", 
                   $sformatf("bus2reg : addr=0x%0h data=0x%0h kind=%s status=%s",
                             rw.addr, rw.data, rw.kind.name(), rw.status.name()),
                   UVM_HIGH)
        pkt.print();
    endfunction

endclassclass spi_agent extends uvm_agent;

    `uvm_component_utils(spi_agent)

    // agent components
    spi_driver driver;
    spi_monitor monitor;
    uvm_sequencer #(spi_packet) sequencer;

    virtual if_spi vif;
    spi_agent_cfg cfg;

    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction

    function void build_phase(uvm_phase phase);
        super.build_phase(phase);

        if (!uvm_config_db #(spi_agent_cfg)::get(this, "", "cfg", cfg))
            `uvm_fatal("SPI_AGENT", "Could not attach SPI config");

        uvm_config_db #(uvm_active_passive_enum)::set(this, "", "is_active", cfg.is_active);
        uvm_config_db #(virtual if_spi)::set(this, "driver", "vif", cfg.vif);
        uvm_config_db #(virtual if_spi)::set(this, "monitor", "vif", cfg.vif);
        uvm_config_db #(bit)::set(this, "driver", "CPOL", cfg.CPOL);
        uvm_config_db #(bit)::set(this, "driver", "CPHA", cfg.CPHA);
        uvm_config_db #(int)::set(this, "driver", "speed", cfg.speed);
        uvm_config_db #(bit)::set(this, "monitor", "CPOL", cfg.CPOL);
        uvm_config_db #(bit)::set(this, "monitor", "CPHA", cfg.CPHA);

        monitor = spi_monitor::type_id::create("monitor", this);
        if (get_is_active()) begin
            driver = spi_driver::type_id::create("driver", this);
            sequencer = uvm_sequencer #(spi_packet)::type_id::create("sequencer", this);
        end
    endfunction

    function void connect_phase(uvm_phase phase);
        if (get_is_active())
            driver.seq_item_port.connect(sequencer.seq_item_export);
    endfunction

endclassclass spi_agent_cfg extends uvm_object;

    `uvm_object_utils(spi_agent_cfg)

    function new(name = "spi_agent_cfg");
        super.new(name);
    endfunction

    virtual if_spi vif;
    int speed;

    uvm_active_passive_enum is_active;
    rand bit                checks_enable;
    rand bit                coverage_enable;

    rand bit CPHA;
    rand bit CPOL;

endclasspackage spi_agent_pkg;
    import uvm_pkg::*;
    `include "uvm_macros.svh"
    `include "data_items/spi_packet.sv"
    `include "data_items/spi_packet_reg_extension.sv"
    `include "src/spi_driver.sv"
    `include "src/spi_monitor.sv"
    `include "spi_agent_cfg.sv"
    `include "spi_agent.sv"
    `include "reg2spi_adapter.sv"
endpackage`timescale 1ns / 1ns

class spi_driver extends uvm_driver #(spi_packet);

    `uvm_component_utils(spi_driver)

    spi_packet req;

    virtual if_spi vif;

    bit CPOL;
    bit CPHA;

    real speed;
    real clk_period_ns;

    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction

    virtual function void build_phase(uvm_phase phase);
        if (!uvm_config_db #(virtual if_spi)::get(this, "", "vif", vif))
            `uvm_fatal("DRV", "Could not attach driver virtual interface")
        if (!uvm_config_db #(bit)::get(this, "", "CPOL", CPOL))
            `uvm_fatal("DRV", "Could not attach driver CPOL")
        if (!uvm_config_db #(bit)::get(this, "", "CPHA", CPHA))
            `uvm_fatal("DRV", "Could not attach driver CPHA")
        if (!uvm_config_db #(int)::get(this, "", "speed", speed))
            `uvm_fatal("DRV", "Could not attach driver speed")
        clk_period_ns = 1e9 / speed;
    endfunction

    virtual task run_phase(uvm_phase phase);
        spi_packet req_copy;

        req_copy = spi_packet::type_id::create("driver_spi_pkt_copy");

        vif.csb = 1'b1; // SPI off to start
        vif.scl = 1'b0; // SPI mode 0 CPHA idle
        vif.mosi = 1'b0;
        forever begin
            seq_item_port.get_next_item(req);
            drive_signals(req);
            seq_item_port.item_done(req);
        end
    endtask

    // drive with 5 MHz clock, which is 200ns
    virtual task drive_signals(spi_packet req);
        bit [15:0] mosi = {req.rd_en, req.address};
        bit [15:0] reg_temp;

        `uvm_info("DRV", "Driving SPI packet", UVM_HIGH);
        req.print();

        #(clk_period_ns/2);
        vif.csb = 1'b0;
        #(clk_period_ns/2);

        // send bit and address
        for (int i = 15; i >= 0; i--) begin
            vif.mosi = mosi[i]; // MSB first
            #(clk_period_ns/2);
            vif.scl = 1'b1;
            #(clk_period_ns/2);
            vif.scl = 1'b0;
        end

        // receive MISO data
        if (req.rd_en == 1'b1) begin : read_reg
            vif.mosi = 1'b0; // drive low to avoid MOSI staying high and being confusing
            req.read_data.delete();
            for (int i = 0; i < req.n_reads; i++) begin
                reg_temp = 16'h0000;
                for (int j = 15; j >= 0; j--) begin
                    #(clk_period_ns/2);
                    vif.scl = 1'b1;
                    reg_temp[j] = vif.miso;
                    #(clk_period_ns/2);
                    vif.scl = 1'b0;
                end
                req.read_data.push_back(reg_temp);
            end
        end else begin : write_reg
            for (int j = 0; j < req.write_data.size(); j++) begin
                mosi = req.write_data[j];
                for (int i = 15; i >= 0; i--) begin
                    vif.mosi = mosi[i]; // MSB first
                    #(clk_period_ns/2);
                    vif.scl = 1'b1;
                    #(clk_period_ns/2);
                    vif.scl = 1'b0;
                end
            end
        end

        #(clk_period_ns/2);
        vif.csb = 1'b1;
        #(clk_period_ns/2);

    endtask

endclassclass spi_monitor extends uvm_monitor;

    `uvm_component_utils(spi_monitor)

    virtual if_spi vif;
    uvm_analysis_port #(spi_packet) mon_analysis_port;

    bit CPOL;
    bit CPHA;

    logic [15:0] read_data_queue [$];

    function new(string name, uvm_component parent);
        super.new(name, parent);
        mon_analysis_port = new("mon_analysis_port", this);
    endfunction

    virtual function void build_phase(uvm_phase phase);
        if (!uvm_config_db#(virtual if_spi)::get(this, "", "vif", vif))
            `uvm_fatal("MON", "Virtual interface not found for SPI Monitor")
        if (!uvm_config_db #(bit)::get(this, "", "CPOL", CPOL))
            `uvm_fatal("MON", "Could not attach monitor CPOL")
        if (!uvm_config_db #(bit)::get(this, "", "CPHA", CPHA))
            `uvm_fatal("MON", "Could not attach monitor CPHA")
    endfunction

    virtual task run_phase(uvm_phase phase);
        spi_packet item;
        forever begin
            item = spi_packet::type_id::create("mon_packet");
            collect_transaction(item);
        end
    endtask

    virtual task collect_transaction(spi_packet item);
        @(negedge vif.csb);
        `uvm_info("MON", "Collecting SPI Packet", UVM_HIGH)
        collect_signals(item);
    endtask

    virtual task collect_signals(spi_packet item);
        logic [15:0] reg_temp;
        spi_packet copy_pkt = spi_packet::type_id::create("monitor_spi_pkt_copy");

        item.read_data.delete();
        item.write_data.delete();
        
        // collect transaction type
        @(posedge vif.scl);
        item.rd_en = vif.mosi;
        
        // collect address
        for (int i = 14; (i >= 0) && (!vif.csb); i--) begin
            @(posedge vif.scl or posedge vif.csb);
            item.address[i] = vif.mosi;
        end

        // receive MISO data if read, MOSI if write
        if (item.rd_en) begin : reg_read
            while (!vif.csb) begin
                // monitor transaction
                reg_temp = 16'h0000;
                for (int j = 15; (j >= 0) && (!vif.csb); j--) begin
                    @(posedge vif.scl or posedge vif.csb);
                    reg_temp[j] = vif.miso;
                end
                if (!vif.csb) begin
                    item.n_reads++;
                    item.read_data.push_back(reg_temp);
                end

                // publish transaction
                copy_pkt.copy(item);
                copy_pkt.read_data.delete();
                copy_pkt.read_data.push_back(reg_temp);
                copy_pkt.address += (copy_pkt.n_reads - 1);
                copy_pkt.is_subsequent_transaction = item.n_reads > 1;
                if (!vif.csb) begin
                    `uvm_info("MON", "Sending Read Packet", UVM_HIGH)
                    mon_analysis_port.write(copy_pkt);
                end
            end
        end else begin : reg_write
            while (!vif.csb) begin
                reg_temp = 16'h0000;
                for (int j = 15; (j >= 0) && (!vif.csb); j--) begin
                    @(posedge vif.scl or posedge vif.csb);
                    reg_temp[j] = vif.mosi;
                end
                if (!vif.csb)
                    item.write_data.push_back(reg_temp);

                // publish transaction
                copy_pkt.copy(item);
                copy_pkt.write_data.delete();
                copy_pkt.write_data.push_back(reg_temp);
                copy_pkt.address += (item.write_data.size() - 1);
                copy_pkt.is_subsequent_transaction = copy_pkt.address != item.address;
                if (!vif.csb) begin
                    `uvm_info("MON", "Sending Write Packet", UVM_HIGH)
                    mon_analysis_port.write(copy_pkt);
                end
            end
        end

    endtask
endclass`timescale 1ns/1ps

class adc_env extends uvm_env;

    `uvm_component_utils (adc_env)

    spi_agent spi;
    spi_agent_cfg spi_cfg;
    clkgen_agent clkgen;
    clkgen_agent_cfg clkgen_cfg;
    input_agent signal_gen;
    input_agent_cfg signal_gen_cfg;

    adc_env_cfg i_env_cfg;
    adc_mc_sequencer mc_sequencer;

    reg_env ral;

    function new(string name = "adc_env", uvm_component parent);
        super.new(name, parent);
    endfunction

    virtual function void build_phase (uvm_phase phase);
        super.build_phase(phase);
        if (!uvm_config_db #(adc_env_cfg)::get(this, "", "cfg", i_env_cfg))
            `uvm_fatal("ENV", "Could not attach environment config")
        
        create_configs();

        uvm_config_db #(input_agent_cfg)::set(this, "signal_gen", "cfg", signal_gen_cfg);
        uvm_config_db #(spi_agent_cfg)        ::set(this, "spi", "cfg", spi_cfg);
        uvm_config_db #(clkgen_agent_cfg)::set(this, "clkgen", "cfg", clkgen_cfg);

        spi = spi_agent::type_id::create("spi", this);
        clkgen = clkgen_agent::type_id::create("clkgen", this);
        signal_gen = input_agent::type_id::create("signal_gen", this);
        ral = reg_env::type_id::create("ral", this);
        mc_sequencer = adc_mc_sequencer::type_id::create("mc_sequencer", this);

        uvm_reg::include_coverage ("*", UVM_CVR_ALL);
    endfunction

    virtual function void connect_phase(uvm_phase phase);
        super.connect_phase(phase);
        ral.ral_model.default_map.set_sequencer(spi.sequencer, ral.adapter);
        spi.monitor.mon_analysis_port.connect(ral.spi_predictor.bus_in);
        mc_sequencer.ral = ral;
        mc_sequencer.input_sequencer = signal_gen.sequencer;
    endfunction

    virtual function void create_configs();
        spi_cfg = new("spi_cfg");
        spi_cfg.vif = i_env_cfg.vif_spi;
        spi_cfg.speed = i_env_cfg.spi_clk;
        spi_cfg.is_active = UVM_ACTIVE;
        spi_cfg.checks_enable = i_env_cfg.checks_enable;
        spi_cfg.coverage_enable = i_env_cfg.coverage_enable;
        spi_cfg.randomize();

        signal_gen_cfg = new("signal_gen_cfg");
        signal_gen_cfg.is_active = UVM_ACTIVE;
        signal_gen_cfg.nfft = i_env_cfg.nfft;

        // INFO : this is not necessarily valid, but the number of active cycles should all be constrained for FFT tests, so this should be fine
        signal_gen_cfg.fs = i_env_cfg.sys_clk / 4; 
        signal_gen_cfg.osr = i_env_cfg.osr;
        signal_gen_cfg.vdd = i_env_cfg.vdd;
        signal_gen_cfg.vif = i_env_cfg.vif_input;
        signal_gen_cfg.checks_enable = i_env_cfg.checks_enable;
        signal_gen_cfg.coverage_enable = i_env_cfg.coverage_enable;

        clkgen_cfg = new("clkgen_cfg");
        clkgen_cfg.is_active = UVM_ACTIVE;
        clkgen_cfg.checks_enable = i_env_cfg.checks_enable;
        clkgen_cfg.coverage_enable = i_env_cfg.coverage_enable;
        clkgen_cfg.sys_clk = i_env_cfg.sys_clk;
        clkgen_cfg.vif = i_env_cfg.vif_clkgen;
    endfunction

endclassimport uvm_pkg::*;
`include "uvm_macros.svh"

class adc_env_cfg extends uvm_object;

    `uvm_object_utils_begin(adc_env_cfg)
        `uvm_field_real(vdd, UVM_DEFAULT)
        `uvm_field_int(sys_clk, UVM_DEFAULT)
        `uvm_field_int(spi_clk, UVM_DEFAULT)
        `uvm_field_int(nfft_power, UVM_DEFAULT)
        `uvm_field_int(osr_power, UVM_DEFAULT)
        `uvm_field_int(dwa_en, UVM_DEFAULT)
        `uvm_field_int(n_sh_total_cycles, UVM_DEFAULT)
        `uvm_field_int(n_sh_active_cycles, UVM_DEFAULT)
        `uvm_field_int(n_bottom_plate_active_cycles, UVM_DEFAULT)
        `uvm_field_int(n_sar_cycles, UVM_DEFAULT)
        `uvm_field_int(n_int1_total_cycles, UVM_DEFAULT)
        `uvm_field_int(n_int1_active_cycles, UVM_DEFAULT)
        `uvm_field_int(n_int2_total_cycles, UVM_DEFAULT)
        `uvm_field_int(n_int2_active_cycles, UVM_DEFAULT)
        `uvm_field_int(checks_enable, UVM_DEFAULT)
        `uvm_field_int(coverage_enable, UVM_DEFAULT)
    `uvm_object_utils_end

    // agent virtual interfaces
    virtual if_spi vif_spi;
    virtual if_clkgen vif_clkgen;
    virtual if_input vif_input;

    // board parameters
    rand int  vdd_index;
         real vdd_options [3];
         real vdd;
    rand int  sys_clk;
    rand int  spi_clk;

    // randomized register fields
    rand int nfft_power;
    rand int osr_power;
    rand bit dwa_en;

    // timing information
    rand int n_sh_total_cycles;
    rand int n_sh_active_cycles;
    rand int n_bottom_plate_active_cycles;
    rand int n_sar_cycles;
    rand int n_int1_total_cycles;
    rand int n_int1_active_cycles;
    rand int n_int2_total_cycles;
    rand int n_int2_active_cycles;

    // post-randomization fields
    int osr;
    int nfft;

    // simulation coverage fields
    bit checks_enable;
    bit coverage_enable;

    // constraints literally match HW/RTL constraints
    constraint clk_matches_syn {
        sys_clk ==  24000000; // 24 MHz crystal oscillator
        spi_clk ==   2000000; // 2 MHz SPI clock
    }

    constraint legal_vdd {
        vdd_index inside {[1:3]};
    }

    constraint legal_osr_power {
        osr_power inside {[0:((2**8)-1)]};
    }

    constraint legal_nfft_power {
        nfft_power inside {[0:((2**14)-1)]};
    }

    constraint active_lte_total {
        n_sh_total_cycles            inside {[1:((2**16)-1)]};
        n_sh_active_cycles           inside {[1:((2**16)-1)]};
        n_bottom_plate_active_cycles inside {[1:((2**16)-1)]};
        n_sar_cycles                 inside {[1:((2**16)-1)]};
        n_int1_total_cycles          inside {[1:((2**16)-1)]};
        n_int1_active_cycles         inside {[1:((2**16)-1)]};
        n_int2_total_cycles          inside {[1:((2**16)-1)]};
        n_int2_active_cycles         inside {[1:((2**16)-1)]};

        n_sh_active_cycles <= n_sh_total_cycles;
        n_bottom_plate_active_cycles <= n_sh_active_cycles;
        n_int1_active_cycles <= n_int1_total_cycles;
        n_int2_active_cycles <= n_int2_total_cycles;
    }

    function void post_randomize();
        osr = 1 << osr_power;
        nfft = 1 << nfft_power;
        vdd = vdd_options[vdd_index];
    endfunction

    function new(name = "adc_env_cfg");
        super.new(name);
        vdd_options = {1.8, 2.5, 3.3};
    endfunction
endclasspackage adc_env_pkg;

    // include UVM package/macros
    import uvm_pkg::*;
    `include "uvm_macros.svh"

    // include agent packages
    import spi_agent_pkg::*;

    import input_agent_pkg::*;

    import clkgen_agent_pkg::*;

    // include RAL
    import reg_env_pkg::*;

    // eventually, include scoreboard package

    // include multichannel sequencer
    `include "adc_mc_sequencer.sv"
    `include "adc_mc_seq_lib.sv"

    // finally, include environment
    `include "adc_env_cfg.sv"
    `include "adc_env.sv"

endpackageclass single_const_value_conversion_seq extends uvm_sequence;

    `uvm_object_utils(single_const_value_conversion_seq)
    `uvm_declare_p_sequencer(adc_mc_sequencer)

    set_random_value_seq srv_seq;
    uvm_status_e status;
    uvm_reg_data_t fsm_status_rb;

    rand int nfft;

    constraint legal_nfft {
        nfft > 0;
        nfft <= 1 << 15;
    }

    function new(string name = "single_const_value_conversion_seq");
        super.new(name);
    endfunction

    task body();
        for (int i = 0; i < nfft; i++) begin
            srv_seq = set_random_value_seq::type_id::create("srv_seq");
            srv_seq.start(p_sequencer.input_sequencer);
            p_sequencer.ral.ral_model.get_field_by_name("begin_sample").write(status, 1);
            do begin
                `uvm_info("MC_SEQR", "Waiting for conversion to end", UVM_MEDIUM);
                p_sequencer.ral.ral_model.get_field_by_name("begin_sample").read(status, fsm_status_rb);
            end while (fsm_status_rb != 0);
            p_sequencer.ral.ral_model.get_field_by_name("read_mem").write(status, 1);
        end
    endtask

endclassclass adc_mc_sequencer extends uvm_sequencer;

    `uvm_component_utils(adc_mc_sequencer)

    reg_env                     ral;
    uvm_sequencer #(sin_packet) input_sequencer;

    function new(string name = "adc_mc_sequencer", uvm_component parent);
        super.new(name, parent);
    endfunction

endclassinterface if_analog_to_fpga;

    parameter N_QUANTIZER_BITS=3;

    logic sample;
    logic en_sar;
    logic integrate_1;
    logic integrate_2;
    logic reset_integrators;
    
    // capacitor controls
    logic [2**N_QUANTIZER_BITS-1:0] cap_set;
    logic [2**N_QUANTIZER_BITS-1:0] cap_p_voltages;

    // comparator output to FPGA
    logic compare;

endinterfaceinterface if_status;

    logic [1:0] fsm_convert_status;

    logic       rst_b;

endinterface/**
models the analog frontend of the SAR IADC, using the same inputs as the
board will have. There are 5 control signals, differential inputs, and
capacitor control switches. It is assumed that nonoverlapping clocks and
bootstrapping switches are implemented on board using discrete components.
*/

module analog_core #(
    parameter real VDD=3.3,
    parameter N_QUANTIZER_BITS=3
) (
    // sampling inputs
    if_input.hardware_port signal_in,

    // control signals
    if_analog_to_fpga if_digital
);

    localparam real VCM = VDD / 2;
    localparam real VSS = 0;

    real vip_sample, vin_sample;
    real i1p, i1n, i1p_r, i1n_r;
    real i2p, i2n, i2p_r, i2n_r;
    real vresp, vresn;
    real vintp, vintn;
    real cap_voltages_p, cap_voltages_n [(2<<N_QUANTIZER_BITS)-1:0];

    always_ff @(posedge if_digital.sample) begin
        vip_sample <= VDD - signal_in.vip;
        vin_sample <= VDD - signal_in.vin;
    end

    assign i1p = i1p_r + vresp;
    assign i1n = i1n_r + vresn;
    always_ff @(posedge if_digital.integrate_1 or posedge i_reset_integrators) begin
        if (i_reset_integrators) begin
            i1p_r <= VCM;
            i1n_r <= VCM;
        end else begin
            i1p_r <= i1p;
            i1n_r <= i1n;
        end
    end

    assign i2p = i1p_r + i2p_r;
    assign i2n = i1n_r + i2n_r;
    always_ff @(posedge if_digital.integrate_2 or posedge i_reset_integrators) begin
        if (i_reset_integrators) begin
            i2p_r <= VCM;
            i2n_r <= VCM;
        end else begin
            i2p_r <= i2p;
            i2n_r <= i2n;
        end
    end

    assign vresp = sum_real_array(cap_voltages_p) / (2**N_QUANTIZER_BITS) + vip_sample;
    assign vresn = sum_real_array(cap_voltages_n) / (2**N_QUANTIZER_BITS) + vin_sample;
    assign vintp = 2 * i1p_r + i2p_r;
    assign vintn = 2 * i1n_r + i2n_r;
    assign if_digital.compare = vintp + vresn >= vintn + vresp;

    genvar i;
    for (i = 0; i < 2**N_QUANTIZER_BITS; i++) begin : gen_capacitor_switch_mux
        assign cap_voltages_p[i] =  i_cap_set[i] ? 
                                        i_cap_p_voltages[i] ? VDD : VSS
                                    : VCM;
        assign cap_voltages_n[i] =  i_cap_set[i] ? 
                                        !i_cap_p_voltages[i] ? VDD : VSS
                                    : VCM;
    end
endmodule

function real sum_real_array(array);
    real array_sum = 0;
    foreach (array[i]) begin
        array_sum = array_sum + array[i]
    end
    return array_sum;
endfunctionmodule board_top (
    if_input.hardware_port vin,

    if_clkgen.module_clkgen clkgen,

    if_spi spi
);

    parameter real VDD=3.3;
    parameter N_QUANTIZER_BITS=3;

    if_analog_to_fpga #(
        .N_QUANTIZER_BITS(N_QUANTIZER_BITS)
    ) if_digital ();

    // analog_core #(
    //     .VDD(VDD),
    //     .N_QUANTIZER_BITS(N_QUANTIZER_BITS)
    // ) analog_core_model (
    //     .signal_in(vin),
    //     .if_digital
    // );

    dig_core #(
        .N_SAR_BITS(N_QUANTIZER_BITS)
    ) DIGTOP (
        .i_sar_compare(if_digital.compare),
        .i_sysclk(clkgen.clk),
        .i_sysrst_b(clkgen.rst_b),
        //TODO: deal with analog/digital boundary later
        .i_cs_b(spi.csb),
        .i_scl(spi.scl),
        .i_mosi(spi.mosi),
        .o_miso(spi.miso)
    );

endmodule
// This file was autogenerated by PeakRDL-uvm
package adc_regs_pkg;
    `include "uvm_macros.svh"
    import uvm_pkg::*;
    
    // reg - adc_regs::NFFT_CTRL
    class adc_regs__NFFT_CTRL extends uvm_reg;
        rand uvm_reg_field NFFT_POWER;
        rand uvm_reg_field DWA_EN;

        function new(string name = "adc_regs__NFFT_CTRL");
            super.new(name, 16, UVM_NO_COVERAGE);
        endfunction : new

        virtual function void build();
            this.NFFT_POWER = new("NFFT_POWER");
            this.NFFT_POWER.configure(this, 15, 0, "RW", 0, 'h0, 1, 1, 0);
            this.DWA_EN = new("DWA_EN");
            this.DWA_EN.configure(this, 1, 15, "RW", 0, 'h0, 1, 1, 0);
        endfunction : build
    endclass : adc_regs__NFFT_CTRL

    // reg - adc_regs::OSR
    class adc_regs__OSR extends uvm_reg;
        rand uvm_reg_field OSR_POWER;

        function new(string name = "adc_regs__OSR");
            super.new(name, 16, UVM_NO_COVERAGE);
        endfunction : new

        virtual function void build();
            this.OSR_POWER = new("OSR_POWER");
            this.OSR_POWER.configure(this, 8, 0, "RW", 0, 'h0, 1, 1, 0);
        endfunction : build
    endclass : adc_regs__OSR

    // reg - adc_regs::active_passive_reg
    class adc_regs__active_passive_reg extends uvm_reg;
        rand uvm_reg_field N_ACTIVE_CYCLES;
        rand uvm_reg_field N_PASSIVE_CYCLES;

        function new(string name = "adc_regs__active_passive_reg");
            super.new(name, 16, UVM_NO_COVERAGE);
        endfunction : new

        virtual function void build();
            this.N_ACTIVE_CYCLES = new("N_ACTIVE_CYCLES");
            this.N_ACTIVE_CYCLES.configure(this, 8, 0, "RW", 0, 'h1, 1, 1, 0);
            this.N_PASSIVE_CYCLES = new("N_PASSIVE_CYCLES");
            this.N_PASSIVE_CYCLES.configure(this, 8, 8, "RW", 0, 'h0, 1, 1, 0);
        endfunction : build
    endclass : adc_regs__active_passive_reg

    // reg - adc_regs::ADC_CTRL
    class adc_regs__ADC_CTRL extends uvm_reg;
        rand uvm_reg_field INPUT_MODE;
        rand uvm_reg_field VCM_SINGLE_ENDED;
        rand uvm_reg_field DELAY_LINE_CTRL;
        rand uvm_reg_field N_QUANTIZER_BITS;
        rand uvm_reg_field INCREMENTAL_MODE_EN;
        rand uvm_reg_field NOISE_SHAPING_EN;

        function new(string name = "adc_regs__ADC_CTRL");
            super.new(name, 16, UVM_NO_COVERAGE);
        endfunction : new

        virtual function void build();
            this.INPUT_MODE = new("INPUT_MODE");
            this.INPUT_MODE.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            this.VCM_SINGLE_ENDED = new("VCM_SINGLE_ENDED");
            this.VCM_SINGLE_ENDED.configure(this, 4, 1, "RW", 0, 'h0, 1, 1, 0);
            this.DELAY_LINE_CTRL = new("DELAY_LINE_CTRL");
            this.DELAY_LINE_CTRL.configure(this, 4, 5, "RW", 0, 'h0, 1, 1, 0);
            this.N_QUANTIZER_BITS = new("N_QUANTIZER_BITS");
            this.N_QUANTIZER_BITS.configure(this, 2, 9, "RW", 0, 'h0, 1, 1, 0);
            this.INCREMENTAL_MODE_EN = new("INCREMENTAL_MODE_EN");
            this.INCREMENTAL_MODE_EN.configure(this, 1, 11, "RW", 0, 'h0, 1, 1, 0);
            this.NOISE_SHAPING_EN = new("NOISE_SHAPING_EN");
            this.NOISE_SHAPING_EN.configure(this, 1, 12, "RW", 0, 'h0, 1, 1, 0);
        endfunction : build
    endclass : adc_regs__ADC_CTRL

    // reg - adc_regs::RUN_CTRL
    class adc_regs__RUN_CTRL extends uvm_reg;
        rand uvm_reg_field NFFT_EN;
        rand uvm_reg_field MAIN_STATE_RB;

        function new(string name = "adc_regs__RUN_CTRL");
            super.new(name, 16, UVM_NO_COVERAGE);
        endfunction : new

        virtual function void build();
            this.NFFT_EN = new("NFFT_EN");
            this.NFFT_EN.configure(this, 1, 1, "RW", 1, 'h0, 1, 1, 0);
            this.MAIN_STATE_RB = new("MAIN_STATE_RB");
            this.MAIN_STATE_RB.configure(this, 4, 2, "RO", 1, 'h0, 1, 1, 0);
        endfunction : build
    endclass : adc_regs__RUN_CTRL

    // reg - adc_regs::CLKGEN_DRP_0
    class adc_regs__CLKGEN_DRP_0 extends uvm_reg;
        rand uvm_reg_field CLKGEN_DRP_RD_EN;
        rand uvm_reg_field CLKGEN_DRP_WR_EN;
        rand uvm_reg_field CLKGEN_DRP_DEN;
        rand uvm_reg_field CLKGEN_DRP_DADDR;

        function new(string name = "adc_regs__CLKGEN_DRP_0");
            super.new(name, 16, UVM_NO_COVERAGE);
        endfunction : new

        virtual function void build();
            this.CLKGEN_DRP_RD_EN = new("CLKGEN_DRP_RD_EN");
            this.CLKGEN_DRP_RD_EN.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            this.CLKGEN_DRP_WR_EN = new("CLKGEN_DRP_WR_EN");
            this.CLKGEN_DRP_WR_EN.configure(this, 1, 1, "RW", 0, 'h0, 1, 1, 0);
            this.CLKGEN_DRP_DEN = new("CLKGEN_DRP_DEN");
            this.CLKGEN_DRP_DEN.configure(this, 1, 2, "RW", 0, 'h0, 1, 1, 0);
            this.CLKGEN_DRP_DADDR = new("CLKGEN_DRP_DADDR");
            this.CLKGEN_DRP_DADDR.configure(this, 7, 3, "RW", 0, 'h0, 1, 1, 0);
        endfunction : build
    endclass : adc_regs__CLKGEN_DRP_0

    // reg - adc_regs::CLKGEN_DRP_2
    class adc_regs__CLKGEN_DRP_2 extends uvm_reg;
        rand uvm_reg_field CLKGEN_DRP_DI;

        function new(string name = "adc_regs__CLKGEN_DRP_2");
            super.new(name, 16, UVM_NO_COVERAGE);
        endfunction : new

        virtual function void build();
            this.CLKGEN_DRP_DI = new("CLKGEN_DRP_DI");
            this.CLKGEN_DRP_DI.configure(this, 16, 0, "RW", 0, 'h0, 1, 1, 0);
        endfunction : build
    endclass : adc_regs__CLKGEN_DRP_2

    // reg - adc_regs::CLKGEN_DRP_3
    class adc_regs__CLKGEN_DRP_3 extends uvm_reg;
        rand uvm_reg_field CLKGEN_DRP_DO;

        function new(string name = "adc_regs__CLKGEN_DRP_3");
            super.new(name, 16, UVM_NO_COVERAGE);
        endfunction : new

        virtual function void build();
            this.CLKGEN_DRP_DO = new("CLKGEN_DRP_DO");
            this.CLKGEN_DRP_DO.configure(this, 16, 0, "RO", 1, 'h0, 1, 1, 0);
        endfunction : build
    endclass : adc_regs__CLKGEN_DRP_3

    // mem - adc_regs::adc_output_mem
    class adc_regs__adc_output_mem extends uvm_reg_block;
        rand uvm_mem m_mem;
        
        function new(string name = "adc_regs__adc_output_mem");
            super.new(name);
        endfunction : new

        virtual function void build();
            this.default_map = create_map("reg_map", 0, 2.0, UVM_NO_ENDIAN);
            this.m_mem = new("m_mem", 32768, 16, "RO");
            this.m_mem.configure(this);
            this.default_map.add_mem(this.m_mem, 0);
        endfunction : build
    endclass : adc_regs__adc_output_mem

    // addrmap - adc_regs
    class adc_regs extends uvm_reg_block;
        rand adc_regs__NFFT_CTRL NFFT_CTRL;
        rand adc_regs__OSR OSR;
        rand adc_regs__active_passive_reg SH_CTRL;
        rand adc_regs__active_passive_reg INT1_CTRL;
        rand adc_regs__active_passive_reg INT2_CTRL;
        rand adc_regs__ADC_CTRL ADC_CTRL;
        rand adc_regs__RUN_CTRL RUN_CTRL;
        rand adc_regs__CLKGEN_DRP_0 CLKGEN_DRP_0;
        rand adc_regs__CLKGEN_DRP_2 CLKGEN_DRP_2;
        rand adc_regs__CLKGEN_DRP_3 CLKGEN_DRP_3;
        rand adc_regs__adc_output_mem adc_output_mem;

        function new(string name = "adc_regs");
            super.new(name);
        endfunction : new

        virtual function void build();
            this.default_map = create_map("reg_map", 0, 2, UVM_NO_ENDIAN);
            this.NFFT_CTRL = new("NFFT_CTRL");
            this.NFFT_CTRL.configure(this);

            this.NFFT_CTRL.build();
            this.default_map.add_reg(this.NFFT_CTRL, 'h0);
            this.OSR = new("OSR");
            this.OSR.configure(this);

            this.OSR.build();
            this.default_map.add_reg(this.OSR, 'h2);
            this.SH_CTRL = new("SH_CTRL");
            this.SH_CTRL.configure(this);

            this.SH_CTRL.build();
            this.default_map.add_reg(this.SH_CTRL, 'h4);
            this.INT1_CTRL = new("INT1_CTRL");
            this.INT1_CTRL.configure(this);

            this.INT1_CTRL.build();
            this.default_map.add_reg(this.INT1_CTRL, 'h6);
            this.INT2_CTRL = new("INT2_CTRL");
            this.INT2_CTRL.configure(this);

            this.INT2_CTRL.build();
            this.default_map.add_reg(this.INT2_CTRL, 'h8);
            this.ADC_CTRL = new("ADC_CTRL");
            this.ADC_CTRL.configure(this);

            this.ADC_CTRL.build();
            this.default_map.add_reg(this.ADC_CTRL, 'ha);
            this.RUN_CTRL = new("RUN_CTRL");
            this.RUN_CTRL.configure(this);

            this.RUN_CTRL.build();
            this.default_map.add_reg(this.RUN_CTRL, 'hc);
            this.CLKGEN_DRP_0 = new("CLKGEN_DRP_0");
            this.CLKGEN_DRP_0.configure(this);

            this.CLKGEN_DRP_0.build();
            this.default_map.add_reg(this.CLKGEN_DRP_0, 'h10);
            this.CLKGEN_DRP_2 = new("CLKGEN_DRP_2");
            this.CLKGEN_DRP_2.configure(this);

            this.CLKGEN_DRP_2.build();
            this.default_map.add_reg(this.CLKGEN_DRP_2, 'h12);
            this.CLKGEN_DRP_3 = new("CLKGEN_DRP_3");
            this.CLKGEN_DRP_3.configure(this);

            this.CLKGEN_DRP_3.build();
            this.default_map.add_reg(this.CLKGEN_DRP_3, 'h14);
            this.adc_output_mem = new("adc_output_mem");
            this.adc_output_mem.configure(this);
            this.adc_output_mem.build();
            this.default_map.add_submap(this.adc_output_mem.default_map, 'h10000);
        endfunction : build
    endclass : adc_regs

endpackage: adc_regs_pkg
import uvm_pkg::*;
`include "uvm_macros.svh"

class ral_register_0 extends uvm_reg;
    uvm_reg_field NFFT_POWER;
    uvm_reg_field DWA_EN;

    `uvm_object_utils(ral_register_0)

    function new (string name = "ral_register_0");
        super.new(name,16,build_coverage(UVM_NO_COVERAGE));
    endfunction

    virtual function void build();
        this.NFFT_POWER = uvm_reg_field::type_id::create("NFFT_POWER", , get_full_name());
        this.NFFT_POWER.configure(
            this,
            14,
            0,
            "RW",
            0,
            0,
            1,
            0,
            0
        );
        this.DWA_EN = uvm_reg_field::type_id::create("DWA_EN", , get_full_name());
        this.DWA_EN.configure(
            this,
            1,
            15,
            "RW",
            0,
            0,
            1,
            0,
            0
        );
    endfunction

endclass

class ral_register_1 extends uvm_reg;
    uvm_reg_field OSR_POWER;

    `uvm_object_utils(ral_register_1)

    function new (string name = "ral_register_1");
        super.new(name,16,build_coverage(UVM_NO_COVERAGE));
    endfunction

    virtual function void build();
        this.OSR_POWER = uvm_reg_field::type_id::create("OSR_POWER", , get_full_name());
        this.OSR_POWER.configure(
            this,
            8,
            0,
            "RW",
            0,
            0,
            1,
            0,
            0
        );
    endfunction

endclass

class ral_register_2 extends uvm_reg;
    uvm_reg_field N_SH_TOTAL_CYCLES;

    `uvm_object_utils(ral_register_2)

    function new (string name = "ral_register_2");
        super.new(name,16,build_coverage(UVM_NO_COVERAGE));
    endfunction

    virtual function void build();
        this.N_SH_TOTAL_CYCLES = uvm_reg_field::type_id::create("N_SH_TOTAL_CYCLES", , get_full_name());
        this.N_SH_TOTAL_CYCLES.configure(
            this,
            16,
            0,
            "RW",
            0,
            1,
            1,
            0,
            0
        );
    endfunction

endclass

class ral_register_3 extends uvm_reg;
    uvm_reg_field N_SH_ACTIVE_CYCLES;

    `uvm_object_utils(ral_register_3)

    function new (string name = "ral_register_3");
        super.new(name,16,build_coverage(UVM_NO_COVERAGE));
    endfunction

    virtual function void build();
        this.N_SH_ACTIVE_CYCLES = uvm_reg_field::type_id::create("N_SH_ACTIVE_CYCLES", , get_full_name());
        this.N_SH_ACTIVE_CYCLES.configure(
            this,
            16,
            0,
            "RW",
            0,
            1,
            1,
            0,
            0
        );
    endfunction

endclass

class ral_register_4 extends uvm_reg;
    uvm_reg_field N_BOTTOM_PLATE_ACTIVE_CYCLES;

    `uvm_object_utils(ral_register_4)

    function new (string name = "ral_register_4");
        super.new(name,16,build_coverage(UVM_NO_COVERAGE));
    endfunction

    virtual function void build();
        this.N_BOTTOM_PLATE_ACTIVE_CYCLES = uvm_reg_field::type_id::create("N_BOTTOM_PLATE_ACTIVE_CYCLES", , get_full_name());
        this.N_BOTTOM_PLATE_ACTIVE_CYCLES.configure(
            this,
            16,
            0,
            "RW",
            0,
            1,
            1,
            0,
            0
        );
    endfunction

endclass

class ral_register_5 extends uvm_reg;
    uvm_reg_field N_SAR_CYCLES;

    `uvm_object_utils(ral_register_5)

    function new (string name = "ral_register_5");
        super.new(name,16,build_coverage(UVM_NO_COVERAGE));
    endfunction

    virtual function void build();
        this.N_SAR_CYCLES = uvm_reg_field::type_id::create("N_SAR_CYCLES", , get_full_name());
        this.N_SAR_CYCLES.configure(
            this,
            14,
            0,
            "RW",
            0,
            1,
            1,
            0,
            0
        );
    endfunction

endclass

class ral_register_6 extends uvm_reg;
    uvm_reg_field N_INT1_TOTAL_CYCLES;

    `uvm_object_utils(ral_register_6)

    function new (string name = "ral_register_6");
        super.new(name,16,build_coverage(UVM_NO_COVERAGE));
    endfunction

    virtual function void build();
        this.N_INT1_TOTAL_CYCLES = uvm_reg_field::type_id::create("N_INT1_TOTAL_CYCLES", , get_full_name());
        this.N_INT1_TOTAL_CYCLES.configure(
            this,
            16,
            0,
            "RW",
            0,
            1,
            1,
            0,
            0
        );
    endfunction

endclass

class ral_register_7 extends uvm_reg;
    uvm_reg_field N_INT1_ACTIVE_CYCLES;

    `uvm_object_utils(ral_register_7)

    function new (string name = "ral_register_7");
        super.new(name,16,build_coverage(UVM_NO_COVERAGE));
    endfunction

    virtual function void build();
        this.N_INT1_ACTIVE_CYCLES = uvm_reg_field::type_id::create("N_INT1_ACTIVE_CYCLES", , get_full_name());
        this.N_INT1_ACTIVE_CYCLES.configure(
            this,
            16,
            0,
            "RW",
            0,
            1,
            1,
            0,
            0
        );
    endfunction

endclass

class ral_register_8 extends uvm_reg;
    uvm_reg_field N_INT2_TOTAL_CYCLES;

    `uvm_object_utils(ral_register_8)

    function new (string name = "ral_register_8");
        super.new(name,16,build_coverage(UVM_NO_COVERAGE));
    endfunction

    virtual function void build();
        this.N_INT2_TOTAL_CYCLES = uvm_reg_field::type_id::create("N_INT2_TOTAL_CYCLES", , get_full_name());
        this.N_INT2_TOTAL_CYCLES.configure(
            this,
            16,
            0,
            "RW",
            0,
            1,
            1,
            0,
            0
        );
    endfunction

endclass

class ral_register_9 extends uvm_reg;
    uvm_reg_field N_INT2_ACTIVE_CYCLES;

    `uvm_object_utils(ral_register_9)

    function new (string name = "ral_register_9");
        super.new(name,16,build_coverage(UVM_NO_COVERAGE));
    endfunction

    virtual function void build();
        this.N_INT2_ACTIVE_CYCLES = uvm_reg_field::type_id::create("N_INT2_ACTIVE_CYCLES", , get_full_name());
        this.N_INT2_ACTIVE_CYCLES.configure(
            this,
            16,
            0,
            "RW",
            0,
            1,
            1,
            0,
            0
        );
    endfunction

endclass

class ral_register_10 extends uvm_reg;
    uvm_reg_field START_CONVERSION;
    uvm_reg_field MAIN_STATE_RB;

    `uvm_object_utils(ral_register_10)

    function new (string name = "ral_register_10");
        super.new(name,16,build_coverage(UVM_NO_COVERAGE));
    endfunction

    virtual function void build();
        this.START_CONVERSION = uvm_reg_field::type_id::create("START_CONVERSION", , get_full_name());
        this.START_CONVERSION.configure(
            this,
            1,
            0,
            "W1C",
            0,
            1,
            1,
            0,
            0
        );
        this.MAIN_STATE_RB = uvm_reg_field::type_id::create("MAIN_STATE_RB", , get_full_name());
        this.MAIN_STATE_RB.configure(
            this,
            3,
            1,
            "RO",
            0,
            0,
            1,
            0,
            0
        );
    endfunction

endclass

class ral_register_11 extends uvm_reg;
    uvm_reg_field CLKGEN_DRP_DADDR;

    `uvm_object_utils(ral_register_11)

    function new (string name = "ral_register_11");
        super.new(name,16,build_coverage(UVM_NO_COVERAGE));
    endfunction

    virtual function void build();
        this.CLKGEN_DRP_DADDR = uvm_reg_field::type_id::create("CLKGEN_DRP_DADDR", , get_full_name());
        this.CLKGEN_DRP_DADDR.configure(
            this,
            7,
            0,
            "RW",
            0,
            0,
            1,
            0,
            0
        );
    endfunction

endclass

class ral_register_12 extends uvm_reg;
    uvm_reg_field CLKGEN_DRP_DI;

    `uvm_object_utils(ral_register_12)

    function new (string name = "ral_register_12");
        super.new(name,16,build_coverage(UVM_NO_COVERAGE));
    endfunction

    virtual function void build();
        this.CLKGEN_DRP_DI = uvm_reg_field::type_id::create("CLKGEN_DRP_DI", , get_full_name());
        this.CLKGEN_DRP_DI.configure(
            this,
            16,
            0,
            "RW",
            0,
            0,
            1,
            0,
            0
        );
    endfunction

endclass

class ral_register_13 extends uvm_reg;
    uvm_reg_field CLKGEN_DRP_DO;

    `uvm_object_utils(ral_register_13)

    function new (string name = "ral_register_13");
        super.new(name,16,build_coverage(UVM_NO_COVERAGE));
    endfunction

    virtual function void build();
        this.CLKGEN_DRP_DO = uvm_reg_field::type_id::create("CLKGEN_DRP_DO", , get_full_name());
        this.CLKGEN_DRP_DO.configure(
            this,
            16,
            0,
            "RO",
            0,
            0,
            1,
            0,
            0
        );
    endfunction

endclass

class ral_register_14 extends uvm_reg;
    uvm_reg_field CLKGEN_DRP_RD_EN;
    uvm_reg_field CLKGEN_DRP_WR_EN;
    uvm_reg_field CLKGEN_DRP_DEN;

    `uvm_object_utils(ral_register_14)

    function new (string name = "ral_register_14");
        super.new(name,16,build_coverage(UVM_NO_COVERAGE));
    endfunction

    virtual function void build();
        this.CLKGEN_DRP_RD_EN = uvm_reg_field::type_id::create("CLKGEN_DRP_RD_EN", , get_full_name());
        this.CLKGEN_DRP_RD_EN.configure(
            this,
            1,
            0,
            "RW",
            0,
            0,
            1,
            0,
            0
        );
        this.CLKGEN_DRP_WR_EN = uvm_reg_field::type_id::create("CLKGEN_DRP_WR_EN", , get_full_name());
        this.CLKGEN_DRP_WR_EN.configure(
            this,
            1,
            1,
            "RW",
            0,
            0,
            1,
            0,
            0
        );
        this.CLKGEN_DRP_DEN = uvm_reg_field::type_id::create("CLKGEN_DRP_DEN", , get_full_name());
        this.CLKGEN_DRP_DEN.configure(
            this,
            1,
            2,
            "RW",
            0,
            0,
            1,
            0,
            0
        );
    endfunction

endclass

class dut_memory extends uvm_reg_block;
    ral_register_0 register_0;
    ral_register_1 register_1;
    ral_register_2 register_2;
    ral_register_3 register_3;
    ral_register_4 register_4;
    ral_register_5 register_5;
    ral_register_6 register_6;
    ral_register_7 register_7;
    ral_register_8 register_8;
    ral_register_9 register_9;
    ral_register_10 register_10;
    ral_register_11 register_11;
    ral_register_12 register_12;
    ral_register_13 register_13;
    ral_register_14 register_14;
    uvm_mem adc_mem;

    `uvm_object_utils(dut_memory)

    function new (string name = "dut_memory");
        super.new(name, build_coverage(UVM_NO_COVERAGE));
    endfunction

    virtual function build();
        this.default_map = create_map("default_map", 0, 2, UVM_LITTLE_ENDIAN);

        this.register_0 = ral_register_0::type_id::create("register_0", , get_full_name());
        this.register_0.configure(this, null, "");
        this.register_0.build();
        this.default_map.add_reg(this.register_0, `UVM_REG_ADDR_WIDTH'h0, "RW");

        this.register_1 = ral_register_1::type_id::create("register_1", , get_full_name());
        this.register_1.configure(this, null, "");
        this.register_1.build();
        this.default_map.add_reg(this.register_1, `UVM_REG_ADDR_WIDTH'h1, "RW");

        this.register_2 = ral_register_2::type_id::create("register_2", , get_full_name());
        this.register_2.configure(this, null, "");
        this.register_2.build();
        this.default_map.add_reg(this.register_2, `UVM_REG_ADDR_WIDTH'h2, "RW");

        this.register_3 = ral_register_3::type_id::create("register_3", , get_full_name());
        this.register_3.configure(this, null, "");
        this.register_3.build();
        this.default_map.add_reg(this.register_3, `UVM_REG_ADDR_WIDTH'h3, "RW");

        this.register_4 = ral_register_4::type_id::create("register_4", , get_full_name());
        this.register_4.configure(this, null, "");
        this.register_4.build();
        this.default_map.add_reg(this.register_4, `UVM_REG_ADDR_WIDTH'h4, "RW");

        this.register_5 = ral_register_5::type_id::create("register_5", , get_full_name());
        this.register_5.configure(this, null, "");
        this.register_5.build();
        this.default_map.add_reg(this.register_5, `UVM_REG_ADDR_WIDTH'h5, "RW");

        this.register_6 = ral_register_6::type_id::create("register_6", , get_full_name());
        this.register_6.configure(this, null, "");
        this.register_6.build();
        this.default_map.add_reg(this.register_6, `UVM_REG_ADDR_WIDTH'h6, "RW");

        this.register_7 = ral_register_7::type_id::create("register_7", , get_full_name());
        this.register_7.configure(this, null, "");
        this.register_7.build();
        this.default_map.add_reg(this.register_7, `UVM_REG_ADDR_WIDTH'h7, "RW");

        this.register_8 = ral_register_8::type_id::create("register_8", , get_full_name());
        this.register_8.configure(this, null, "");
        this.register_8.build();
        this.default_map.add_reg(this.register_8, `UVM_REG_ADDR_WIDTH'h8, "RW");

        this.register_9 = ral_register_9::type_id::create("register_9", , get_full_name());
        this.register_9.configure(this, null, "");
        this.register_9.build();
        this.default_map.add_reg(this.register_9, `UVM_REG_ADDR_WIDTH'h9, "RW");

        this.register_10 = ral_register_10::type_id::create("register_10", , get_full_name());
        this.register_10.configure(this, null, "");
        this.register_10.build();
        this.default_map.add_reg(this.register_10, `UVM_REG_ADDR_WIDTH'hA, "RW");

        this.register_11 = ral_register_11::type_id::create("register_11", , get_full_name());
        this.register_11.configure(this, null, "");
        this.register_11.build();
        this.default_map.add_reg(this.register_11, `UVM_REG_ADDR_WIDTH'hB, "RW");

        this.register_12 = ral_register_12::type_id::create("register_12", , get_full_name());
        this.register_12.configure(this, null, "");
        this.register_12.build();
        this.default_map.add_reg(this.register_12, `UVM_REG_ADDR_WIDTH'hC, "RW");

        this.register_13 = ral_register_13::type_id::create("register_13", , get_full_name());
        this.register_13.configure(this, null, "");
        this.register_13.build();
        this.default_map.add_reg(this.register_13, `UVM_REG_ADDR_WIDTH'hD, "RW");

        this.register_14 = ral_register_14::type_id::create("register_14", , get_full_name());
        this.register_14.configure(this, null, "");
        this.register_14.build();
        this.default_map.add_reg(this.register_14, `UVM_REG_ADDR_WIDTH'hE, "RW");

        this.adc_mem = new("adc_mem", 16384, 16, "RO");
        this.adc_mem.configure(this);
        this.default_map.add_mem(this.adc_mem, 16384, "RO");
    endfunction
endclass
import spi_agent_pkg::*;

class reg_env extends uvm_env;

    `uvm_component_utils(reg_env)
    function new (string name = "reg_env", uvm_component parent);
        super.new(name, parent);
    endfunction

    dut_memory                      ral_model;
    reg2spi_adapter                 adapter;
    uvm_reg_predictor #(spi_packet) spi_predictor;

    virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        ral_model = dut_memory::type_id::create("ral_model", this);
        adapter = reg2spi_adapter::type_id::create("adapter");
        
        spi_predictor = uvm_reg_predictor #(spi_packet)::type_id::create("spi_predictor", this);

        ral_model.build();
        ral_model.lock_model();
        ral_model.reset();
        ral_model.default_map.set_auto_predict(0);
        uvm_config_db #(dut_memory)::set(null, "uvm_test_top", "ral_model", ral_model);
    endfunction

    virtual function void connect_phase(uvm_phase phase);
        super.connect_phase(phase);
        spi_predictor.map = ral_model.default_map;
        spi_predictor.adapter = adapter;
    endfunction

endclasspackage reg_env_pkg;

    // include UVM package/macros
    import uvm_pkg::*;
    `include "uvm_macros.svh"

    // include agent packages
    import spi_agent_pkg::*;

    // include files
    `include "ral_dut_cfg.sv"
    `include "reg_env.sv"

endpackageclass adc_exact_scoreboard extends uvm_scoreboard;

endclassclass adc_noise_scoreboard extends uvm_scoreboard;

endclassclass reg_scoreboard extends uvm_scoreboard;
    // TODO: gather coverage information

    // TODO: throw error every time a SUBSEQUENT read does not match the mirrored value
    //       this is because primary reads should match mirrored vlaues
    //       Also : this should pay attention and make sure it compares before RAL is updated
endclass`timescale 1ns/1ps

import uvm_pkg::*;
`include "uvm_macros.svh"

import test_pkg::*;

module uvm_tb_top ();

    if_clkgen i_if_clkgen();
    if_input i_if_input();
    if_spi i_if_spi();

    if_status i_if_status();

    board_top DUT (
        .vin(i_if_input.hardware_port),
        .clkgen(i_if_clkgen.module_clkgen),
        .spi(i_if_spi)
    );

    // TODO: connect status interface signals
    // assign i_if_status.fsm_convert_status = DUT.
    assign i_if_status.fsm_convert_status = 2'b00;
    assign i_if_status.rst_b = DUT.DIGTOP.sys_rst_b;

    tb_top_cfg cfg;
    assign i_if_spi.miso = 1'b0;

    initial begin
        cfg = new("tb_top_cfg");
        cfg.vif_spi = i_if_spi;
        cfg.vif_clkgen = i_if_clkgen;
        cfg.vif_input = i_if_input;
        cfg.vif_status = i_if_status;

        uvm_config_db #(tb_top_cfg)::set(null, "*", "tb_top_cfg", cfg);

        // run_test("base_test");
        run_test("main_sm_test");
    end

endmoduleclass tb_top_cfg extends uvm_object;

    `uvm_object_utils(tb_top_cfg)

    virtual if_spi vif_spi;
    virtual if_clkgen vif_clkgen;
    virtual if_input vif_input;
    virtual if_status vif_status;

    function new (string name = "tb_top_cfg");
        super.new(name);
    endfunction

endclassimport uvm_pkg         ::*;
`include "uvm_macros.svh"

import adc_env_pkg     ::*;
import clkgen_agent_pkg::*;
import input_agent_pkg ::*;
import spi_agent_pkg   ::*;
import reg_env_pkg     ::*;

class base_test extends uvm_test;

    `uvm_component_utils(base_test)

    adc_env     env;
    tb_top_cfg  i_top_cfg;
    adc_env_cfg i_env_cfg;

    virtual if_status vif_status;

    bit checks_enable;
    bit coverage_enable;

    uvm_status_e status;

    function new (string name = "base_test", uvm_component parent = null);
        super.new(name, parent);
        checks_enable = 1'b0;
        coverage_enable = 1'b0; // these can be overridden in child constructors
    endfunction

    virtual function void build_phase(uvm_phase phase);
        if (!uvm_config_db #(tb_top_cfg)::get(this, "*", "tb_top_cfg", i_top_cfg))
            `uvm_fatal("TB_TOP", "Could not attach top-level configuration")

        i_env_cfg = new("i_env_cfg");
        randomize_config();
        i_env_cfg.vif_spi = i_top_cfg.vif_spi;
        i_env_cfg.vif_clkgen = i_top_cfg.vif_clkgen;
        i_env_cfg.vif_input = i_top_cfg.vif_input;
        vif_status = i_top_cfg.vif_status;

        i_env_cfg.checks_enable = checks_enable;
        i_env_cfg.coverage_enable = coverage_enable;

        uvm_config_db #(adc_env_cfg)::set(this, "env", "cfg", i_env_cfg);

        env = adc_env::type_id::create("env", this);
    endfunction

    virtual function int randomize_config();
        return i_env_cfg.randomize();
    endfunction

    virtual function void end_of_elaboration_phase(uvm_phase phase);
        uvm_top.print_topology();
    endfunction

    virtual task reset_phase(uvm_phase phase);
        start_clk_seq clk_seq;
        drive_sine_wave_seq input_seq;

        `uvm_info("RESET_PHASE", "Resetting DUT", UVM_MEDIUM)
        phase.raise_objection(this);

        clk_seq = start_clk_seq::type_id::create("clk_seq");
        input_seq = drive_sine_wave_seq::type_id::create("input_seq");

        fork
            clk_seq.start(env.clkgen.sequencer);
            input_seq.start(env.signal_gen.sequencer);
        join
        
        wait(vif_status.rst_b == 1);

        `uvm_info("RESET_PHASE", "DUT Successfully reset and sine wave being generated", UVM_MEDIUM)
        phase.drop_objection(this);

    endtask

    virtual task configure_phase (uvm_phase phase);
        dut_memory ral;
        logic [3:0] rdata;

        `uvm_info("CONFIG_PHASE", "Configuring DUT", UVM_MEDIUM)
        ral = env.ral.ral_model;

        phase.raise_objection(this);
        i_env_cfg.print();

        // write config to device
        set_field("NFFT_POWER", i_env_cfg.nfft_power);
        set_field("DWA_EN", i_env_cfg.dwa_en);
        set_field("OSR_POWER", i_env_cfg.osr_power);
        set_field("N_SH_TOTAL_CYCLES", i_env_cfg.n_sh_total_cycles);
        set_field("N_SH_ACTIVE_CYCLES", i_env_cfg.n_sh_active_cycles);
        set_field("N_BOTTOM_PLATE_ACTIVE_CYCLES", i_env_cfg.n_bottom_plate_active_cycles);
        set_field("N_SAR_CYCLES", i_env_cfg.n_sar_cycles);
        set_field("N_INT1_TOTAL_CYCLES", i_env_cfg.n_int1_total_cycles);
        set_field("N_INT1_ACTIVE_CYCLES", i_env_cfg.n_int1_active_cycles);
        set_field("N_INT2_TOTAL_CYCLES", i_env_cfg.n_int2_total_cycles);
        set_field("N_INT2_ACTIVE_CYCLES", i_env_cfg.n_int2_active_cycles);
        update_all_reg_burst();

        // mirror values back to make sure they are what we just wrote
        `uvm_info("CONFIG_PHASE", "Reading back registers to make sure write data worked", UVM_MEDIUM);
        mirror_all_reg_burst(UVM_CHECK);

        `uvm_info("CONFIG_PHASE", "Finished Configuring DUT", UVM_MEDIUM)
        
        ral.print();

        phase.drop_objection(this);
    endtask

    task write_field(string name, uvm_reg_data_t value);
        uvm_reg_field field_to_write;
        field_to_write = env.ral.ral_model.get_field_by_name(name);
        field_to_write.write(status, value);
    endtask

    task set_field(string name, uvm_reg_data_t value);
        uvm_reg_field field_to_set;
        field_to_set = env.ral.ral_model.get_field_by_name(name);
        field_to_set.set(value);
    endtask

    task update_all_reg();
        env.ral.ral_model.update(status);
    endtask

    task predict_field(string name, uvm_reg_data_t expected_value);
        uvm_reg_field field_to_check;
        field_to_check = env.ral.ral_model.get_field_by_name(name);
        field_to_check.predict(expected_value);
    endtask

    task mirror_field(string name, uvm_reg_data_t expected_value, uvm_check_e check = UVM_NO_CHECK);
        uvm_reg_field field_to_check;
        field_to_check = env.ral.ral_model.get_field_by_name(name);

        if (check == UVM_CHECK)
            field_to_check.predict(expected_value);
    
        field_to_check.mirror(status, check);
    endtask

    task read_field(string name, output uvm_reg_data_t reg_value);
        uvm_reg_field field_to_read;
        field_to_read = env.ral.ral_model.get_field_by_name(name);
        field_to_read.read(status, reg_value);
    endtask

    task write_reg_burst(bit [14:0] address, bit [15:0] write_data [$]);
        uvm_reg                  initial_register;
        spi_packet_reg_extension ext;
        bit [15:0]               address_data;
        uvm_status_e             status;

        initial_register = env.ral.ral_model.default_map.get_reg_by_offset(address);
        ext = spi_packet_reg_extension::type_id::create("burst_write_ext");
        address_data = write_data.pop_front();

        ext.n_additional_reads = 0;
        ext.additional_write_data = write_data;

        initial_register.write(
            .status(status), 
            .value(address_data), 
            .extension(ext)
        );

    endtask

    task mirror_reg_burst(bit [14:0] address, int n_reads, uvm_check_e check = UVM_NO_CHECK);
        uvm_reg                  initial_register;
        spi_packet_reg_extension ext;
        bit [15:0]               address_data;
        uvm_status_e             status;
        bit                      original_check_on_read;
        initial_register = env.ral.ral_model.default_map.get_reg_by_offset(address);
        ext = spi_packet_reg_extension::type_id::create("burst_write_ext");

        ext.n_additional_reads = n_reads - 1;
        ext.additional_write_data = {};

        original_check_on_read = env.ral.ral_model.default_map.get_check_on_read();

        if (check == UVM_CHECK) 
            env.ral.ral_model.default_map.set_check_on_read(1);

        initial_register.mirror(
            .status(status),
            .extension(ext)
        );

        if (check == UVM_CHECK)
            env.ral.ral_model.default_map.set_check_on_read(original_check_on_read);

    endtask

    task mirror_all_reg_burst(uvm_check_e check = UVM_NO_CHECK);
        uvm_reg regs [$];
        int     top_address;
        int     bottom_address;

        env.ral.ral_model.default_map.get_registers(regs);
        bottom_address = regs[0].get_address();
        top_address = bottom_address;

        for (int i = 1; i < regs.size(); i++) begin
            if (regs[i].get_address() > top_address)
                top_address = regs[i].get_address();
        end

        mirror_reg_burst(bottom_address, top_address - bottom_address + 1, check);

    endtask

    task update_all_reg_burst();
        uvm_reg regs [$];
        uvm_reg current_reg;

        bit [14:0]     low_address    ;
        bit [14:0]     high_address   ;
        bit [15:0]     write_data  [$];
        bit            update_data [$];
        uvm_reg_addr_t offset;

        env.ral.ral_model.default_map.get_registers(regs);

        offset = regs[0].get_address();
        low_address = offset;
        high_address = offset;

        for (int i = 1; i < regs.size(); i++) begin
            offset = regs[i].get_address();
            if (offset < low_address)
                low_address = offset;
            if (offset > high_address)
                high_address = offset;
        end

        // starting at low and going to high, get desired value
        write_data.delete();
        update_data.delete();
        for (int i = low_address; i <= high_address; i++) begin
            current_reg = env.ral.ral_model.default_map.get_reg_by_offset(i);
            if (current_reg != null) begin
                if (current_reg.needs_update()) begin
                    write_data.push_back(current_reg.get());
                    update_data.push_back(1);
                end else begin
                    write_data.push_back(current_reg.get_mirrored_value());
                    update_data.push_back(0);
                end
            end else begin
                write_data.push_back(0);
                update_data.push_back(0);
            end
        end

        // trim values that do not need to be updated
        while (update_data[0] == 0) begin
            update_data.pop_front();
            write_data.pop_front();
            low_address++;
        end

        while (update_data[update_data.size() - 1] == 0) begin
            update_data.pop_back();
            write_data.pop_back();
        end

        write_reg_burst(low_address, write_data);

    endtask

endclass

class main_sm_test extends base_test;

    `uvm_component_utils(main_sm_test)

    function new (string name = "main_sm_test", uvm_component parent = null);
        super.new(name, parent);
    endfunction

    virtual function int randomize_config();
        i_env_cfg.randomize() with {
            nfft_power == 4; // NFFT == 16
            osr_power  == 3; // OSR  == 8
            n_sh_total_cycles == 6;
            n_sh_active_cycles == 5;
            n_bottom_plate_active_cycles == 4;
            n_sar_cycles == 1;
            n_int1_total_cycles == 6;
            n_int1_active_cycles == 5;
            n_int2_total_cycles == 6;
            n_int2_active_cycles == 5;
        };
    endfunction

    virtual task main_phase(uvm_phase phase);
        logic readback_status;
        
        phase.raise_objection(this);
        `uvm_info("TEST", "Starting main phase", UVM_MEDIUM)

        write_field("START_CONVERSION", 1);

        do begin
            read_field("START_CONVERSION", readback_status);
        end while (readback_status == 0);

        phase.drop_objection(this);
        `uvm_info("TEST", "Ending main phase", UVM_MEDIUM)
    endtask

endclasspackage test_pkg;

import uvm_pkg::*;
`include "uvm_macros.svh"

`include "tb_top_cfg.sv"
`include "test_lib.sv"

endpackage<?xml version="1.0" encoding="UTF-8"?>
<wave_config>
   <wave_state>
   </wave_state>
   <db_ref_list>
      <db_ref path="uvm_tb_top_behav.wdb" id="1">
         <top_modules>
            <top_module name="adc_env_pkg" />
            <top_module name="clkgen_agent_pkg" />
            <top_module name="glbl" />
            <top_module name="input_agent_pkg" />
            <top_module name="reg_env_pkg" />
            <top_module name="spi_agent_pkg" />
            <top_module name="std" />
            <top_module name="test_pkg" />
            <top_module name="uvm_pkg" />
            <top_module name="uvm_tb_top" />
         </top_modules>
      </db_ref>
   </db_ref_list>
   <zoom_setting>
      <ZoomStartTime time="0.000000 us"></ZoomStartTime>
      <ZoomEndTime time="263.067100 us"></ZoomEndTime>
      <Cursor1Time time="263.067100 us"></Cursor1Time>
   </zoom_setting>
   <column_width_setting>
      <NameColumnWidth column_width="221"></NameColumnWidth>
      <ValueColumnWidth column_width="159"></ValueColumnWidth>
   </column_width_setting>
   <WVObjectSize size="70" />
   <wvobject type="divider" fp_name="divider54">
      <obj_property name="label">SPI</obj_property>
      <obj_property name="DisplayName">label</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/spi/scl" type="logic">
      <obj_property name="ElementShortName">scl</obj_property>
      <obj_property name="ObjectShortName">scl</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/spi/mosi" type="logic">
      <obj_property name="ElementShortName">mosi</obj_property>
      <obj_property name="ObjectShortName">mosi</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/spi/csb" type="logic">
      <obj_property name="ElementShortName">csb</obj_property>
      <obj_property name="ObjectShortName">csb</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/spi/miso" type="logic">
      <obj_property name="ElementShortName">miso</obj_property>
      <obj_property name="ObjectShortName">miso</obj_property>
   </wvobject>
   <wvobject type="divider" fp_name="divider53">
      <obj_property name="label">Register Read/Write</obj_property>
      <obj_property name="DisplayName">label</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_spi/scl" type="logic">
      <obj_property name="ElementShortName">scl</obj_property>
      <obj_property name="ObjectShortName">scl</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_spi/state" type="array">
      <obj_property name="ElementShortName">state[1:0]</obj_property>
      <obj_property name="ObjectShortName">state[1:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_spi/reg_addr" type="array">
      <obj_property name="ElementShortName">reg_addr[14:0]</obj_property>
      <obj_property name="ObjectShortName">reg_addr[14:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_spi/reg_wr_data" type="array">
      <obj_property name="ElementShortName">reg_wr_data[15:0]</obj_property>
      <obj_property name="ObjectShortName">reg_wr_data[15:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_spi/reg_wr_en" type="logic">
      <obj_property name="ElementShortName">reg_wr_en</obj_property>
      <obj_property name="ObjectShortName">reg_wr_en</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_spi/reg_addr" type="array">
      <obj_property name="ElementShortName">reg_addr[14:0]</obj_property>
      <obj_property name="ObjectShortName">reg_addr[14:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_spi/reg_rd_data" type="array">
      <obj_property name="ElementShortName">reg_rd_data[15:0]</obj_property>
      <obj_property name="ObjectShortName">reg_rd_data[15:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_spi/reg_rd_en" type="logic">
      <obj_property name="ElementShortName">reg_rd_en</obj_property>
      <obj_property name="ObjectShortName">reg_rd_en</obj_property>
   </wvobject>
   <wvobject type="divider" fp_name="divider84">
      <obj_property name="label">System Values</obj_property>
      <obj_property name="DisplayName">label</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_sysclk" type="logic">
      <obj_property name="ElementShortName">i_sysclk</obj_property>
      <obj_property name="ObjectShortName">i_sysclk</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/pll_clk" type="logic">
      <obj_property name="ElementShortName">pll_clk</obj_property>
      <obj_property name="ObjectShortName">pll_clk</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/sys_rst_b" type="logic">
      <obj_property name="ElementShortName">sys_rst_b</obj_property>
      <obj_property name="ObjectShortName">sys_rst_b</obj_property>
   </wvobject>
   <wvobject type="divider" fp_name="divider19">
      <obj_property name="label">SPICLK Interface</obj_property>
      <obj_property name="DisplayName">label</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_spi_clk/NFFT_POWER" type="array">
      <obj_property name="ElementShortName">NFFT_POWER[13:0]</obj_property>
      <obj_property name="ObjectShortName">NFFT_POWER[13:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_spi_clk/DWA_EN" type="logic">
      <obj_property name="ElementShortName">DWA_EN</obj_property>
      <obj_property name="ObjectShortName">DWA_EN</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_spi_clk/OSR_POWER" type="array">
      <obj_property name="ElementShortName">OSR_POWER[7:0]</obj_property>
      <obj_property name="ObjectShortName">OSR_POWER[7:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_spi_clk/N_SH_TOTAL_CYCLES" type="array">
      <obj_property name="ElementShortName">N_SH_TOTAL_CYCLES[15:0]</obj_property>
      <obj_property name="ObjectShortName">N_SH_TOTAL_CYCLES[15:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_spi_clk/N_SH_ACTIVE_CYCLES" type="array">
      <obj_property name="ElementShortName">N_SH_ACTIVE_CYCLES[15:0]</obj_property>
      <obj_property name="ObjectShortName">N_SH_ACTIVE_CYCLES[15:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_spi_clk/N_BOTTOM_PLATE_ACTIVE_CYCLES" type="array">
      <obj_property name="ElementShortName">N_BOTTOM_PLATE_ACTIVE_CYCLES[15:0]</obj_property>
      <obj_property name="ObjectShortName">N_BOTTOM_PLATE_ACTIVE_CYCLES[15:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_spi_clk/N_SAR_CYCLES" type="array">
      <obj_property name="ElementShortName">N_SAR_CYCLES[13:0]</obj_property>
      <obj_property name="ObjectShortName">N_SAR_CYCLES[13:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_spi_clk/N_INT1_TOTAL_CYCLES" type="array">
      <obj_property name="ElementShortName">N_INT1_TOTAL_CYCLES[15:0]</obj_property>
      <obj_property name="ObjectShortName">N_INT1_TOTAL_CYCLES[15:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_spi_clk/N_INT1_ACTIVE_CYCLES" type="array">
      <obj_property name="ElementShortName">N_INT1_ACTIVE_CYCLES[15:0]</obj_property>
      <obj_property name="ObjectShortName">N_INT1_ACTIVE_CYCLES[15:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_spi_clk/N_INT2_TOTAL_CYCLES" type="array">
      <obj_property name="ElementShortName">N_INT2_TOTAL_CYCLES[15:0]</obj_property>
      <obj_property name="ObjectShortName">N_INT2_TOTAL_CYCLES[15:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_spi_clk/N_INT2_ACTIVE_CYCLES" type="array">
      <obj_property name="ElementShortName">N_INT2_ACTIVE_CYCLES[15:0]</obj_property>
      <obj_property name="ObjectShortName">N_INT2_ACTIVE_CYCLES[15:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_spi_clk/START_CONVERSION" type="logic">
      <obj_property name="ElementShortName">START_CONVERSION</obj_property>
      <obj_property name="ObjectShortName">START_CONVERSION</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_spi_clk/START_CONVERSION_set" type="logic">
      <obj_property name="ElementShortName">START_CONVERSION_set</obj_property>
      <obj_property name="ObjectShortName">START_CONVERSION_set</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_spi_clk/START_CONVERSION_clear" type="logic">
      <obj_property name="ElementShortName">START_CONVERSION_clear</obj_property>
      <obj_property name="ObjectShortName">START_CONVERSION_clear</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_spi_clk/MAIN_STATE_RB" type="array">
      <obj_property name="ElementShortName">MAIN_STATE_RB[2:0]</obj_property>
      <obj_property name="ObjectShortName">MAIN_STATE_RB[2:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_spi_clk/CLKGEN_DRP_DADDR" type="array">
      <obj_property name="ElementShortName">CLKGEN_DRP_DADDR[6:0]</obj_property>
      <obj_property name="ObjectShortName">CLKGEN_DRP_DADDR[6:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_spi_clk/CLKGEN_DRP_DI" type="array">
      <obj_property name="ElementShortName">CLKGEN_DRP_DI[15:0]</obj_property>
      <obj_property name="ObjectShortName">CLKGEN_DRP_DI[15:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_spi_clk/CLKGEN_DRP_DO" type="array">
      <obj_property name="ElementShortName">CLKGEN_DRP_DO[15:0]</obj_property>
      <obj_property name="ObjectShortName">CLKGEN_DRP_DO[15:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_spi_clk/CLKGEN_DRP_RD_EN" type="logic">
      <obj_property name="ElementShortName">CLKGEN_DRP_RD_EN</obj_property>
      <obj_property name="ObjectShortName">CLKGEN_DRP_RD_EN</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_spi_clk/CLKGEN_DRP_WR_EN" type="logic">
      <obj_property name="ElementShortName">CLKGEN_DRP_WR_EN</obj_property>
      <obj_property name="ObjectShortName">CLKGEN_DRP_WR_EN</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_spi_clk/CLKGEN_DRP_DEN" type="logic">
      <obj_property name="ElementShortName">CLKGEN_DRP_DEN</obj_property>
      <obj_property name="ObjectShortName">CLKGEN_DRP_DEN</obj_property>
   </wvobject>
   <wvobject type="divider" fp_name="divider83">
      <obj_property name="label">SYSCLK Interface</obj_property>
      <obj_property name="DisplayName">label</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_sys_clk/NFFT_POWER" type="array">
      <obj_property name="ElementShortName">NFFT_POWER[13:0]</obj_property>
      <obj_property name="ObjectShortName">NFFT_POWER[13:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_sys_clk/DWA_EN" type="logic">
      <obj_property name="ElementShortName">DWA_EN</obj_property>
      <obj_property name="ObjectShortName">DWA_EN</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_sys_clk/OSR_POWER" type="array">
      <obj_property name="ElementShortName">OSR_POWER[7:0]</obj_property>
      <obj_property name="ObjectShortName">OSR_POWER[7:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_sys_clk/N_SH_TOTAL_CYCLES" type="array">
      <obj_property name="ElementShortName">N_SH_TOTAL_CYCLES[15:0]</obj_property>
      <obj_property name="ObjectShortName">N_SH_TOTAL_CYCLES[15:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_sys_clk/N_SH_ACTIVE_CYCLES" type="array">
      <obj_property name="ElementShortName">N_SH_ACTIVE_CYCLES[15:0]</obj_property>
      <obj_property name="ObjectShortName">N_SH_ACTIVE_CYCLES[15:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_sys_clk/N_BOTTOM_PLATE_ACTIVE_CYCLES" type="array">
      <obj_property name="ElementShortName">N_BOTTOM_PLATE_ACTIVE_CYCLES[15:0]</obj_property>
      <obj_property name="ObjectShortName">N_BOTTOM_PLATE_ACTIVE_CYCLES[15:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_sys_clk/N_SAR_CYCLES" type="array">
      <obj_property name="ElementShortName">N_SAR_CYCLES[13:0]</obj_property>
      <obj_property name="ObjectShortName">N_SAR_CYCLES[13:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_sys_clk/N_INT1_TOTAL_CYCLES" type="array">
      <obj_property name="ElementShortName">N_INT1_TOTAL_CYCLES[15:0]</obj_property>
      <obj_property name="ObjectShortName">N_INT1_TOTAL_CYCLES[15:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_sys_clk/N_INT1_ACTIVE_CYCLES" type="array">
      <obj_property name="ElementShortName">N_INT1_ACTIVE_CYCLES[15:0]</obj_property>
      <obj_property name="ObjectShortName">N_INT1_ACTIVE_CYCLES[15:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_sys_clk/N_INT2_TOTAL_CYCLES" type="array">
      <obj_property name="ElementShortName">N_INT2_TOTAL_CYCLES[15:0]</obj_property>
      <obj_property name="ObjectShortName">N_INT2_TOTAL_CYCLES[15:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_sys_clk/N_INT2_ACTIVE_CYCLES" type="array">
      <obj_property name="ElementShortName">N_INT2_ACTIVE_CYCLES[15:0]</obj_property>
      <obj_property name="ObjectShortName">N_INT2_ACTIVE_CYCLES[15:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_sys_clk/START_CONVERSION" type="logic">
      <obj_property name="ElementShortName">START_CONVERSION</obj_property>
      <obj_property name="ObjectShortName">START_CONVERSION</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_sys_clk/START_CONVERSION_set" type="logic">
      <obj_property name="ElementShortName">START_CONVERSION_set</obj_property>
      <obj_property name="ObjectShortName">START_CONVERSION_set</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_sys_clk/START_CONVERSION_clear" type="logic">
      <obj_property name="ElementShortName">START_CONVERSION_clear</obj_property>
      <obj_property name="ObjectShortName">START_CONVERSION_clear</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_sys_clk/MAIN_STATE_RB" type="array">
      <obj_property name="ElementShortName">MAIN_STATE_RB[2:0]</obj_property>
      <obj_property name="ObjectShortName">MAIN_STATE_RB[2:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_sys_clk/CLKGEN_DRP_DADDR" type="array">
      <obj_property name="ElementShortName">CLKGEN_DRP_DADDR[6:0]</obj_property>
      <obj_property name="ObjectShortName">CLKGEN_DRP_DADDR[6:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_sys_clk/CLKGEN_DRP_DI" type="array">
      <obj_property name="ElementShortName">CLKGEN_DRP_DI[15:0]</obj_property>
      <obj_property name="ObjectShortName">CLKGEN_DRP_DI[15:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_sys_clk/CLKGEN_DRP_DO" type="array">
      <obj_property name="ElementShortName">CLKGEN_DRP_DO[15:0]</obj_property>
      <obj_property name="ObjectShortName">CLKGEN_DRP_DO[15:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_sys_clk/CLKGEN_DRP_RD_EN" type="logic">
      <obj_property name="ElementShortName">CLKGEN_DRP_RD_EN</obj_property>
      <obj_property name="ObjectShortName">CLKGEN_DRP_RD_EN</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_sys_clk/CLKGEN_DRP_WR_EN" type="logic">
      <obj_property name="ElementShortName">CLKGEN_DRP_WR_EN</obj_property>
      <obj_property name="ObjectShortName">CLKGEN_DRP_WR_EN</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_reg_if_sys_clk/CLKGEN_DRP_DEN" type="logic">
      <obj_property name="ElementShortName">CLKGEN_DRP_DEN</obj_property>
      <obj_property name="ObjectShortName">CLKGEN_DRP_DEN</obj_property>
   </wvobject>
   <wvobject type="divider" fp_name="divider683">
      <obj_property name="label">Main State Machine Output</obj_property>
      <obj_property name="DisplayName">label</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_main_state_machine/state" type="array">
      <obj_property name="ElementShortName">state[2:0]</obj_property>
      <obj_property name="ObjectShortName">state[2:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_main_state_machine/o_sample" type="logic">
      <obj_property name="ElementShortName">o_sample</obj_property>
      <obj_property name="ObjectShortName">o_sample</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_main_state_machine/o_int1" type="logic">
      <obj_property name="ElementShortName">o_int1</obj_property>
      <obj_property name="ObjectShortName">o_int1</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_main_state_machine/o_int2" type="logic">
      <obj_property name="ElementShortName">o_int2</obj_property>
      <obj_property name="ObjectShortName">o_int2</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/pll_clk" type="logic">
      <obj_property name="ElementShortName">pll_clk</obj_property>
      <obj_property name="ObjectShortName">pll_clk</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_main_state_machine/nfft_counter" type="array">
      <obj_property name="ElementShortName">nfft_counter[13:0]</obj_property>
      <obj_property name="ObjectShortName">nfft_counter[13:0]</obj_property>
   </wvobject>
   <wvobject fp_name="/uvm_tb_top/DUT/DIGTOP/i_main_state_machine/current_state_counter" type="array">
      <obj_property name="ElementShortName">current_state_counter[15:0]</obj_property>
      <obj_property name="ObjectShortName">current_state_counter[15:0]</obj_property>
   </wvobject>
</wave_config>
addrmap adc_regs {
    desc = "SAR ADC PCB register map";
    default regwidth=16;
    default sw=rw;
    default hw=r;
    default reset=0x0;

    enum input_mode_e {
        SINGLE_ENDED = 0;
        DIFFERENTIAL = 1;
    };

    reg {
        field {
            desc="FFT power (8 LSB bits). When taking FFT samples, the ADC will take 2^NFFT_POWER samples.";
        } NFFT_POWER [14:0];
        field {
            desc="If 1, enables DWA during FFT conversion. Else, there will be no DEM whatsoever.";
        } DWA_EN [15:15];
    } NFFT_CTRL @ 0x0;

    reg {
        field {
            desc="OSR power - configures ADC to have an oversampling ratio of 2^OSR_POWER. This allows an OSR of up to 256.";
        } OSR_POWER [7:0];
    } OSR @ 0x2;

    // describe "active" and "passive" cycles of some ADC operation
    reg active_passive_reg {
        field {
            desc="Number of ADC clock cycles during which target will be active.";
            reset=0x1;
        } N_ACTIVE_CYCLES [7:0];
        field {
            desc="Number of ADC clock cycles during which target will be inactive.";
        } N_PASSIVE_CYCLES [15:8];
    };
    
    active_passive_reg SH_CTRL @ 0x4;
    active_passive_reg INT1_CTRL @ 0x6;
    active_passive_reg INT2_CTRL @ 0x8;

    reg {
        field {
            desc="Single-ended will only take inputs at the single-ended input of the PCB, which will compare to the programmed VCM value. Differential will read from the differential inputs.";
            encode=input_mode_e;
        } INPUT_MODE [0:0];
        field {
            desc="VCM selection for single-ended mode. 0 will connect the single-ended value to ground, where all 1s will connect the single-ended value to VDD.";
        } VCM_SINGLE_ENDED [4:1];
        field {
            desc="SAR asynchronous delay control. Higher values will lead to longer SAR clock periods.";
        } DELAY_LINE_CTRL [8:5];
        field {
            desc="Number of bits to quantize, minus one. That is, the SAR will quantize N_QUANTIZER_BITS + 1.";
        } N_QUANTIZER_BITS [10:9];
        field {
            desc="If 1, runs the ADC in incremental mode, meaning that the reset will be applied and the output will be filtered (up-counted). Else, runs in delta-sigma mode, and there will be no filtering at the output.";
        } INCREMENTAL_MODE_EN [11:11];
        
        field {
            desc="If 0, run an NFFT conversion with SAR quantizer only. If 1, run with noise-shaping.";
        } NOISE_SHAPING_EN [12:12];
    } ADC_CTRL @ 0xA;

    reg {
        default sw=rw;
        default hw=r;
        donttest;

        field {
            hwclr;
            desc="When a 1 is written, starts an NFFT conversion. When read, a 1 means the NFFT conversion is running, and a 0 means it is not. If a 0 is written while the conversion is running, terminates the conversion early and sets state machine back to ready state.";
        } NFFT_EN [1:1];
        field {
            sw=r;
            hw=w;
            desc="Readback of the current status of the main state machine.";
        } MAIN_STATE_RB [5:2];
    } RUN_CTRL @ 0xC;

    // xilinx CLKGEN DRP registers
    reg {
        donttest;

        field {
            desc="Read enable bit for CLKGEN xip";
        } CLKGEN_DRP_RD_EN [0:0];
        field {
            desc="Write enable bit for CLKGEN xip";
        } CLKGEN_DRP_WR_EN [1:1];
        field {
            desc="Data enable bit for CLKGEN xip";
        } CLKGEN_DRP_DEN [2:2];
        field {
            desc="Read/Write address for CLKGEN xip";
        } CLKGEN_DRP_DADDR [9:3];
    } CLKGEN_DRP_0 @ 0x10;

    reg {
        donttest;
        regwidth=16;
        field {
            desc="Data input for CLKGEN xip";
        } CLKGEN_DRP_DI [15:0];
    } CLKGEN_DRP_2 @ 0x12;

    reg {
        donttest;
        regwidth=16;
        field {
            sw=r;
            hw=w;
            desc="Data output for CLKGEN xip";
        } CLKGEN_DRP_DO [15:0];
    } CLKGEN_DRP_3 @ 0x14;

    mem {
        sw=r;
        memwidth=16;
        
        mementries=0x8000;
    } external adc_output_mem @ 0x10000;
};module cdc_sync #(
    parameter N_SYNC_STAGES=3
) (
    reg_if.WR_BUS_CLK bus_clk_reg,
    reg_if.WR_SYS_CLK sys_clk_reg,
    input logic sys_clk,
    input logic bus_clk
);

    // RO registers, sys_clk -> bus_clk
    `ifdef VIVADO
    xpm_cdc_array_single #(
        .DEST_SYNC_FF(N_SYNC_STAGES),
        .WIDTH(3),
        .SRC_INPUT_REG(0)
    ) cdc_sync_to_bus_clk_MAIN_STATE_RB (
        .src_in  (sys_clk_reg.MAIN_STATE_RB),
        .dest_out(bus_clk_reg.MAIN_STATE_RB),
        .dest_clk(bus_clk),
        .src_clk(sys_clk)
    );
    `else
    logic [N_SYNC_STAGES-1:0] sync_to_bus_clk_MAIN_STATE_RB [(N_SYNC_STAGES-1):0];
    genvar i;
    for (i = 0; i < N_SYNC_STAGES; i++) begin
        always_ff @(posedge bus_clk) begin
            if (i == 0)
                sync_to_bus_clk_MAIN_STATE_RB[i] <= sys_clk_reg.MAIN_STATE_RB;
            else
                sync_to_bus_clk_MAIN_STATE_RB[i] <= sync_to_bus_clk_MAIN_STATE_RB[i - 1];
        end
    end
    assign bus_clk_reg.MAIN_STATE_RB = sync_to_bus_clk_MAIN_STATE_RB[N_SYNC_STAGES - 1];
    `endif

    `ifdef VIVADO
    xpm_cdc_array_single #(
        .DEST_SYNC_FF(N_SYNC_STAGES),
        .WIDTH(16),
        .SRC_INPUT_REG(0)
    ) cdc_sync_to_bus_clk_CLKGEN_DRP_DO (
        .src_in  (sys_clk_reg.CLKGEN_DRP_DO),
        .dest_out(bus_clk_reg.CLKGEN_DRP_DO),
        .dest_clk(bus_clk),
        .src_clk(sys_clk)
    );
    `else
    logic [N_SYNC_STAGES-1:0] sync_to_bus_clk_CLKGEN_DRP_DO [(N_SYNC_STAGES-1):0];
    genvar i;
    for (i = 0; i < N_SYNC_STAGES; i++) begin
        always_ff @(posedge bus_clk) begin
            if (i == 0)
                sync_to_bus_clk_CLKGEN_DRP_DO[i] <= sys_clk_reg.CLKGEN_DRP_DO;
            else
                sync_to_bus_clk_CLKGEN_DRP_DO[i] <= sync_to_bus_clk_CLKGEN_DRP_DO[i - 1];
        end
    end
    assign bus_clk_reg.CLKGEN_DRP_DO = sync_to_bus_clk_CLKGEN_DRP_DO[N_SYNC_STAGES - 1];
    `endif

    // RO registers, bus_clk -> sys_clk
    `ifdef VIVADO
    xpm_cdc_array_single #(
        .DEST_SYNC_FF(N_SYNC_STAGES),
        .WIDTH(14),
        .SRC_INPUT_REG(0)
    ) cdc_sync_to_sys_clk_NFFT_POWER (
        .src_in  (bus_clk_reg.NFFT_POWER),
        .dest_out(sys_clk_reg.NFFT_POWER),
        .dest_clk(sys_clk),
        .src_clk(bus_clk)
    );
    `else
    logic [N_SYNC_STAGES-1:0] sync_to_sys_clk_NFFT_POWER [(N_SYNC_STAGES-1):0];
    genvar i;
    for (i = 0; i < N_SYNC_STAGES; i++) begin
        always_ff @(posedge sys_clk) begin
            if (i == 0)
                sync_to_sys_clk_NFFT_POWER[i] <= bus_clk_reg.NFFT_POWER;
            else
                sync_to_sys_clk_NFFT_POWER[i] <= sync_to_sys_clk_NFFT_POWER[i - 1];
        end
    end
    assign sys_clk_reg.NFFT_POWER = sync_to_sys_clk_NFFT_POWER[N_SYNC_STAGES - 1];
    `endif

    `ifdef VIVADO
    xpm_cdc_array_single #(
        .DEST_SYNC_FF(N_SYNC_STAGES),
        .WIDTH(1),
        .SRC_INPUT_REG(0)
    ) cdc_sync_to_sys_clk_DWA_EN (
        .src_in  (bus_clk_reg.DWA_EN),
        .dest_out(sys_clk_reg.DWA_EN),
        .dest_clk(sys_clk),
        .src_clk(bus_clk)
    );
    `else
    logic       sync_to_sys_clk_DWA_EN [(N_SYNC_STAGES-1):0];
    genvar i;
    for (i = 0; i < N_SYNC_STAGES; i++) begin
        always_ff @(posedge sys_clk) begin
            if (i == 0)
                sync_to_sys_clk_DWA_EN[i] <= bus_clk_reg.DWA_EN;
            else
                sync_to_sys_clk_DWA_EN[i] <= sync_to_sys_clk_DWA_EN[i - 1];
        end
    end
    assign sys_clk_reg.DWA_EN = sync_to_sys_clk_DWA_EN[N_SYNC_STAGES - 1];
    `endif

    `ifdef VIVADO
    xpm_cdc_array_single #(
        .DEST_SYNC_FF(N_SYNC_STAGES),
        .WIDTH(8),
        .SRC_INPUT_REG(0)
    ) cdc_sync_to_sys_clk_OSR_POWER (
        .src_in  (bus_clk_reg.OSR_POWER),
        .dest_out(sys_clk_reg.OSR_POWER),
        .dest_clk(sys_clk),
        .src_clk(bus_clk)
    );
    `else
    logic [N_SYNC_STAGES-1:0] sync_to_sys_clk_OSR_POWER [(N_SYNC_STAGES-1):0];
    genvar i;
    for (i = 0; i < N_SYNC_STAGES; i++) begin
        always_ff @(posedge sys_clk) begin
            if (i == 0)
                sync_to_sys_clk_OSR_POWER[i] <= bus_clk_reg.OSR_POWER;
            else
                sync_to_sys_clk_OSR_POWER[i] <= sync_to_sys_clk_OSR_POWER[i - 1];
        end
    end
    assign sys_clk_reg.OSR_POWER = sync_to_sys_clk_OSR_POWER[N_SYNC_STAGES - 1];
    `endif

    `ifdef VIVADO
    xpm_cdc_array_single #(
        .DEST_SYNC_FF(N_SYNC_STAGES),
        .WIDTH(16),
        .SRC_INPUT_REG(0)
    ) cdc_sync_to_sys_clk_N_SH_TOTAL_CYCLES (
        .src_in  (bus_clk_reg.N_SH_TOTAL_CYCLES),
        .dest_out(sys_clk_reg.N_SH_TOTAL_CYCLES),
        .dest_clk(sys_clk),
        .src_clk(bus_clk)
    );
    `else
    logic [N_SYNC_STAGES-1:0] sync_to_sys_clk_N_SH_TOTAL_CYCLES [(N_SYNC_STAGES-1):0];
    genvar i;
    for (i = 0; i < N_SYNC_STAGES; i++) begin
        always_ff @(posedge sys_clk) begin
            if (i == 0)
                sync_to_sys_clk_N_SH_TOTAL_CYCLES[i] <= bus_clk_reg.N_SH_TOTAL_CYCLES;
            else
                sync_to_sys_clk_N_SH_TOTAL_CYCLES[i] <= sync_to_sys_clk_N_SH_TOTAL_CYCLES[i - 1];
        end
    end
    assign sys_clk_reg.N_SH_TOTAL_CYCLES = sync_to_sys_clk_N_SH_TOTAL_CYCLES[N_SYNC_STAGES - 1];
    `endif

    `ifdef VIVADO
    xpm_cdc_array_single #(
        .DEST_SYNC_FF(N_SYNC_STAGES),
        .WIDTH(16),
        .SRC_INPUT_REG(0)
    ) cdc_sync_to_sys_clk_N_SH_ACTIVE_CYCLES (
        .src_in  (bus_clk_reg.N_SH_ACTIVE_CYCLES),
        .dest_out(sys_clk_reg.N_SH_ACTIVE_CYCLES),
        .dest_clk(sys_clk),
        .src_clk(bus_clk)
    );
    `else
    logic [N_SYNC_STAGES-1:0] sync_to_sys_clk_N_SH_ACTIVE_CYCLES [(N_SYNC_STAGES-1):0];
    genvar i;
    for (i = 0; i < N_SYNC_STAGES; i++) begin
        always_ff @(posedge sys_clk) begin
            if (i == 0)
                sync_to_sys_clk_N_SH_ACTIVE_CYCLES[i] <= bus_clk_reg.N_SH_ACTIVE_CYCLES;
            else
                sync_to_sys_clk_N_SH_ACTIVE_CYCLES[i] <= sync_to_sys_clk_N_SH_ACTIVE_CYCLES[i - 1];
        end
    end
    assign sys_clk_reg.N_SH_ACTIVE_CYCLES = sync_to_sys_clk_N_SH_ACTIVE_CYCLES[N_SYNC_STAGES - 1];
    `endif

    `ifdef VIVADO
    xpm_cdc_array_single #(
        .DEST_SYNC_FF(N_SYNC_STAGES),
        .WIDTH(16),
        .SRC_INPUT_REG(0)
    ) cdc_sync_to_sys_clk_N_BOTTOM_PLATE_ACTIVE_CYCLES (
        .src_in  (bus_clk_reg.N_BOTTOM_PLATE_ACTIVE_CYCLES),
        .dest_out(sys_clk_reg.N_BOTTOM_PLATE_ACTIVE_CYCLES),
        .dest_clk(sys_clk),
        .src_clk(bus_clk)
    );
    `else
    logic [N_SYNC_STAGES-1:0] sync_to_sys_clk_N_BOTTOM_PLATE_ACTIVE_CYCLES [(N_SYNC_STAGES-1):0];
    genvar i;
    for (i = 0; i < N_SYNC_STAGES; i++) begin
        always_ff @(posedge sys_clk) begin
            if (i == 0)
                sync_to_sys_clk_N_BOTTOM_PLATE_ACTIVE_CYCLES[i] <= bus_clk_reg.N_BOTTOM_PLATE_ACTIVE_CYCLES;
            else
                sync_to_sys_clk_N_BOTTOM_PLATE_ACTIVE_CYCLES[i] <= sync_to_sys_clk_N_BOTTOM_PLATE_ACTIVE_CYCLES[i - 1];
        end
    end
    assign sys_clk_reg.N_BOTTOM_PLATE_ACTIVE_CYCLES = sync_to_sys_clk_N_BOTTOM_PLATE_ACTIVE_CYCLES[N_SYNC_STAGES - 1];
    `endif

    `ifdef VIVADO
    xpm_cdc_array_single #(
        .DEST_SYNC_FF(N_SYNC_STAGES),
        .WIDTH(14),
        .SRC_INPUT_REG(0)
    ) cdc_sync_to_sys_clk_N_SAR_CYCLES (
        .src_in  (bus_clk_reg.N_SAR_CYCLES),
        .dest_out(sys_clk_reg.N_SAR_CYCLES),
        .dest_clk(sys_clk),
        .src_clk(bus_clk)
    );
    `else
    logic [N_SYNC_STAGES-1:0] sync_to_sys_clk_N_SAR_CYCLES [(N_SYNC_STAGES-1):0];
    genvar i;
    for (i = 0; i < N_SYNC_STAGES; i++) begin
        always_ff @(posedge sys_clk) begin
            if (i == 0)
                sync_to_sys_clk_N_SAR_CYCLES[i] <= bus_clk_reg.N_SAR_CYCLES;
            else
                sync_to_sys_clk_N_SAR_CYCLES[i] <= sync_to_sys_clk_N_SAR_CYCLES[i - 1];
        end
    end
    assign sys_clk_reg.N_SAR_CYCLES = sync_to_sys_clk_N_SAR_CYCLES[N_SYNC_STAGES - 1];
    `endif

    `ifdef VIVADO
    xpm_cdc_array_single #(
        .DEST_SYNC_FF(N_SYNC_STAGES),
        .WIDTH(16),
        .SRC_INPUT_REG(0)
    ) cdc_sync_to_sys_clk_N_INT1_TOTAL_CYCLES (
        .src_in  (bus_clk_reg.N_INT1_TOTAL_CYCLES),
        .dest_out(sys_clk_reg.N_INT1_TOTAL_CYCLES),
        .dest_clk(sys_clk),
        .src_clk(bus_clk)
    );
    `else
    logic [N_SYNC_STAGES-1:0] sync_to_sys_clk_N_INT1_TOTAL_CYCLES [(N_SYNC_STAGES-1):0];
    genvar i;
    for (i = 0; i < N_SYNC_STAGES; i++) begin
        always_ff @(posedge sys_clk) begin
            if (i == 0)
                sync_to_sys_clk_N_INT1_TOTAL_CYCLES[i] <= bus_clk_reg.N_INT1_TOTAL_CYCLES;
            else
                sync_to_sys_clk_N_INT1_TOTAL_CYCLES[i] <= sync_to_sys_clk_N_INT1_TOTAL_CYCLES[i - 1];
        end
    end
    assign sys_clk_reg.N_INT1_TOTAL_CYCLES = sync_to_sys_clk_N_INT1_TOTAL_CYCLES[N_SYNC_STAGES - 1];
    `endif

    `ifdef VIVADO
    xpm_cdc_array_single #(
        .DEST_SYNC_FF(N_SYNC_STAGES),
        .WIDTH(16),
        .SRC_INPUT_REG(0)
    ) cdc_sync_to_sys_clk_N_INT1_ACTIVE_CYCLES (
        .src_in  (bus_clk_reg.N_INT1_ACTIVE_CYCLES),
        .dest_out(sys_clk_reg.N_INT1_ACTIVE_CYCLES),
        .dest_clk(sys_clk),
        .src_clk(bus_clk)
    );
    `else
    logic [N_SYNC_STAGES-1:0] sync_to_sys_clk_N_INT1_ACTIVE_CYCLES [(N_SYNC_STAGES-1):0];
    genvar i;
    for (i = 0; i < N_SYNC_STAGES; i++) begin
        always_ff @(posedge sys_clk) begin
            if (i == 0)
                sync_to_sys_clk_N_INT1_ACTIVE_CYCLES[i] <= bus_clk_reg.N_INT1_ACTIVE_CYCLES;
            else
                sync_to_sys_clk_N_INT1_ACTIVE_CYCLES[i] <= sync_to_sys_clk_N_INT1_ACTIVE_CYCLES[i - 1];
        end
    end
    assign sys_clk_reg.N_INT1_ACTIVE_CYCLES = sync_to_sys_clk_N_INT1_ACTIVE_CYCLES[N_SYNC_STAGES - 1];
    `endif

    `ifdef VIVADO
    xpm_cdc_array_single #(
        .DEST_SYNC_FF(N_SYNC_STAGES),
        .WIDTH(16),
        .SRC_INPUT_REG(0)
    ) cdc_sync_to_sys_clk_N_INT2_TOTAL_CYCLES (
        .src_in  (bus_clk_reg.N_INT2_TOTAL_CYCLES),
        .dest_out(sys_clk_reg.N_INT2_TOTAL_CYCLES),
        .dest_clk(sys_clk),
        .src_clk(bus_clk)
    );
    `else
    logic [N_SYNC_STAGES-1:0] sync_to_sys_clk_N_INT2_TOTAL_CYCLES [(N_SYNC_STAGES-1):0];
    genvar i;
    for (i = 0; i < N_SYNC_STAGES; i++) begin
        always_ff @(posedge sys_clk) begin
            if (i == 0)
                sync_to_sys_clk_N_INT2_TOTAL_CYCLES[i] <= bus_clk_reg.N_INT2_TOTAL_CYCLES;
            else
                sync_to_sys_clk_N_INT2_TOTAL_CYCLES[i] <= sync_to_sys_clk_N_INT2_TOTAL_CYCLES[i - 1];
        end
    end
    assign sys_clk_reg.N_INT2_TOTAL_CYCLES = sync_to_sys_clk_N_INT2_TOTAL_CYCLES[N_SYNC_STAGES - 1];
    `endif

    `ifdef VIVADO
    xpm_cdc_array_single #(
        .DEST_SYNC_FF(N_SYNC_STAGES),
        .WIDTH(16),
        .SRC_INPUT_REG(0)
    ) cdc_sync_to_sys_clk_N_INT2_ACTIVE_CYCLES (
        .src_in  (bus_clk_reg.N_INT2_ACTIVE_CYCLES),
        .dest_out(sys_clk_reg.N_INT2_ACTIVE_CYCLES),
        .dest_clk(sys_clk),
        .src_clk(bus_clk)
    );
    `else
    logic [N_SYNC_STAGES-1:0] sync_to_sys_clk_N_INT2_ACTIVE_CYCLES [(N_SYNC_STAGES-1):0];
    genvar i;
    for (i = 0; i < N_SYNC_STAGES; i++) begin
        always_ff @(posedge sys_clk) begin
            if (i == 0)
                sync_to_sys_clk_N_INT2_ACTIVE_CYCLES[i] <= bus_clk_reg.N_INT2_ACTIVE_CYCLES;
            else
                sync_to_sys_clk_N_INT2_ACTIVE_CYCLES[i] <= sync_to_sys_clk_N_INT2_ACTIVE_CYCLES[i - 1];
        end
    end
    assign sys_clk_reg.N_INT2_ACTIVE_CYCLES = sync_to_sys_clk_N_INT2_ACTIVE_CYCLES[N_SYNC_STAGES - 1];
    `endif

    `ifdef VIVADO
    xpm_cdc_array_single #(
        .DEST_SYNC_FF(N_SYNC_STAGES),
        .WIDTH(1),
        .SRC_INPUT_REG(0)
    ) cdc_sync_to_sys_clk_START_CONVERSION (
        .src_in  (bus_clk_reg.START_CONVERSION),
        .dest_out(sys_clk_reg.START_CONVERSION),
        .dest_clk(sys_clk),
        .src_clk(bus_clk)
    );
    `else
    logic       sync_to_sys_clk_START_CONVERSION [(N_SYNC_STAGES-1):0];
    genvar i;
    for (i = 0; i < N_SYNC_STAGES; i++) begin
        always_ff @(posedge sys_clk) begin
            if (i == 0)
                sync_to_sys_clk_START_CONVERSION[i] <= bus_clk_reg.START_CONVERSION;
            else
                sync_to_sys_clk_START_CONVERSION[i] <= sync_to_sys_clk_START_CONVERSION[i - 1];
        end
    end
    assign sys_clk_reg.START_CONVERSION = sync_to_sys_clk_START_CONVERSION[N_SYNC_STAGES - 1];
    `endif

    `ifdef VIVADO
    xpm_cdc_array_single #(
        .DEST_SYNC_FF(N_SYNC_STAGES),
        .WIDTH(7),
        .SRC_INPUT_REG(0)
    ) cdc_sync_to_sys_clk_CLKGEN_DRP_DADDR (
        .src_in  (bus_clk_reg.CLKGEN_DRP_DADDR),
        .dest_out(sys_clk_reg.CLKGEN_DRP_DADDR),
        .dest_clk(sys_clk),
        .src_clk(bus_clk)
    );
    `else
    logic [N_SYNC_STAGES-1:0] sync_to_sys_clk_CLKGEN_DRP_DADDR [(N_SYNC_STAGES-1):0];
    genvar i;
    for (i = 0; i < N_SYNC_STAGES; i++) begin
        always_ff @(posedge sys_clk) begin
            if (i == 0)
                sync_to_sys_clk_CLKGEN_DRP_DADDR[i] <= bus_clk_reg.CLKGEN_DRP_DADDR;
            else
                sync_to_sys_clk_CLKGEN_DRP_DADDR[i] <= sync_to_sys_clk_CLKGEN_DRP_DADDR[i - 1];
        end
    end
    assign sys_clk_reg.CLKGEN_DRP_DADDR = sync_to_sys_clk_CLKGEN_DRP_DADDR[N_SYNC_STAGES - 1];
    `endif

    `ifdef VIVADO
    xpm_cdc_array_single #(
        .DEST_SYNC_FF(N_SYNC_STAGES),
        .WIDTH(16),
        .SRC_INPUT_REG(0)
    ) cdc_sync_to_sys_clk_CLKGEN_DRP_DI (
        .src_in  (bus_clk_reg.CLKGEN_DRP_DI),
        .dest_out(sys_clk_reg.CLKGEN_DRP_DI),
        .dest_clk(sys_clk),
        .src_clk(bus_clk)
    );
    `else
    logic [N_SYNC_STAGES-1:0] sync_to_sys_clk_CLKGEN_DRP_DI [(N_SYNC_STAGES-1):0];
    genvar i;
    for (i = 0; i < N_SYNC_STAGES; i++) begin
        always_ff @(posedge sys_clk) begin
            if (i == 0)
                sync_to_sys_clk_CLKGEN_DRP_DI[i] <= bus_clk_reg.CLKGEN_DRP_DI;
            else
                sync_to_sys_clk_CLKGEN_DRP_DI[i] <= sync_to_sys_clk_CLKGEN_DRP_DI[i - 1];
        end
    end
    assign sys_clk_reg.CLKGEN_DRP_DI = sync_to_sys_clk_CLKGEN_DRP_DI[N_SYNC_STAGES - 1];
    `endif

    `ifdef VIVADO
    xpm_cdc_array_single #(
        .DEST_SYNC_FF(N_SYNC_STAGES),
        .WIDTH(1),
        .SRC_INPUT_REG(0)
    ) cdc_sync_to_sys_clk_CLKGEN_DRP_RD_EN (
        .src_in  (bus_clk_reg.CLKGEN_DRP_RD_EN),
        .dest_out(sys_clk_reg.CLKGEN_DRP_RD_EN),
        .dest_clk(sys_clk),
        .src_clk(bus_clk)
    );
    `else
    logic       sync_to_sys_clk_CLKGEN_DRP_RD_EN [(N_SYNC_STAGES-1):0];
    genvar i;
    for (i = 0; i < N_SYNC_STAGES; i++) begin
        always_ff @(posedge sys_clk) begin
            if (i == 0)
                sync_to_sys_clk_CLKGEN_DRP_RD_EN[i] <= bus_clk_reg.CLKGEN_DRP_RD_EN;
            else
                sync_to_sys_clk_CLKGEN_DRP_RD_EN[i] <= sync_to_sys_clk_CLKGEN_DRP_RD_EN[i - 1];
        end
    end
    assign sys_clk_reg.CLKGEN_DRP_RD_EN = sync_to_sys_clk_CLKGEN_DRP_RD_EN[N_SYNC_STAGES - 1];
    `endif

    `ifdef VIVADO
    xpm_cdc_array_single #(
        .DEST_SYNC_FF(N_SYNC_STAGES),
        .WIDTH(1),
        .SRC_INPUT_REG(0)
    ) cdc_sync_to_sys_clk_CLKGEN_DRP_WR_EN (
        .src_in  (bus_clk_reg.CLKGEN_DRP_WR_EN),
        .dest_out(sys_clk_reg.CLKGEN_DRP_WR_EN),
        .dest_clk(sys_clk),
        .src_clk(bus_clk)
    );
    `else
    logic       sync_to_sys_clk_CLKGEN_DRP_WR_EN [(N_SYNC_STAGES-1):0];
    genvar i;
    for (i = 0; i < N_SYNC_STAGES; i++) begin
        always_ff @(posedge sys_clk) begin
            if (i == 0)
                sync_to_sys_clk_CLKGEN_DRP_WR_EN[i] <= bus_clk_reg.CLKGEN_DRP_WR_EN;
            else
                sync_to_sys_clk_CLKGEN_DRP_WR_EN[i] <= sync_to_sys_clk_CLKGEN_DRP_WR_EN[i - 1];
        end
    end
    assign sys_clk_reg.CLKGEN_DRP_WR_EN = sync_to_sys_clk_CLKGEN_DRP_WR_EN[N_SYNC_STAGES - 1];
    `endif

    `ifdef VIVADO
    xpm_cdc_array_single #(
        .DEST_SYNC_FF(N_SYNC_STAGES),
        .WIDTH(1),
        .SRC_INPUT_REG(0)
    ) cdc_sync_to_sys_clk_CLKGEN_DRP_DEN (
        .src_in  (bus_clk_reg.CLKGEN_DRP_DEN),
        .dest_out(sys_clk_reg.CLKGEN_DRP_DEN),
        .dest_clk(sys_clk),
        .src_clk(bus_clk)
    );
    `else
    logic       sync_to_sys_clk_CLKGEN_DRP_DEN [(N_SYNC_STAGES-1):0];
    genvar i;
    for (i = 0; i < N_SYNC_STAGES; i++) begin
        always_ff @(posedge sys_clk) begin
            if (i == 0)
                sync_to_sys_clk_CLKGEN_DRP_DEN[i] <= bus_clk_reg.CLKGEN_DRP_DEN;
            else
                sync_to_sys_clk_CLKGEN_DRP_DEN[i] <= sync_to_sys_clk_CLKGEN_DRP_DEN[i - 1];
        end
    end
    assign sys_clk_reg.CLKGEN_DRP_DEN = sync_to_sys_clk_CLKGEN_DRP_DEN[N_SYNC_STAGES - 1];
    `endif

endmodule
/**
Alex Knowlton
5/3/2025

Defines a memory with a single R/W port on clock A and a second read port on
clock B, with synchronous read on the next cycle. No reset, but reads out X
if has not been written.

Port A has write-before-read capability, so keeping address the same will
read out the value written on the previous clock cycle, if any
*/
`ifndef VIVADO
`define NON_IP_MEM
`endif

module data_mem #(
    parameter ADDR_WIDTH=15,
    parameter DATA_WIDTH=16
) (
    input logic clka,
    input logic [ADDR_WIDTH-1:0] addr_a,
    input logic [DATA_WIDTH-1:0] wr_data_a,
    output logic [DATA_WIDTH-1:0] rd_data_a,
    input logic wr_enable_a,

    input logic clkb,
    input logic [ADDR_WIDTH-1:0] addr_b,
    output logic [DATA_WIDTH-1:0] rd_data_b
);

    `ifdef VIVADO
    mem_xip data_mem (
        .addra(addr_a),
        .dina(wr_data_a),
        .clka,
        .wea(wr_enable_a),

        .addrb(addr_b),
        .clkb,
        .doutb(rd_data_b)
    );
    assign rd_data_a = { DATA_WIDTH { 1'b0 } };
    `else
    localparam MEM_DEPTH = 1 << ADDR_WIDTH;
    logic [DATA_WIDTH-1:0] mem [MEM_DEPTH-1:0];

    always_ff @(posedge clka) begin
        if (wr_enable_a) begin
            mem[addr_a] <= wr_data_a;
            rd_data_a <= wr_data_a; // write-before-read
        end else begin
            rd_data_a <= mem[addr_a];
        end
    end

    always_ff @(posedge clkb)
        rd_data_b <= mem[addr_b];
    `endif

endmodulemodule dig_core #(
    parameter N_SAR_BITS = 3,
    parameter N_SYNC_STAGES = 3
) (
    // clkgen pins
    input logic i_sysclk,
    input logic i_sysrst_b,
    
    // analog boundary pins
    input logic i_sar_compare,
    output logic [(2<<N_SAR_BITS)-1:0] o_caps_to_vin,
    output logic [(2<<N_SAR_BITS)-1:0] o_caps_to_vcm,
    output logic [(2<<N_SAR_BITS)-1:0] o_caps_to_vdd,
    output logic [(2<<N_SAR_BITS)-1:0] o_caps_to_vss,
    output logic o_integrator_1,
    output logic o_integrator_2,
    output logic o_sample,
    // TODO: connect bottom plates
    // TODO: connect analog boundary pins to status interface for verification in the scoreboard
    
    // SPI IO pins
    input logic i_cs_b,
    input logic i_scl,
    input logic i_mosi,
    output logic o_miso
);

    localparam DATA_WIDTH = 16;
    localparam ADDR_WIDTH = 15;

    // system signals from clock gen and reset IP
    logic pll_clk;
    logic pll_is_locked;
    logic sys_rst_b;
    logic sys_rst;

    // bus interface registers
    logic [DATA_WIDTH-1:0] reg_wr_data;
    logic [DATA_WIDTH-1:0] reg_rd_data;
    logic [ADDR_WIDTH-1:0] reg_addr;
    logic                  reg_rd_en;
    logic                  reg_wr_en;
    logic [DATA_WIDTH-1:0] mem_rd_data;
    logic [DATA_WIDTH-1:0] spi_rd_data;
    
    reg_if                 i_reg_if_spi_clk ();
    reg_if                 i_reg_if_sys_clk ();

    spi #(
        .ADDR_WIDTH(ADDR_WIDTH),
        .DATA_WIDTH(DATA_WIDTH)
    ) i_spi (
        .scl(i_scl),
        .mosi(i_mosi),
        .miso(o_miso),
        .cs_b(i_cs_b || (!sys_rst_b)), // hold SPI in reset if the device is in reset

        .reg_wr_data,
        .reg_rd_data,
        .reg_addr,
        .reg_rd_en,
        .reg_wr_en
    );

    data_mem i_adc_mem (
        .clkb(i_scl),
        .addr_b(reg_addr),
        .rd_data_b(mem_rd_data)
    );

    registers i_registers (
        .i0(i_reg_if_spi_clk),
        .clk(i_scl),
        .rst_b(sys_rst_b), // connect to system reset, not anything from SPI
        .bus_if_wr_addr(reg_addr),
        .bus_if_wr_data(reg_wr_data),
        .bus_if_wr_en(reg_wr_en),
        .bus_if_rd_addr(reg_addr),
        .bus_if_rd_data(reg_rd_data),
        .bus_if_rd_en(reg_rd_en)
    );

    main_state_machine #(
        .N_SAR_BITS(N_SAR_BITS)
    ) i_main_state_machine (
        .rd(i_reg_if_sys_clk),
        .i_clk(pll_clk),
        .i_rst_b(sys_rst_b),
        .i_start(!i_reg_if_sys_clk.START_CONVERSION),
        .o_main_state(i_reg_if_sys_clk.MAIN_STATE_RB),
        .o_sample(o_sample),
        .o_int1(o_integrator_1),
        .o_int2(o_integrator_2)
    );

    cdc_sync #(
        .N_SYNC_STAGES(N_SYNC_STAGES)
    ) i_cdc_sync (
        .bus_clk_reg(i_reg_if_spi_clk.WR_BUS_CLK),
        .sys_clk_reg(i_reg_if_sys_clk.WR_SYS_CLK),
        .sys_clk(pll_clk),
        .bus_clk(i_scl)
    );

    assign spi_rd_data = reg_addr[ADDR_WIDTH-1] ? mem_rd_data : reg_rd_data;

    clk_gen_xip i_clk_gen (
        .reset(sys_rst),
        .clk_in1(i_sysclk),
        .clk_out1(pll_clk),
        .locked(pll_is_locked),
        .daddr(i_reg_if_sys_clk.CLKGEN_DRP_DADDR),
        .dwe(i_reg_if_sys_clk.CLKGEN_DRP_WR_EN),
        .den(i_reg_if_sys_clk.CLKGEN_DRP_DEN),
        .din(i_reg_if_sys_clk.CLKGEN_DRP_DI),
        .dout(i_reg_if_sys_clk.CLKGEN_DRP_DO)
    );

    reset_gen_xip i_reset_gen (
        .slowest_sync_clk(i_sysclk),
        .ext_reset_in(i_sysrst_b),

        .dcm_locked(1'b1),
        .aux_reset_in(1'b1),
        .mb_debug_sys_rst(1'b0),

        .peripheral_reset(sys_rst)
    );

    assign sys_rst_b = (!sys_rst) && pll_is_locked;

    
    assign i_reg_if_sys_clk.START_CONVERSION_set = (i_reg_if_sys_clk.MAIN_STATE_RB == 3'h5);

    // RO registers, sys_clk -> bus_clk
    `ifdef VIVADO
    xpm_cdc_array_single #(
        .DEST_SYNC_FF(N_SYNC_STAGES),
        .WIDTH(1),
        .SRC_INPUT_REG(0)
    ) cdc_sync_to_bus_clk_START_CONVERSION_set (
        .src_in  (i_reg_if_sys_clk.START_CONVERSION_set),
        .dest_out(i_reg_if_spi_clk.START_CONVERSION_set),
        .dest_clk(i_scl),
        .src_clk(pll_clk)
    );
    `else
    logic [N_SYNC_STAGES-1:0] sync_to_bus_clk_START_CONVERSION_set [(N_SYNC_STAGES-1):0];
    genvar i;
    for (i = 0; i < N_SYNC_STAGES; i++) begin
        always_ff @(posedge i_scl) begin
            if (i == 0)
                sync_to_bus_clk_START_CONVERSION_set[i] <= sys_clk_reg.START_CONVERSION_set;
            else
                sync_to_bus_clk_START_CONVERSION_set[i] <= sync_to_bus_clk_START_CONVERSION_set[i - 1];
        end
    end
    assign bus_clk_reg.START_CONVERSION_set = sync_to_bus_clk_START_CONVERSION_set[N_SYNC_STAGES - 1];
    `endif

endmodule{
  "schema": "xilinx.com:schema:json_instance:1.0",
  "ip_inst": {
    "xci_name": "clk_gen_xip",
    "component_reference": "xilinx.com:ip:clk_wiz:6.0",
    "ip_revision": "15",
    "gen_directory": "../../../../hdl_design.gen/sources_1/ip/clk_gen_xip",
    "parameters": {
      "component_parameters": {
        "Component_Name": [ { "value": "clk_gen_xip", "resolve_type": "user", "usage": "all" } ],
        "USER_CLK_FREQ0": [ { "value": "100.0", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "USER_CLK_FREQ1": [ { "value": "100.0", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "USER_CLK_FREQ2": [ { "value": "100.0", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "USER_CLK_FREQ3": [ { "value": "100.0", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "ENABLE_CLOCK_MONITOR": [ { "value": "false", "value_src": "user", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "OPTIMIZE_CLOCKING_STRUCTURE_EN": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "ENABLE_USER_CLOCK0": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "ENABLE_USER_CLOCK1": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "ENABLE_USER_CLOCK2": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "ENABLE_USER_CLOCK3": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "Enable_PLL0": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "Enable_PLL1": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "REF_CLK_FREQ": [ { "value": "100.0", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "PRECISION": [ { "value": "1", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "PRIMITIVE": [ { "value": "PLL", "value_src": "user", "resolve_type": "user", "usage": "all" } ],
        "PRIMTYPE_SEL": [ { "value": "mmcm_adv", "resolve_type": "user", "usage": "all" } ],
        "CLOCK_MGR_TYPE": [ { "value": "auto", "resolve_type": "user", "usage": "all" } ],
        "USE_FREQ_SYNTH": [ { "value": "true", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "USE_SPREAD_SPECTRUM": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "USE_PHASE_ALIGNMENT": [ { "value": "false", "value_src": "user", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "USE_MIN_POWER": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "USE_DYN_PHASE_SHIFT": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "USE_DYN_RECONFIG": [ { "value": "true", "value_src": "user", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "JITTER_SEL": [ { "value": "No_Jitter", "resolve_type": "user", "usage": "all" } ],
        "PRIM_IN_FREQ": [ { "value": "24", "value_src": "user", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "PRIM_IN_TIMEPERIOD": [ { "value": "10.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "IN_FREQ_UNITS": [ { "value": "Units_MHz", "resolve_type": "user", "usage": "all" } ],
        "PHASESHIFT_MODE": [ { "value": "WAVEFORM", "resolve_type": "user", "usage": "all" } ],
        "IN_JITTER_UNITS": [ { "value": "Units_UI", "resolve_type": "user", "usage": "all" } ],
        "RELATIVE_INCLK": [ { "value": "REL_PRIMARY", "resolve_type": "user", "usage": "all" } ],
        "USE_INCLK_SWITCHOVER": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "SECONDARY_IN_FREQ": [ { "value": "100.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "SECONDARY_IN_TIMEPERIOD": [ { "value": "10.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "SECONDARY_PORT": [ { "value": "clk_in2", "resolve_type": "user", "usage": "all" } ],
        "SECONDARY_SOURCE": [ { "value": "Single_ended_clock_capable_pin", "value_src": "user", "resolve_type": "user", "usage": "all" } ],
        "JITTER_OPTIONS": [ { "value": "UI", "resolve_type": "user", "usage": "all" } ],
        "CLKIN1_UI_JITTER": [ { "value": "0.010", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKIN2_UI_JITTER": [ { "value": "0.010", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "PRIM_IN_JITTER": [ { "value": "0.010", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "SECONDARY_IN_JITTER": [ { "value": "0.010", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKIN1_JITTER_PS": [ { "value": "416.65999999999997", "value_src": "user", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKIN2_JITTER_PS": [ { "value": "100.0", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT1_USED": [ { "value": "true", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "CLKOUT2_USED": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "CLKOUT3_USED": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "CLKOUT4_USED": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "CLKOUT5_USED": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "CLKOUT6_USED": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "CLKOUT7_USED": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "NUM_OUT_CLKS": [ { "value": "1", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "CLK_OUT1_USE_FINE_PS_GUI": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "CLK_OUT2_USE_FINE_PS_GUI": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "CLK_OUT3_USE_FINE_PS_GUI": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "CLK_OUT4_USE_FINE_PS_GUI": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "CLK_OUT5_USE_FINE_PS_GUI": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "CLK_OUT6_USE_FINE_PS_GUI": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "CLK_OUT7_USE_FINE_PS_GUI": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "PRIMARY_PORT": [ { "value": "clk_in1", "resolve_type": "user", "usage": "all" } ],
        "CLK_OUT1_PORT": [ { "value": "clk_out1", "resolve_type": "user", "usage": "all" } ],
        "CLK_OUT2_PORT": [ { "value": "clk_out2", "resolve_type": "user", "usage": "all" } ],
        "CLK_OUT3_PORT": [ { "value": "clk_out3", "resolve_type": "user", "usage": "all" } ],
        "CLK_OUT4_PORT": [ { "value": "clk_out4", "resolve_type": "user", "usage": "all" } ],
        "CLK_OUT5_PORT": [ { "value": "clk_out5", "resolve_type": "user", "usage": "all" } ],
        "CLK_OUT6_PORT": [ { "value": "clk_out6", "resolve_type": "user", "usage": "all" } ],
        "CLK_OUT7_PORT": [ { "value": "clk_out7", "resolve_type": "user", "usage": "all" } ],
        "DADDR_PORT": [ { "value": "daddr", "resolve_type": "user", "usage": "all" } ],
        "DCLK_PORT": [ { "value": "dclk", "resolve_type": "user", "usage": "all" } ],
        "DRDY_PORT": [ { "value": "drdy", "resolve_type": "user", "usage": "all" } ],
        "DWE_PORT": [ { "value": "dwe", "resolve_type": "user", "usage": "all" } ],
        "DIN_PORT": [ { "value": "din", "resolve_type": "user", "usage": "all" } ],
        "DOUT_PORT": [ { "value": "dout", "resolve_type": "user", "usage": "all" } ],
        "DEN_PORT": [ { "value": "den", "resolve_type": "user", "usage": "all" } ],
        "PSCLK_PORT": [ { "value": "psclk", "resolve_type": "user", "usage": "all" } ],
        "PSEN_PORT": [ { "value": "psen", "resolve_type": "user", "usage": "all" } ],
        "PSINCDEC_PORT": [ { "value": "psincdec", "resolve_type": "user", "usage": "all" } ],
        "PSDONE_PORT": [ { "value": "psdone", "resolve_type": "user", "usage": "all" } ],
        "CLKOUT1_REQUESTED_OUT_FREQ": [ { "value": "100.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT1_REQUESTED_PHASE": [ { "value": "0.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT1_REQUESTED_DUTY_CYCLE": [ { "value": "50.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT2_REQUESTED_OUT_FREQ": [ { "value": "100.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT2_REQUESTED_PHASE": [ { "value": "0.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT2_REQUESTED_DUTY_CYCLE": [ { "value": "50.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT3_REQUESTED_OUT_FREQ": [ { "value": "100.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT3_REQUESTED_PHASE": [ { "value": "0.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT3_REQUESTED_DUTY_CYCLE": [ { "value": "50.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT4_REQUESTED_OUT_FREQ": [ { "value": "100.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT4_REQUESTED_PHASE": [ { "value": "0.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT4_REQUESTED_DUTY_CYCLE": [ { "value": "50.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT5_REQUESTED_OUT_FREQ": [ { "value": "100.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT5_REQUESTED_PHASE": [ { "value": "0.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT5_REQUESTED_DUTY_CYCLE": [ { "value": "50.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT6_REQUESTED_OUT_FREQ": [ { "value": "100.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT6_REQUESTED_PHASE": [ { "value": "0.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT6_REQUESTED_DUTY_CYCLE": [ { "value": "50.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT7_REQUESTED_OUT_FREQ": [ { "value": "100.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT7_REQUESTED_PHASE": [ { "value": "0.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT7_REQUESTED_DUTY_CYCLE": [ { "value": "50.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "USE_MAX_I_JITTER": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "USE_MIN_O_JITTER": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "CLKOUT1_MATCHED_ROUTING": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "CLKOUT2_MATCHED_ROUTING": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "CLKOUT3_MATCHED_ROUTING": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "CLKOUT4_MATCHED_ROUTING": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "CLKOUT5_MATCHED_ROUTING": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "CLKOUT6_MATCHED_ROUTING": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "CLKOUT7_MATCHED_ROUTING": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "PRIM_SOURCE": [ { "value": "Single_ended_clock_capable_pin", "value_src": "user", "resolve_type": "user", "usage": "all" } ],
        "CLKOUT1_DRIVES": [ { "value": "BUFG", "value_src": "user", "resolve_type": "user", "usage": "all" } ],
        "CLKOUT2_DRIVES": [ { "value": "BUFG", "value_src": "user", "resolve_type": "user", "usage": "all" } ],
        "CLKOUT3_DRIVES": [ { "value": "BUFG", "value_src": "user", "resolve_type": "user", "usage": "all" } ],
        "CLKOUT4_DRIVES": [ { "value": "BUFG", "value_src": "user", "resolve_type": "user", "usage": "all" } ],
        "CLKOUT5_DRIVES": [ { "value": "BUFG", "value_src": "user", "resolve_type": "user", "usage": "all" } ],
        "CLKOUT6_DRIVES": [ { "value": "BUFG", "value_src": "user", "resolve_type": "user", "usage": "all" } ],
        "CLKOUT7_DRIVES": [ { "value": "BUFG", "value_src": "user", "resolve_type": "user", "usage": "all" } ],
        "FEEDBACK_SOURCE": [ { "value": "FDBK_AUTO", "resolve_type": "user", "usage": "all" } ],
        "CLKFB_IN_SIGNALING": [ { "value": "SINGLE", "resolve_type": "user", "usage": "all" } ],
        "CLKFB_IN_PORT": [ { "value": "clkfb_in", "resolve_type": "user", "usage": "all" } ],
        "CLKFB_IN_P_PORT": [ { "value": "clkfb_in_p", "resolve_type": "user", "usage": "all" } ],
        "CLKFB_IN_N_PORT": [ { "value": "clkfb_in_n", "resolve_type": "user", "usage": "all" } ],
        "CLKFB_OUT_PORT": [ { "value": "clkfb_out", "resolve_type": "user", "usage": "all" } ],
        "CLKFB_OUT_P_PORT": [ { "value": "clkfb_out_p", "resolve_type": "user", "usage": "all" } ],
        "CLKFB_OUT_N_PORT": [ { "value": "clkfb_out_n", "resolve_type": "user", "usage": "all" } ],
        "PLATFORM": [ { "value": "UNKNOWN", "resolve_type": "user", "usage": "all" } ],
        "SUMMARY_STRINGS": [ { "value": "empty", "resolve_type": "user", "usage": "all" } ],
        "USE_LOCKED": [ { "value": "true", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "CALC_DONE": [ { "value": "empty", "resolve_type": "user", "usage": "all" } ],
        "USE_RESET": [ { "value": "true", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "USE_POWER_DOWN": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "USE_STATUS": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "USE_FREEZE": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "USE_CLK_VALID": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "USE_INCLK_STOPPED": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "USE_CLKFB_STOPPED": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "RESET_PORT": [ { "value": "reset", "resolve_type": "user", "usage": "all" } ],
        "LOCKED_PORT": [ { "value": "locked", "resolve_type": "user", "usage": "all" } ],
        "POWER_DOWN_PORT": [ { "value": "power_down", "resolve_type": "user", "usage": "all" } ],
        "CLK_VALID_PORT": [ { "value": "CLK_VALID", "resolve_type": "user", "usage": "all" } ],
        "STATUS_PORT": [ { "value": "STATUS", "resolve_type": "user", "usage": "all" } ],
        "CLK_IN_SEL_PORT": [ { "value": "clk_in_sel", "resolve_type": "user", "usage": "all" } ],
        "INPUT_CLK_STOPPED_PORT": [ { "value": "input_clk_stopped", "resolve_type": "user", "usage": "all" } ],
        "CLKFB_STOPPED_PORT": [ { "value": "clkfb_stopped", "resolve_type": "user", "usage": "all" } ],
        "SS_MODE": [ { "value": "CENTER_HIGH", "resolve_type": "user", "usage": "all" } ],
        "SS_MOD_FREQ": [ { "value": "250", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "SS_MOD_TIME": [ { "value": "0.004", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "OVERRIDE_MMCM": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "MMCM_NOTES": [ { "value": "None", "resolve_type": "user", "usage": "all" } ],
        "MMCM_DIVCLK_DIVIDE": [ { "value": "1", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "MMCM_BANDWIDTH": [ { "value": "OPTIMIZED", "value_src": "user", "resolve_type": "user", "usage": "all" } ],
        "MMCM_CLKFBOUT_MULT_F": [ { "value": "50", "value_src": "user", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "MMCM_CLKFBOUT_PHASE": [ { "value": "0.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "MMCM_CLKFBOUT_USE_FINE_PS": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "MMCM_CLKIN1_PERIOD": [ { "value": "41.667", "value_src": "user", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "MMCM_CLKIN2_PERIOD": [ { "value": "10.0", "value_src": "user", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "MMCM_CLKOUT4_CASCADE": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "MMCM_CLOCK_HOLD": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "MMCM_COMPENSATION": [ { "value": "ZHOLD", "value_src": "user", "resolve_type": "user", "usage": "all" } ],
        "MMCM_REF_JITTER1": [ { "value": "0.010", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "MMCM_REF_JITTER2": [ { "value": "0.010", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "MMCM_STARTUP_WAIT": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "MMCM_CLKOUT0_DIVIDE_F": [ { "value": "12", "value_src": "user", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "MMCM_CLKOUT0_DUTY_CYCLE": [ { "value": "0.500", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "MMCM_CLKOUT0_PHASE": [ { "value": "0.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "MMCM_CLKOUT0_USE_FINE_PS": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "MMCM_CLKOUT1_DIVIDE": [ { "value": "1", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "MMCM_CLKOUT1_DUTY_CYCLE": [ { "value": "0.500", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "MMCM_CLKOUT1_PHASE": [ { "value": "0.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "MMCM_CLKOUT1_USE_FINE_PS": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "MMCM_CLKOUT2_DIVIDE": [ { "value": "1", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "MMCM_CLKOUT2_DUTY_CYCLE": [ { "value": "0.500", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "MMCM_CLKOUT2_PHASE": [ { "value": "0.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "MMCM_CLKOUT2_USE_FINE_PS": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "MMCM_CLKOUT3_DIVIDE": [ { "value": "1", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "MMCM_CLKOUT3_DUTY_CYCLE": [ { "value": "0.500", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "MMCM_CLKOUT3_PHASE": [ { "value": "0.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "MMCM_CLKOUT3_USE_FINE_PS": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "MMCM_CLKOUT4_DIVIDE": [ { "value": "1", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "MMCM_CLKOUT4_DUTY_CYCLE": [ { "value": "0.500", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "MMCM_CLKOUT4_PHASE": [ { "value": "0.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "MMCM_CLKOUT4_USE_FINE_PS": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "MMCM_CLKOUT5_DIVIDE": [ { "value": "1", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "MMCM_CLKOUT5_DUTY_CYCLE": [ { "value": "0.500", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "MMCM_CLKOUT5_PHASE": [ { "value": "0.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "MMCM_CLKOUT5_USE_FINE_PS": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "MMCM_CLKOUT6_DIVIDE": [ { "value": "1", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "MMCM_CLKOUT6_DUTY_CYCLE": [ { "value": "0.500", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "MMCM_CLKOUT6_PHASE": [ { "value": "0.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "MMCM_CLKOUT6_USE_FINE_PS": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "OVERRIDE_PLL": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "PLL_NOTES": [ { "value": "None", "resolve_type": "user", "usage": "all" } ],
        "PLL_BANDWIDTH": [ { "value": "OPTIMIZED", "resolve_type": "user", "usage": "all" } ],
        "PLL_CLKFBOUT_MULT": [ { "value": "4", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "PLL_CLKFBOUT_PHASE": [ { "value": "0.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "PLL_CLK_FEEDBACK": [ { "value": "CLKFBOUT", "resolve_type": "user", "usage": "all" } ],
        "PLL_DIVCLK_DIVIDE": [ { "value": "1", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "PLL_CLKIN_PERIOD": [ { "value": "41.666", "value_src": "user", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "PLL_COMPENSATION": [ { "value": "SYSTEM_SYNCHRONOUS", "resolve_type": "user", "usage": "all" } ],
        "PLL_REF_JITTER": [ { "value": "0.010", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "PLL_CLKOUT0_DIVIDE": [ { "value": "1", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "PLL_CLKOUT0_DUTY_CYCLE": [ { "value": "0.500", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "PLL_CLKOUT0_PHASE": [ { "value": "0.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "PLL_CLKOUT1_DIVIDE": [ { "value": "1", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "PLL_CLKOUT1_DUTY_CYCLE": [ { "value": "0.500", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "PLL_CLKOUT1_PHASE": [ { "value": "0.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "PLL_CLKOUT2_DIVIDE": [ { "value": "1", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "PLL_CLKOUT2_DUTY_CYCLE": [ { "value": "0.500", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "PLL_CLKOUT2_PHASE": [ { "value": "0.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "PLL_CLKOUT3_DIVIDE": [ { "value": "1", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "PLL_CLKOUT3_DUTY_CYCLE": [ { "value": "0.500", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "PLL_CLKOUT3_PHASE": [ { "value": "0.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "PLL_CLKOUT4_DIVIDE": [ { "value": "1", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "PLL_CLKOUT4_DUTY_CYCLE": [ { "value": "0.500", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "PLL_CLKOUT4_PHASE": [ { "value": "0.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "PLL_CLKOUT5_DIVIDE": [ { "value": "1", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "PLL_CLKOUT5_DUTY_CYCLE": [ { "value": "0.500", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "PLL_CLKOUT5_PHASE": [ { "value": "0.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "RESET_TYPE": [ { "value": "ACTIVE_HIGH", "resolve_type": "user", "usage": "all" } ],
        "USE_SAFE_CLOCK_STARTUP": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "USE_CLOCK_SEQUENCING": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "CLKOUT1_SEQUENCE_NUMBER": [ { "value": "1", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "CLKOUT2_SEQUENCE_NUMBER": [ { "value": "1", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "CLKOUT3_SEQUENCE_NUMBER": [ { "value": "1", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "CLKOUT4_SEQUENCE_NUMBER": [ { "value": "1", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "CLKOUT5_SEQUENCE_NUMBER": [ { "value": "1", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "CLKOUT6_SEQUENCE_NUMBER": [ { "value": "1", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "CLKOUT7_SEQUENCE_NUMBER": [ { "value": "1", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "USE_BOARD_FLOW": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "CLK_IN1_BOARD_INTERFACE": [ { "value": "Custom", "resolve_type": "user", "usage": "all" } ],
        "CLK_IN2_BOARD_INTERFACE": [ { "value": "Custom", "resolve_type": "user", "usage": "all" } ],
        "DIFF_CLK_IN1_BOARD_INTERFACE": [ { "value": "Custom", "resolve_type": "user", "usage": "all" } ],
        "DIFF_CLK_IN2_BOARD_INTERFACE": [ { "value": "Custom", "resolve_type": "user", "usage": "all" } ],
        "AUTO_PRIMITIVE": [ { "value": "MMCM", "resolve_type": "user", "usage": "all" } ],
        "RESET_BOARD_INTERFACE": [ { "value": "Custom", "resolve_type": "user", "usage": "all" } ],
        "ENABLE_CDDC": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "CDDCDONE_PORT": [ { "value": "cddcdone", "resolve_type": "user", "usage": "all" } ],
        "CDDCREQ_PORT": [ { "value": "cddcreq", "resolve_type": "user", "usage": "all" } ],
        "ENABLE_CLKOUTPHY": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "CLKOUTPHY_REQUESTED_FREQ": [ { "value": "600.000", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT1_JITTER": [ { "value": "195.038", "value_src": "user", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT1_PHASE_ERROR": [ { "value": "233.531", "value_src": "user", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT2_JITTER": [ { "value": "0.0", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT2_PHASE_ERROR": [ { "value": "0.0", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT3_JITTER": [ { "value": "0.0", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT3_PHASE_ERROR": [ { "value": "0.0", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT4_JITTER": [ { "value": "0.0", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT4_PHASE_ERROR": [ { "value": "0.0", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT5_JITTER": [ { "value": "0.0", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT5_PHASE_ERROR": [ { "value": "0.0", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT6_JITTER": [ { "value": "0.0", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT6_PHASE_ERROR": [ { "value": "0.0", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT7_JITTER": [ { "value": "0.0", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "CLKOUT7_PHASE_ERROR": [ { "value": "0.0", "resolve_type": "user", "format": "float", "usage": "all" } ],
        "INPUT_MODE": [ { "value": "frequency", "resolve_type": "user", "usage": "all" } ],
        "INTERFACE_SELECTION": [ { "value": "Enable_DRP", "value_src": "user", "resolve_type": "user", "usage": "all" } ],
        "AXI_DRP": [ { "value": "false", "value_src": "user", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "PHASE_DUTY_CONFIG": [ { "value": "false", "value_src": "user", "resolve_type": "user", "format": "bool", "usage": "all" } ]
      },
      "model_parameters": {
        "C_CLKOUT2_USED": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_USER_CLK_FREQ0": [ { "value": "100.0", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_AUTO_PRIMITIVE": [ { "value": "MMCM", "resolve_type": "generated", "usage": "all" } ],
        "C_USER_CLK_FREQ1": [ { "value": "100.0", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_USER_CLK_FREQ2": [ { "value": "100.0", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_USER_CLK_FREQ3": [ { "value": "100.0", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_ENABLE_CLOCK_MONITOR": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_ENABLE_USER_CLOCK0": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_ENABLE_USER_CLOCK1": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_ENABLE_USER_CLOCK2": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_ENABLE_USER_CLOCK3": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_Enable_PLL0": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_Enable_PLL1": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_REF_CLK_FREQ": [ { "value": "100.0", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_PRECISION": [ { "value": "1", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT3_USED": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_CLKOUT4_USED": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_CLKOUT5_USED": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_CLKOUT6_USED": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_CLKOUT7_USED": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_USE_CLKOUT1_BAR": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_USE_CLKOUT2_BAR": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_USE_CLKOUT3_BAR": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_USE_CLKOUT4_BAR": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "c_component_name": [ { "value": "clk_gen_xip", "resolve_type": "generated", "usage": "all" } ],
        "C_PLATFORM": [ { "value": "UNKNOWN", "resolve_type": "generated", "usage": "all" } ],
        "C_USE_FREQ_SYNTH": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_USE_PHASE_ALIGNMENT": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_PRIM_IN_JITTER": [ { "value": "0.010", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_SECONDARY_IN_JITTER": [ { "value": "0.010", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_JITTER_SEL": [ { "value": "No_Jitter", "resolve_type": "generated", "usage": "all" } ],
        "C_USE_MIN_POWER": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_USE_MIN_O_JITTER": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_USE_MAX_I_JITTER": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_USE_DYN_PHASE_SHIFT": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_OPTIMIZE_CLOCKING_STRUCTURE_EN": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_USE_INCLK_SWITCHOVER": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_USE_DYN_RECONFIG": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_USE_SPREAD_SPECTRUM": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_USE_FAST_SIMULATION": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_PRIMTYPE_SEL": [ { "value": "AUTO", "resolve_type": "generated", "usage": "all" } ],
        "C_USE_CLK_VALID": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_PRIM_IN_FREQ": [ { "value": "24", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_PRIM_IN_TIMEPERIOD": [ { "value": "10.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_IN_FREQ_UNITS": [ { "value": "Units_MHz", "resolve_type": "generated", "usage": "all" } ],
        "C_SECONDARY_IN_FREQ": [ { "value": "100.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_SECONDARY_IN_TIMEPERIOD": [ { "value": "10.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_FEEDBACK_SOURCE": [ { "value": "FDBK_AUTO", "resolve_type": "generated", "usage": "all" } ],
        "C_PRIM_SOURCE": [ { "value": "Single_ended_clock_capable_pin", "resolve_type": "generated", "usage": "all" } ],
        "C_PHASESHIFT_MODE": [ { "value": "WAVEFORM", "resolve_type": "generated", "usage": "all" } ],
        "C_SECONDARY_SOURCE": [ { "value": "Single_ended_clock_capable_pin", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKFB_IN_SIGNALING": [ { "value": "SINGLE", "resolve_type": "generated", "usage": "all" } ],
        "C_USE_RESET": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_RESET_LOW": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_USE_LOCKED": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_USE_INCLK_STOPPED": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_USE_CLKFB_STOPPED": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_USE_POWER_DOWN": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_USE_STATUS": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_USE_FREEZE": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_NUM_OUT_CLKS": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_CLKOUT1_DRIVES": [ { "value": "BUFG", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT2_DRIVES": [ { "value": "BUFG", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT3_DRIVES": [ { "value": "BUFG", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT4_DRIVES": [ { "value": "BUFG", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT5_DRIVES": [ { "value": "BUFG", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT6_DRIVES": [ { "value": "BUFG", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT7_DRIVES": [ { "value": "BUFG", "resolve_type": "generated", "usage": "all" } ],
        "C_INCLK_SUM_ROW0": [ { "value": "Input Clock   Freq (MHz)    Input Jitter (UI)", "resolve_type": "generated", "usage": "all" } ],
        "C_INCLK_SUM_ROW1": [ { "value": "__primary______________24____________0.010", "resolve_type": "generated", "usage": "all" } ],
        "C_INCLK_SUM_ROW2": [ { "value": "no_secondary_input_clock ", "resolve_type": "generated", "usage": "all" } ],
        "C_OUTCLK_SUM_ROW0A": [ { "value": " Output     Output      Phase    Duty Cycle   Pk-to-Pk     Phase", "resolve_type": "generated", "usage": "all" } ],
        "C_OUTCLK_SUM_ROW0B": [ { "value": "  Clock     Freq (MHz)  (degrees)    (%)     Jitter (ps)  Error (ps)", "resolve_type": "generated", "usage": "all" } ],
        "C_OUTCLK_SUM_ROW1": [ { "value": "clk_out1__100.00000______0.000______50.0______195.038____233.531", "resolve_type": "generated", "usage": "all" } ],
        "C_OUTCLK_SUM_ROW2": [ { "value": "no_CLK_OUT2_output", "resolve_type": "generated", "usage": "all" } ],
        "C_OUTCLK_SUM_ROW3": [ { "value": "no_CLK_OUT3_output", "resolve_type": "generated", "usage": "all" } ],
        "C_OUTCLK_SUM_ROW4": [ { "value": "no_CLK_OUT4_output", "resolve_type": "generated", "usage": "all" } ],
        "C_OUTCLK_SUM_ROW5": [ { "value": "no_CLK_OUT5_output", "resolve_type": "generated", "usage": "all" } ],
        "C_OUTCLK_SUM_ROW6": [ { "value": "no_CLK_OUT6_output", "resolve_type": "generated", "usage": "all" } ],
        "C_OUTCLK_SUM_ROW7": [ { "value": "no_CLK_OUT7_output", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT1_REQUESTED_OUT_FREQ": [ { "value": "100.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT2_REQUESTED_OUT_FREQ": [ { "value": "100.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT3_REQUESTED_OUT_FREQ": [ { "value": "100.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT4_REQUESTED_OUT_FREQ": [ { "value": "100.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT5_REQUESTED_OUT_FREQ": [ { "value": "100.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT6_REQUESTED_OUT_FREQ": [ { "value": "100.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT7_REQUESTED_OUT_FREQ": [ { "value": "100.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT1_REQUESTED_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT2_REQUESTED_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT3_REQUESTED_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT4_REQUESTED_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT5_REQUESTED_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT6_REQUESTED_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT7_REQUESTED_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT1_REQUESTED_DUTY_CYCLE": [ { "value": "50.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT2_REQUESTED_DUTY_CYCLE": [ { "value": "50.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT3_REQUESTED_DUTY_CYCLE": [ { "value": "50.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT4_REQUESTED_DUTY_CYCLE": [ { "value": "50.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT5_REQUESTED_DUTY_CYCLE": [ { "value": "50.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT6_REQUESTED_DUTY_CYCLE": [ { "value": "50.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT7_REQUESTED_DUTY_CYCLE": [ { "value": "50.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT1_OUT_FREQ": [ { "value": "100.00000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT2_OUT_FREQ": [ { "value": "100.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT3_OUT_FREQ": [ { "value": "100.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT4_OUT_FREQ": [ { "value": "100.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT5_OUT_FREQ": [ { "value": "100.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT6_OUT_FREQ": [ { "value": "100.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT7_OUT_FREQ": [ { "value": "100.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT1_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT2_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT3_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT4_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT5_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT6_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT7_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT1_DUTY_CYCLE": [ { "value": "50.0", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT2_DUTY_CYCLE": [ { "value": "50.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT3_DUTY_CYCLE": [ { "value": "50.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT4_DUTY_CYCLE": [ { "value": "50.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT5_DUTY_CYCLE": [ { "value": "50.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT6_DUTY_CYCLE": [ { "value": "50.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKOUT7_DUTY_CYCLE": [ { "value": "50.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_USE_SAFE_CLOCK_STARTUP": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_USE_CLOCK_SEQUENCING": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_CLKOUT1_SEQUENCE_NUMBER": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_CLKOUT2_SEQUENCE_NUMBER": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_CLKOUT3_SEQUENCE_NUMBER": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_CLKOUT4_SEQUENCE_NUMBER": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_CLKOUT5_SEQUENCE_NUMBER": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_CLKOUT6_SEQUENCE_NUMBER": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_CLKOUT7_SEQUENCE_NUMBER": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_MMCM_NOTES": [ { "value": "None", "resolve_type": "generated", "usage": "all" } ],
        "C_MMCM_BANDWIDTH": [ { "value": "OPTIMIZED", "resolve_type": "generated", "usage": "all" } ],
        "C_MMCM_CLKFBOUT_MULT_F": [ { "value": "50.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_MMCM_CLKIN1_PERIOD": [ { "value": "41.667", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_MMCM_CLKIN2_PERIOD": [ { "value": "10.0", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_MMCM_CLKOUT4_CASCADE": [ { "value": "FALSE", "resolve_type": "generated", "format": "bool", "usage": "all" } ],
        "C_MMCM_CLOCK_HOLD": [ { "value": "FALSE", "resolve_type": "generated", "format": "bool", "usage": "all" } ],
        "C_MMCM_COMPENSATION": [ { "value": "ZHOLD", "resolve_type": "generated", "usage": "all" } ],
        "C_MMCM_DIVCLK_DIVIDE": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_MMCM_REF_JITTER1": [ { "value": "0.010", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_MMCM_REF_JITTER2": [ { "value": "0.010", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_MMCM_STARTUP_WAIT": [ { "value": "FALSE", "resolve_type": "generated", "usage": "all" } ],
        "C_MMCM_CLKOUT0_DIVIDE_F": [ { "value": "12.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_MMCM_CLKOUT1_DIVIDE": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_MMCM_CLKOUT2_DIVIDE": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_MMCM_CLKOUT3_DIVIDE": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_MMCM_CLKOUT4_DIVIDE": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_MMCM_CLKOUT5_DIVIDE": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_MMCM_CLKOUT6_DIVIDE": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_MMCM_CLKOUT0_DUTY_CYCLE": [ { "value": "0.500", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_MMCM_CLKOUT1_DUTY_CYCLE": [ { "value": "0.500", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_MMCM_CLKOUT2_DUTY_CYCLE": [ { "value": "0.500", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_MMCM_CLKOUT3_DUTY_CYCLE": [ { "value": "0.500", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_MMCM_CLKOUT4_DUTY_CYCLE": [ { "value": "0.500", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_MMCM_CLKOUT5_DUTY_CYCLE": [ { "value": "0.500", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_MMCM_CLKOUT6_DUTY_CYCLE": [ { "value": "0.500", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_MMCM_CLKFBOUT_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_MMCM_CLKOUT0_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_MMCM_CLKOUT1_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_MMCM_CLKOUT2_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_MMCM_CLKOUT3_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_MMCM_CLKOUT4_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_MMCM_CLKOUT5_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_MMCM_CLKOUT6_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_MMCM_CLKFBOUT_USE_FINE_PS": [ { "value": "FALSE", "resolve_type": "generated", "usage": "all" } ],
        "C_MMCM_CLKOUT0_USE_FINE_PS": [ { "value": "FALSE", "resolve_type": "generated", "usage": "all" } ],
        "C_MMCM_CLKOUT1_USE_FINE_PS": [ { "value": "FALSE", "resolve_type": "generated", "usage": "all" } ],
        "C_MMCM_CLKOUT2_USE_FINE_PS": [ { "value": "FALSE", "resolve_type": "generated", "usage": "all" } ],
        "C_MMCM_CLKOUT3_USE_FINE_PS": [ { "value": "FALSE", "resolve_type": "generated", "usage": "all" } ],
        "C_MMCM_CLKOUT4_USE_FINE_PS": [ { "value": "FALSE", "resolve_type": "generated", "usage": "all" } ],
        "C_MMCM_CLKOUT5_USE_FINE_PS": [ { "value": "FALSE", "resolve_type": "generated", "usage": "all" } ],
        "C_MMCM_CLKOUT6_USE_FINE_PS": [ { "value": "FALSE", "resolve_type": "generated", "usage": "all" } ],
        "C_PLL_NOTES": [ { "value": "No notes", "resolve_type": "generated", "usage": "all" } ],
        "C_PLL_BANDWIDTH": [ { "value": "OPTIMIZED", "resolve_type": "generated", "usage": "all" } ],
        "C_PLL_CLK_FEEDBACK": [ { "value": "CLKFBOUT", "resolve_type": "generated", "usage": "all" } ],
        "C_PLL_CLKFBOUT_MULT": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_PLL_CLKIN_PERIOD": [ { "value": "1.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_PLL_COMPENSATION": [ { "value": "SYSTEM_SYNCHRONOUS", "resolve_type": "generated", "usage": "all" } ],
        "C_PLL_DIVCLK_DIVIDE": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_PLL_REF_JITTER": [ { "value": "0.010", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_PLL_CLKOUT0_DIVIDE": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_PLL_CLKOUT1_DIVIDE": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_PLL_CLKOUT2_DIVIDE": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_PLL_CLKOUT3_DIVIDE": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_PLL_CLKOUT4_DIVIDE": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_PLL_CLKOUT5_DIVIDE": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_PLL_CLKOUT0_DUTY_CYCLE": [ { "value": "0.500", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_PLL_CLKOUT1_DUTY_CYCLE": [ { "value": "0.500", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_PLL_CLKOUT2_DUTY_CYCLE": [ { "value": "0.500", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_PLL_CLKOUT3_DUTY_CYCLE": [ { "value": "0.500", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_PLL_CLKOUT4_DUTY_CYCLE": [ { "value": "0.500", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_PLL_CLKOUT5_DUTY_CYCLE": [ { "value": "0.500", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_PLL_CLKFBOUT_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_PLL_CLKOUT0_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_PLL_CLKOUT1_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_PLL_CLKOUT2_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_PLL_CLKOUT3_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_PLL_CLKOUT4_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_PLL_CLKOUT5_PHASE": [ { "value": "0.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLOCK_MGR_TYPE": [ { "value": "NA", "resolve_type": "generated", "usage": "all" } ],
        "C_OVERRIDE_MMCM": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_OVERRIDE_PLL": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_PRIMARY_PORT": [ { "value": "clk_in1", "resolve_type": "generated", "usage": "all" } ],
        "C_SECONDARY_PORT": [ { "value": "clk_in2", "resolve_type": "generated", "usage": "all" } ],
        "C_CLK_OUT1_PORT": [ { "value": "clk_out1", "resolve_type": "generated", "usage": "all" } ],
        "C_CLK_OUT2_PORT": [ { "value": "clk_out2", "resolve_type": "generated", "usage": "all" } ],
        "C_CLK_OUT3_PORT": [ { "value": "clk_out3", "resolve_type": "generated", "usage": "all" } ],
        "C_CLK_OUT4_PORT": [ { "value": "clk_out4", "resolve_type": "generated", "usage": "all" } ],
        "C_CLK_OUT5_PORT": [ { "value": "clk_out5", "resolve_type": "generated", "usage": "all" } ],
        "C_CLK_OUT6_PORT": [ { "value": "clk_out6", "resolve_type": "generated", "usage": "all" } ],
        "C_CLK_OUT7_PORT": [ { "value": "clk_out7", "resolve_type": "generated", "usage": "all" } ],
        "C_RESET_PORT": [ { "value": "reset", "resolve_type": "generated", "usage": "all" } ],
        "C_LOCKED_PORT": [ { "value": "locked", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKFB_IN_PORT": [ { "value": "clkfb_in", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKFB_IN_P_PORT": [ { "value": "clkfb_in_p", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKFB_IN_N_PORT": [ { "value": "clkfb_in_n", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKFB_OUT_PORT": [ { "value": "clkfb_out", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKFB_OUT_P_PORT": [ { "value": "clkfb_out_p", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKFB_OUT_N_PORT": [ { "value": "clkfb_out_n", "resolve_type": "generated", "usage": "all" } ],
        "C_POWER_DOWN_PORT": [ { "value": "power_down", "resolve_type": "generated", "usage": "all" } ],
        "C_DADDR_PORT": [ { "value": "daddr", "resolve_type": "generated", "usage": "all" } ],
        "C_DCLK_PORT": [ { "value": "dclk", "resolve_type": "generated", "usage": "all" } ],
        "C_DRDY_PORT": [ { "value": "drdy", "resolve_type": "generated", "usage": "all" } ],
        "C_DWE_PORT": [ { "value": "dwe", "resolve_type": "generated", "usage": "all" } ],
        "C_DIN_PORT": [ { "value": "din", "resolve_type": "generated", "usage": "all" } ],
        "C_DOUT_PORT": [ { "value": "dout", "resolve_type": "generated", "usage": "all" } ],
        "C_DEN_PORT": [ { "value": "den", "resolve_type": "generated", "usage": "all" } ],
        "C_PSCLK_PORT": [ { "value": "psclk", "resolve_type": "generated", "usage": "all" } ],
        "C_PSEN_PORT": [ { "value": "psen", "resolve_type": "generated", "usage": "all" } ],
        "C_PSINCDEC_PORT": [ { "value": "psincdec", "resolve_type": "generated", "usage": "all" } ],
        "C_PSDONE_PORT": [ { "value": "psdone", "resolve_type": "generated", "usage": "all" } ],
        "C_CLK_VALID_PORT": [ { "value": "CLK_VALID", "resolve_type": "generated", "usage": "all" } ],
        "C_STATUS_PORT": [ { "value": "STATUS", "resolve_type": "generated", "usage": "all" } ],
        "C_CLK_IN_SEL_PORT": [ { "value": "clk_in_sel", "resolve_type": "generated", "usage": "all" } ],
        "C_INPUT_CLK_STOPPED_PORT": [ { "value": "input_clk_stopped", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKFB_STOPPED_PORT": [ { "value": "clkfb_stopped", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKIN1_JITTER_PS": [ { "value": "416.65999999999997", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_CLKIN2_JITTER_PS": [ { "value": "100.0", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_PRIMITIVE": [ { "value": "PLL", "resolve_type": "generated", "usage": "all" } ],
        "C_SS_MODE": [ { "value": "CENTER_HIGH", "resolve_type": "generated", "usage": "all" } ],
        "C_SS_MOD_PERIOD": [ { "value": "4000", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_SS_MOD_TIME": [ { "value": "0.004", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_HAS_CDDC": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_CDDCDONE_PORT": [ { "value": "cddcdone", "resolve_type": "generated", "usage": "all" } ],
        "C_CDDCREQ_PORT": [ { "value": "cddcreq", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUTPHY_MODE": [ { "value": "VCO", "resolve_type": "generated", "usage": "all" } ],
        "C_ENABLE_CLKOUTPHY": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_INTERFACE_SELECTION": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_S_AXI_ADDR_WIDTH": [ { "value": "11", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_S_AXI_DATA_WIDTH": [ { "value": "32", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_POWER_REG": [ { "value": "0000", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT0_1": [ { "value": "0000", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT0_2": [ { "value": "0000", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT1_1": [ { "value": "0000", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT1_2": [ { "value": "0000", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT2_1": [ { "value": "0000", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT2_2": [ { "value": "0000", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT3_1": [ { "value": "0000", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT3_2": [ { "value": "0000", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT4_1": [ { "value": "0000", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT4_2": [ { "value": "0000", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT5_1": [ { "value": "0000", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT5_2": [ { "value": "0000", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT6_1": [ { "value": "0000", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT6_2": [ { "value": "0000", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKFBOUT_1": [ { "value": "0000", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKFBOUT_2": [ { "value": "0000", "resolve_type": "generated", "usage": "all" } ],
        "C_DIVCLK": [ { "value": "0000", "resolve_type": "generated", "usage": "all" } ],
        "C_LOCK_1": [ { "value": "0000", "resolve_type": "generated", "usage": "all" } ],
        "C_LOCK_2": [ { "value": "0000", "resolve_type": "generated", "usage": "all" } ],
        "C_LOCK_3": [ { "value": "0000", "resolve_type": "generated", "usage": "all" } ],
        "C_FILTER_1": [ { "value": "0000", "resolve_type": "generated", "usage": "all" } ],
        "C_FILTER_2": [ { "value": "0000", "resolve_type": "generated", "usage": "all" } ],
        "C_DIVIDE1_AUTO": [ { "value": "1", "resolve_type": "generated", "usage": "all" } ],
        "C_DIVIDE2_AUTO": [ { "value": "0.08333333333333333", "resolve_type": "generated", "usage": "all" } ],
        "C_DIVIDE3_AUTO": [ { "value": "0.08333333333333333", "resolve_type": "generated", "usage": "all" } ],
        "C_DIVIDE4_AUTO": [ { "value": "0.08333333333333333", "resolve_type": "generated", "usage": "all" } ],
        "C_DIVIDE5_AUTO": [ { "value": "0.08333333333333333", "resolve_type": "generated", "usage": "all" } ],
        "C_DIVIDE6_AUTO": [ { "value": "0.08333333333333333", "resolve_type": "generated", "usage": "all" } ],
        "C_DIVIDE7_AUTO": [ { "value": "0.08333333333333333", "resolve_type": "generated", "usage": "all" } ],
        "C_PLLBUFGCEDIV": [ { "value": "false", "resolve_type": "generated", "usage": "all" } ],
        "C_MMCMBUFGCEDIV": [ { "value": "false", "resolve_type": "generated", "usage": "all" } ],
        "C_PLLBUFGCEDIV1": [ { "value": "false", "resolve_type": "generated", "usage": "all" } ],
        "C_PLLBUFGCEDIV2": [ { "value": "false", "resolve_type": "generated", "usage": "all" } ],
        "C_PLLBUFGCEDIV3": [ { "value": "false", "resolve_type": "generated", "usage": "all" } ],
        "C_PLLBUFGCEDIV4": [ { "value": "false", "resolve_type": "generated", "usage": "all" } ],
        "C_MMCMBUFGCEDIV1": [ { "value": "false", "resolve_type": "generated", "usage": "all" } ],
        "C_MMCMBUFGCEDIV2": [ { "value": "false", "resolve_type": "generated", "usage": "all" } ],
        "C_MMCMBUFGCEDIV3": [ { "value": "false", "resolve_type": "generated", "usage": "all" } ],
        "C_MMCMBUFGCEDIV4": [ { "value": "false", "resolve_type": "generated", "usage": "all" } ],
        "C_MMCMBUFGCEDIV5": [ { "value": "false", "resolve_type": "generated", "usage": "all" } ],
        "C_MMCMBUFGCEDIV6": [ { "value": "false", "resolve_type": "generated", "usage": "all" } ],
        "C_MMCMBUFGCEDIV7": [ { "value": "false", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT1_MATCHED_ROUTING": [ { "value": "false", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT2_MATCHED_ROUTING": [ { "value": "false", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT3_MATCHED_ROUTING": [ { "value": "false", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT4_MATCHED_ROUTING": [ { "value": "false", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT5_MATCHED_ROUTING": [ { "value": "false", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT6_MATCHED_ROUTING": [ { "value": "false", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT7_MATCHED_ROUTING": [ { "value": "false", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT0_ACTUAL_FREQ": [ { "value": "100.00000", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT1_ACTUAL_FREQ": [ { "value": "100.000", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT2_ACTUAL_FREQ": [ { "value": "100.000", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT3_ACTUAL_FREQ": [ { "value": "100.000", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT4_ACTUAL_FREQ": [ { "value": "100.000", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT5_ACTUAL_FREQ": [ { "value": "100.000", "resolve_type": "generated", "usage": "all" } ],
        "C_CLKOUT6_ACTUAL_FREQ": [ { "value": "100.000", "resolve_type": "generated", "usage": "all" } ],
        "C_M_MAX": [ { "value": "64.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_M_MIN": [ { "value": "2.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_D_MAX": [ { "value": "42.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_D_MIN": [ { "value": "1.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_O_MAX": [ { "value": "128.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_O_MIN": [ { "value": "1.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_VCO_MIN": [ { "value": "800.000", "resolve_type": "generated", "format": "float", "usage": "all" } ],
        "C_VCO_MAX": [ { "value": "1600.000", "resolve_type": "generated", "format": "float", "usage": "all" } ]
      },
      "project_parameters": {
        "ARCHITECTURE": [ { "value": "zynq" } ],
        "BASE_BOARD_PART": [ { "value": "xilinx.com:zc702:part0:1.4" } ],
        "BOARD_CONNECTIONS": [ { "value": "" } ],
        "DEVICE": [ { "value": "xc7z020" } ],
        "PACKAGE": [ { "value": "clg484" } ],
        "PREFHDL": [ { "value": "VERILOG" } ],
        "SILICON_REVISION": [ { "value": "" } ],
        "SIMULATOR_LANGUAGE": [ { "value": "MIXED" } ],
        "SPEEDGRADE": [ { "value": "-1" } ],
        "STATIC_POWER": [ { "value": "" } ],
        "TEMPERATURE_GRADE": [ { "value": "" } ]
      },
      "runtime_parameters": {
        "IPCONTEXT": [ { "value": "IP_Flow" } ],
        "IPREVISION": [ { "value": "15" } ],
        "MANAGED": [ { "value": "TRUE" } ],
        "OUTPUTDIR": [ { "value": "../../../../hdl_design.gen/sources_1/ip/clk_gen_xip" } ],
        "SELECTEDSIMMODEL": [ { "value": "" } ],
        "SHAREDDIR": [ { "value": "." } ],
        "SWVERSION": [ { "value": "2024.2" } ],
        "SYNTHESISFLOW": [ { "value": "OUT_OF_CONTEXT" } ]
      }
    },
    "boundary": {
      "ports": {
        "reset": [ { "direction": "in", "driver_value": "0" } ],
        "clk_in1": [ { "direction": "in" } ],
        "daddr": [ { "direction": "in", "size_left": "6", "size_right": "0" } ],
        "drdy": [ { "direction": "out" } ],
        "dwe": [ { "direction": "in" } ],
        "din": [ { "direction": "in", "size_left": "15", "size_right": "0" } ],
        "dout": [ { "direction": "out", "size_left": "15", "size_right": "0" } ],
        "den": [ { "direction": "in" } ],
        "dclk": [ { "direction": "in" } ],
        "clk_out1": [ { "direction": "out" } ],
        "locked": [ { "direction": "out" } ]
      },
      "interfaces": {
        "reset": {
          "vlnv": "xilinx.com:signal:reset:1.0",
          "abstraction_type": "xilinx.com:signal:reset_rtl:1.0",
          "mode": "slave",
          "parameters": {
            "POLARITY": [ { "value": "ACTIVE_HIGH", "value_src": "constant", "usage": "all" } ],
            "BOARD.ASSOCIATED_PARAM": [ { "value": "RESET_BOARD_INTERFACE", "value_src": "constant", "usage": "all" } ],
            "INSERT_VIP": [ { "value": "0", "resolve_type": "user", "format": "long", "usage": "simulation.rtl", "is_ips_inferred": true, "is_static_object": false } ]
          },
          "port_maps": {
            "RST": [ { "physical_name": "reset" } ]
          }
        },
        "clock_CLK_IN1": {
          "vlnv": "xilinx.com:signal:clock:1.0",
          "abstraction_type": "xilinx.com:signal:clock_rtl:1.0",
          "mode": "slave",
          "parameters": {
            "FREQ_HZ": [ { "value": "100000000", "resolve_type": "generated", "format": "long", "is_ips_inferred": true, "is_static_object": false } ],
            "FREQ_TOLERANCE_HZ": [ { "value": "0", "resolve_type": "generated", "format": "long", "is_ips_inferred": true, "is_static_object": false } ],
            "PHASE": [ { "value": "0.0", "resolve_type": "generated", "format": "float", "is_ips_inferred": true, "is_static_object": false } ],
            "CLK_DOMAIN": [ { "value": "", "resolve_type": "generated", "is_ips_inferred": true, "is_static_object": false } ],
            "ASSOCIATED_BUSIF": [ { "value": "", "resolve_type": "generated", "is_ips_inferred": true, "is_static_object": false } ],
            "ASSOCIATED_PORT": [ { "value": "", "resolve_type": "generated", "is_ips_inferred": true, "is_static_object": false } ],
            "ASSOCIATED_RESET": [ { "value": "", "resolve_type": "generated", "is_ips_inferred": true, "is_static_object": false } ],
            "INSERT_VIP": [ { "value": "0", "resolve_type": "user", "format": "long", "usage": "simulation.rtl", "is_ips_inferred": true, "is_static_object": false } ],
            "BOARD.ASSOCIATED_PARAM": [ { "value": "CLK_IN1_BOARD_INTERFACE", "usage": "all", "is_static_object": false } ]
          },
          "port_maps": {
            "CLK_IN1": [ { "physical_name": "clk_in1" } ]
          }
        },
        "s_drp": {
          "vlnv": "xilinx.com:interface:drp:1.0",
          "abstraction_type": "xilinx.com:interface:drp_rtl:1.0",
          "mode": "slave",
          "port_maps": {
            "DADDR": [ { "physical_name": "daddr" } ],
            "DRDY": [ { "physical_name": "drdy" } ],
            "DWE": [ { "physical_name": "dwe" } ],
            "DI": [ { "physical_name": "din" } ],
            "DO": [ { "physical_name": "dout" } ],
            "DEN": [ { "physical_name": "den" } ]
          }
        },
        "clock_CLK_OUT1": {
          "vlnv": "xilinx.com:signal:clock:1.0",
          "abstraction_type": "xilinx.com:signal:clock_rtl:1.0",
          "mode": "master",
          "parameters": {
            "FREQ_HZ": [ { "value": "100000000", "resolve_type": "generated", "format": "long", "is_ips_inferred": true, "is_static_object": false } ],
            "FREQ_TOLERANCE_HZ": [ { "value": "0", "resolve_type": "generated", "format": "long", "is_ips_inferred": true, "is_static_object": false } ],
            "PHASE": [ { "value": "0.0", "resolve_type": "generated", "format": "float", "is_ips_inferred": true, "is_static_object": false } ],
            "CLK_DOMAIN": [ { "value": "", "resolve_type": "generated", "is_ips_inferred": true, "is_static_object": false } ],
            "ASSOCIATED_BUSIF": [ { "value": "", "resolve_type": "generated", "is_ips_inferred": true, "is_static_object": false } ],
            "ASSOCIATED_PORT": [ { "value": "", "resolve_type": "generated", "is_ips_inferred": true, "is_static_object": false } ],
            "ASSOCIATED_RESET": [ { "value": "", "resolve_type": "generated", "is_ips_inferred": true, "is_static_object": false } ],
            "INSERT_VIP": [ { "value": "0", "resolve_type": "user", "format": "long", "usage": "simulation.rtl", "is_ips_inferred": true, "is_static_object": false } ]
          },
          "port_maps": {
            "CLK_OUT1": [ { "physical_name": "clk_out1" } ]
          }
        }
      }
    }
  }
}{
  "schema": "xilinx.com:schema:json_instance:1.0",
  "ip_inst": {
    "xci_name": "mem_xip",
    "component_reference": "xilinx.com:ip:blk_mem_gen:8.4",
    "ip_revision": "9",
    "gen_directory": "../../../../hdl_design.gen/sources_1/ip/mem_xip",
    "parameters": {
      "component_parameters": {
        "Component_Name": [ { "value": "mem_xip", "resolve_type": "user", "usage": "all" } ],
        "Interface_Type": [ { "value": "Native", "resolve_type": "user", "usage": "all" } ],
        "AXI_Type": [ { "value": "AXI4_Full", "resolve_type": "user", "usage": "all" } ],
        "AXI_Slave_Type": [ { "value": "Memory_Slave", "resolve_type": "user", "usage": "all" } ],
        "Use_AXI_ID": [ { "value": "false", "resolve_type": "user", "format": "bool", "enabled": false, "usage": "all" } ],
        "AXI_ID_Width": [ { "value": "4", "resolve_type": "user", "format": "long", "enabled": false, "usage": "all" } ],
        "Memory_Type": [ { "value": "Simple_Dual_Port_RAM", "value_src": "user", "resolve_type": "user", "usage": "all" } ],
        "PRIM_type_to_Implement": [ { "value": "BRAM", "resolve_type": "user", "usage": "all" } ],
        "Enable_32bit_Address": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "ecctype": [ { "value": "No_ECC", "resolve_type": "user", "usage": "all" } ],
        "ECC": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "softecc": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "EN_SLEEP_PIN": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "EN_DEEPSLEEP_PIN": [ { "value": "false", "resolve_type": "user", "format": "bool", "enabled": false, "usage": "all" } ],
        "EN_SHUTDOWN_PIN": [ { "value": "false", "resolve_type": "user", "format": "bool", "enabled": false, "usage": "all" } ],
        "EN_ECC_PIPE": [ { "value": "false", "resolve_type": "user", "format": "bool", "enabled": false, "usage": "all" } ],
        "RD_ADDR_CHNG_A": [ { "value": "false", "resolve_type": "user", "format": "bool", "enabled": false, "usage": "all" } ],
        "RD_ADDR_CHNG_B": [ { "value": "false", "resolve_type": "user", "format": "bool", "enabled": false, "usage": "all" } ],
        "Use_Error_Injection_Pins": [ { "value": "false", "resolve_type": "user", "format": "bool", "enabled": false, "usage": "all" } ],
        "Error_Injection_Type": [ { "value": "Single_Bit_Error_Injection", "resolve_type": "user", "enabled": false, "usage": "all" } ],
        "Use_Byte_Write_Enable": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "Byte_Size": [ { "value": "9", "resolve_type": "user", "enabled": false, "usage": "all" } ],
        "Algorithm": [ { "value": "Minimum_Area", "resolve_type": "user", "usage": "all" } ],
        "Primitive": [ { "value": "8kx2", "resolve_type": "user", "enabled": false, "usage": "all" } ],
        "Assume_Synchronous_Clk": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "Write_Width_A": [ { "value": "16", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "Write_Depth_A": [ { "value": "16384", "value_src": "user", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "Read_Width_A": [ { "value": "16", "resolve_type": "user", "enabled": false, "usage": "all" } ],
        "Operating_Mode_A": [ { "value": "NO_CHANGE", "value_src": "user", "resolve_type": "user", "usage": "all" } ],
        "Enable_A": [ { "value": "Always_Enabled", "value_src": "user", "resolve_type": "user", "usage": "all" } ],
        "Write_Width_B": [ { "value": "16", "resolve_type": "user", "usage": "all" } ],
        "Read_Width_B": [ { "value": "16", "resolve_type": "user", "usage": "all" } ],
        "Operating_Mode_B": [ { "value": "WRITE_FIRST", "resolve_type": "user", "enabled": false, "usage": "all" } ],
        "Enable_B": [ { "value": "Always_Enabled", "value_src": "user", "resolve_type": "user", "usage": "all" } ],
        "Register_PortA_Output_of_Memory_Primitives": [ { "value": "false", "resolve_type": "user", "format": "bool", "enabled": false, "usage": "all" } ],
        "Register_PortA_Output_of_Memory_Core": [ { "value": "false", "resolve_type": "user", "format": "bool", "enabled": false, "usage": "all" } ],
        "Use_REGCEA_Pin": [ { "value": "false", "resolve_type": "user", "format": "bool", "enabled": false, "usage": "all" } ],
        "Register_PortB_Output_of_Memory_Primitives": [ { "value": "false", "value_src": "user", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "Register_PortB_Output_of_Memory_Core": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "Use_REGCEB_Pin": [ { "value": "false", "resolve_type": "user", "format": "bool", "enabled": false, "usage": "all" } ],
        "register_porta_input_of_softecc": [ { "value": "false", "resolve_type": "user", "format": "bool", "enabled": false, "usage": "all" } ],
        "register_portb_output_of_softecc": [ { "value": "false", "resolve_type": "user", "format": "bool", "enabled": false, "usage": "all" } ],
        "Pipeline_Stages": [ { "value": "0", "resolve_type": "user", "enabled": false, "usage": "all" } ],
        "Load_Init_File": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "Coe_File": [ { "value": "no_coe_file_loaded", "resolve_type": "user", "enabled": false, "usage": "all" } ],
        "Fill_Remaining_Memory_Locations": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "Remaining_Memory_Locations": [ { "value": "0", "resolve_type": "user", "enabled": false, "usage": "all" } ],
        "Use_RSTA_Pin": [ { "value": "false", "resolve_type": "user", "format": "bool", "enabled": false, "usage": "all" } ],
        "Reset_Memory_Latch_A": [ { "value": "false", "resolve_type": "user", "format": "bool", "enabled": false, "usage": "all" } ],
        "Reset_Priority_A": [ { "value": "CE", "resolve_type": "user", "enabled": false, "usage": "all" } ],
        "Output_Reset_Value_A": [ { "value": "0", "resolve_type": "user", "enabled": false, "usage": "all" } ],
        "Use_RSTB_Pin": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "Reset_Memory_Latch_B": [ { "value": "false", "resolve_type": "user", "format": "bool", "enabled": false, "usage": "all" } ],
        "Reset_Priority_B": [ { "value": "CE", "resolve_type": "user", "enabled": false, "usage": "all" } ],
        "Output_Reset_Value_B": [ { "value": "0", "resolve_type": "user", "enabled": false, "usage": "all" } ],
        "Reset_Type": [ { "value": "SYNC", "resolve_type": "user", "enabled": false, "usage": "all" } ],
        "Additional_Inputs_for_Power_Estimation": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "Port_A_Clock": [ { "value": "100", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "Port_A_Write_Rate": [ { "value": "50", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "Port_B_Clock": [ { "value": "100", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "Port_B_Write_Rate": [ { "value": "0", "resolve_type": "user", "format": "long", "enabled": false, "usage": "all" } ],
        "Port_A_Enable_Rate": [ { "value": "100", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "Port_B_Enable_Rate": [ { "value": "100", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "Collision_Warnings": [ { "value": "ALL", "resolve_type": "user", "usage": "all" } ],
        "Disable_Collision_Warnings": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "Disable_Out_of_Range_Warnings": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "use_bram_block": [ { "value": "Stand_Alone", "resolve_type": "user", "usage": "all" } ],
        "MEM_FILE": [ { "value": "no_mem_loaded", "resolve_type": "user", "usage": "all" } ],
        "CTRL_ECC_ALGO": [ { "value": "NONE", "resolve_type": "user", "usage": "all" } ],
        "EN_SAFETY_CKT": [ { "value": "false", "resolve_type": "user", "format": "bool", "enabled": false, "usage": "all" } ],
        "READ_LATENCY_A": [ { "value": "1", "resolve_type": "user", "format": "long", "enabled": false, "usage": "all" } ],
        "READ_LATENCY_B": [ { "value": "1", "resolve_type": "user", "format": "long", "enabled": false, "usage": "all" } ]
      },
      "model_parameters": {
        "C_FAMILY": [ { "value": "zynq", "resolve_type": "generated", "usage": "all" } ],
        "C_XDEVICEFAMILY": [ { "value": "zynq", "resolve_type": "generated", "usage": "all" } ],
        "C_ELABORATION_DIR": [ { "value": "./", "resolve_type": "generated", "usage": "all" } ],
        "C_INTERFACE_TYPE": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_AXI_TYPE": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_AXI_SLAVE_TYPE": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_USE_BRAM_BLOCK": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_ENABLE_32BIT_ADDRESS": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_CTRL_ECC_ALGO": [ { "value": "NONE", "resolve_type": "generated", "usage": "all" } ],
        "C_HAS_AXI_ID": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_AXI_ID_WIDTH": [ { "value": "4", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_MEM_TYPE": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_BYTE_SIZE": [ { "value": "9", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_ALGORITHM": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_PRIM_TYPE": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_LOAD_INIT_FILE": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_INIT_FILE_NAME": [ { "value": "no_coe_file_loaded", "resolve_type": "generated", "usage": "all" } ],
        "C_INIT_FILE": [ { "value": "mem_xip.mem", "resolve_type": "generated", "usage": "all" } ],
        "C_USE_DEFAULT_DATA": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_DEFAULT_DATA": [ { "value": "0", "resolve_type": "generated", "usage": "all" } ],
        "C_HAS_RSTA": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_RST_PRIORITY_A": [ { "value": "CE", "resolve_type": "generated", "usage": "all" } ],
        "C_RSTRAM_A": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_INITA_VAL": [ { "value": "0", "resolve_type": "generated", "usage": "all" } ],
        "C_HAS_ENA": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_HAS_REGCEA": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_USE_BYTE_WEA": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_WEA_WIDTH": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_WRITE_MODE_A": [ { "value": "NO_CHANGE", "resolve_type": "generated", "usage": "all" } ],
        "C_WRITE_WIDTH_A": [ { "value": "16", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_READ_WIDTH_A": [ { "value": "16", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_WRITE_DEPTH_A": [ { "value": "16384", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_READ_DEPTH_A": [ { "value": "16384", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_ADDRA_WIDTH": [ { "value": "14", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_HAS_RSTB": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_RST_PRIORITY_B": [ { "value": "CE", "resolve_type": "generated", "usage": "all" } ],
        "C_RSTRAM_B": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_INITB_VAL": [ { "value": "0", "resolve_type": "generated", "usage": "all" } ],
        "C_HAS_ENB": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_HAS_REGCEB": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_USE_BYTE_WEB": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_WEB_WIDTH": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_WRITE_MODE_B": [ { "value": "WRITE_FIRST", "resolve_type": "generated", "usage": "all" } ],
        "C_WRITE_WIDTH_B": [ { "value": "16", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_READ_WIDTH_B": [ { "value": "16", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_WRITE_DEPTH_B": [ { "value": "16384", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_READ_DEPTH_B": [ { "value": "16384", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_ADDRB_WIDTH": [ { "value": "14", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_HAS_MEM_OUTPUT_REGS_A": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_HAS_MEM_OUTPUT_REGS_B": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_HAS_MUX_OUTPUT_REGS_A": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_HAS_MUX_OUTPUT_REGS_B": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_MUX_PIPELINE_STAGES": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_HAS_SOFTECC_INPUT_REGS_A": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_HAS_SOFTECC_OUTPUT_REGS_B": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_USE_SOFTECC": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_USE_ECC": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_EN_ECC_PIPE": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_READ_LATENCY_A": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_READ_LATENCY_B": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_HAS_INJECTERR": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_SIM_COLLISION_CHECK": [ { "value": "ALL", "resolve_type": "generated", "usage": "all" } ],
        "C_COMMON_CLK": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_DISABLE_WARN_BHV_COLL": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_EN_SLEEP_PIN": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_USE_URAM": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_EN_RDADDRA_CHG": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_EN_RDADDRB_CHG": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_EN_DEEPSLEEP_PIN": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_EN_SHUTDOWN_PIN": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_EN_SAFETY_CKT": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_DISABLE_WARN_BHV_RANGE": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_COUNT_36K_BRAM": [ { "value": "7", "resolve_type": "generated", "usage": "all" } ],
        "C_COUNT_18K_BRAM": [ { "value": "1", "resolve_type": "generated", "usage": "all" } ],
        "C_EST_POWER_SUMMARY": [ { "value": "Estimated Power for IP     :     19.908848 mW", "resolve_type": "generated", "usage": "all" } ]
      },
      "project_parameters": {
        "ARCHITECTURE": [ { "value": "zynq" } ],
        "BASE_BOARD_PART": [ { "value": "xilinx.com:zc702:part0:1.4" } ],
        "BOARD_CONNECTIONS": [ { "value": "" } ],
        "DEVICE": [ { "value": "xc7z020" } ],
        "PACKAGE": [ { "value": "clg484" } ],
        "PREFHDL": [ { "value": "VERILOG" } ],
        "SILICON_REVISION": [ { "value": "" } ],
        "SIMULATOR_LANGUAGE": [ { "value": "MIXED" } ],
        "SPEEDGRADE": [ { "value": "-1" } ],
        "STATIC_POWER": [ { "value": "" } ],
        "TEMPERATURE_GRADE": [ { "value": "" } ]
      },
      "runtime_parameters": {
        "IPCONTEXT": [ { "value": "IP_Flow" } ],
        "IPREVISION": [ { "value": "9" } ],
        "MANAGED": [ { "value": "TRUE" } ],
        "OUTPUTDIR": [ { "value": "../../../../hdl_design.gen/sources_1/ip/mem_xip" } ],
        "SELECTEDSIMMODEL": [ { "value": "" } ],
        "SHAREDDIR": [ { "value": "." } ],
        "SWVERSION": [ { "value": "2024.2" } ],
        "SYNTHESISFLOW": [ { "value": "OUT_OF_CONTEXT" } ]
      }
    },
    "boundary": {
      "ports": {
        "clka": [ { "direction": "in", "driver_value": "0" } ],
        "wea": [ { "direction": "in", "size_left": "0", "size_right": "0", "driver_value": "0" } ],
        "addra": [ { "direction": "in", "size_left": "13", "size_right": "0", "driver_value": "0" } ],
        "dina": [ { "direction": "in", "size_left": "15", "size_right": "0", "driver_value": "0" } ],
        "clkb": [ { "direction": "in", "driver_value": "0" } ],
        "addrb": [ { "direction": "in", "size_left": "13", "size_right": "0", "driver_value": "0" } ],
        "doutb": [ { "direction": "out", "size_left": "15", "size_right": "0" } ]
      },
      "interfaces": {
        "CLK.ACLK": {
          "vlnv": "xilinx.com:signal:clock:1.0",
          "abstraction_type": "xilinx.com:signal:clock_rtl:1.0",
          "mode": "slave",
          "parameters": {
            "ASSOCIATED_BUSIF": [ { "value": "AXI_SLAVE_S_AXI:AXILite_SLAVE_S_AXI", "value_src": "constant", "usage": "all" } ],
            "ASSOCIATED_RESET": [ { "value": "s_aresetn", "value_src": "constant", "usage": "all" } ],
            "FREQ_HZ": [ { "value": "100000000", "resolve_type": "generated", "format": "long", "is_ips_inferred": true, "is_static_object": false } ],
            "FREQ_TOLERANCE_HZ": [ { "value": "0", "resolve_type": "generated", "format": "long", "is_ips_inferred": true, "is_static_object": false } ],
            "PHASE": [ { "value": "0.0", "resolve_type": "generated", "format": "float", "is_ips_inferred": true, "is_static_object": false } ],
            "CLK_DOMAIN": [ { "value": "", "resolve_type": "generated", "is_ips_inferred": true, "is_static_object": false } ],
            "ASSOCIATED_PORT": [ { "value": "", "resolve_type": "generated", "is_ips_inferred": true, "is_static_object": false } ],
            "INSERT_VIP": [ { "value": "0", "resolve_type": "user", "format": "long", "usage": "simulation.rtl", "is_ips_inferred": true, "is_static_object": false } ]
          }
        },
        "RST.ARESETN": {
          "vlnv": "xilinx.com:signal:reset:1.0",
          "abstraction_type": "xilinx.com:signal:reset_rtl:1.0",
          "mode": "slave",
          "parameters": {
            "POLARITY": [ { "value": "ACTIVE_LOW", "value_src": "constant", "usage": "all" } ],
            "INSERT_VIP": [ { "value": "0", "resolve_type": "user", "format": "long", "usage": "simulation.rtl", "is_ips_inferred": true, "is_static_object": false } ]
          }
        },
        "BRAM_PORTA": {
          "vlnv": "xilinx.com:interface:bram:1.0",
          "abstraction_type": "xilinx.com:interface:bram_rtl:1.0",
          "mode": "slave",
          "parameters": {
            "MEM_ADDRESS_MODE": [ { "value": "BYTE_ADDRESS", "resolve_type": "user", "usage": "all" } ],
            "MEM_SIZE": [ { "value": "8192", "resolve_type": "generated", "format": "long", "is_ips_inferred": true, "is_static_object": false } ],
            "MEM_WIDTH": [ { "value": "32", "resolve_type": "generated", "format": "long", "is_ips_inferred": true, "is_static_object": false } ],
            "MEM_ECC": [ { "value": "NONE", "resolve_type": "generated", "is_ips_inferred": true, "is_static_object": false } ],
            "MASTER_TYPE": [ { "value": "OTHER", "resolve_type": "generated", "is_ips_inferred": true, "is_static_object": false } ],
            "READ_WRITE_MODE": [ { "value": "", "resolve_type": "generated", "is_ips_inferred": true, "is_static_object": false } ],
            "READ_LATENCY": [ { "value": "1", "resolve_type": "generated", "format": "long", "is_ips_inferred": true, "is_static_object": false } ]
          },
          "port_maps": {
            "ADDR": [ { "physical_name": "addra" } ],
            "CLK": [ { "physical_name": "clka" } ],
            "DIN": [ { "physical_name": "dina" } ],
            "WE": [ { "physical_name": "wea" } ]
          }
        },
        "BRAM_PORTB": {
          "vlnv": "xilinx.com:interface:bram:1.0",
          "abstraction_type": "xilinx.com:interface:bram_rtl:1.0",
          "mode": "slave",
          "parameters": {
            "MEM_ADDRESS_MODE": [ { "value": "BYTE_ADDRESS", "resolve_type": "user", "usage": "all" } ],
            "MEM_SIZE": [ { "value": "8192", "resolve_type": "generated", "format": "long", "is_ips_inferred": true, "is_static_object": false } ],
            "MEM_WIDTH": [ { "value": "32", "resolve_type": "generated", "format": "long", "is_ips_inferred": true, "is_static_object": false } ],
            "MEM_ECC": [ { "value": "NONE", "resolve_type": "generated", "is_ips_inferred": true, "is_static_object": false } ],
            "MASTER_TYPE": [ { "value": "OTHER", "resolve_type": "generated", "is_ips_inferred": true, "is_static_object": false } ],
            "READ_WRITE_MODE": [ { "value": "", "resolve_type": "generated", "is_ips_inferred": true, "is_static_object": false } ],
            "READ_LATENCY": [ { "value": "1", "resolve_type": "generated", "format": "long", "is_ips_inferred": true, "is_static_object": false } ]
          },
          "port_maps": {
            "ADDR": [ { "physical_name": "addrb" } ],
            "CLK": [ { "physical_name": "clkb" } ],
            "DOUT": [ { "physical_name": "doutb" } ]
          }
        }
      },
      "memory_maps": {
        "S_1": {
          "address_blocks": {
            "Mem0": {
              "base_address": "0",
              "range": "4096",
              "usage": "memory",
              "access": "read-write",
              "parameters": {
                "OFFSET_BASE_PARAM": [ { "value": "C_BASEADDR" } ],
                "OFFSET_HIGH_PARAM": [ { "value": "C_HIGHADDR" } ]
              }
            }
          }
        }
      }
    }
  }
}{
  "schema": "xilinx.com:schema:json_instance:1.0",
  "ip_inst": {
    "xci_name": "reset_gen_xip",
    "component_reference": "xilinx.com:ip:proc_sys_reset:5.0",
    "ip_revision": "16",
    "gen_directory": "../../../../hdl_design.gen/sources_1/ip/reset_gen_xip",
    "parameters": {
      "component_parameters": {
        "C_NUM_PERP_ARESETN": [ { "value": "1", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "C_NUM_INTERCONNECT_ARESETN": [ { "value": "1", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "C_NUM_PERP_RST": [ { "value": "1", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "C_NUM_BUS_RST": [ { "value": "1", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "C_AUX_RESET_HIGH": [ { "value": "0", "value_src": "user", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "C_EXT_RESET_HIGH": [ { "value": "0", "value_src": "user", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "C_AUX_RST_WIDTH": [ { "value": "1", "value_src": "user", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "C_EXT_RST_WIDTH": [ { "value": "1", "value_src": "user", "resolve_type": "user", "format": "long", "usage": "all" } ],
        "Component_Name": [ { "value": "reset_gen_xip", "resolve_type": "user", "usage": "all" } ],
        "USE_BOARD_FLOW": [ { "value": "false", "resolve_type": "user", "format": "bool", "usage": "all" } ],
        "RESET_BOARD_INTERFACE": [ { "value": "Custom", "resolve_type": "user", "usage": "all" } ]
      },
      "model_parameters": {
        "C_FAMILY": [ { "value": "zynq", "resolve_type": "generated", "usage": "all" } ],
        "C_EXT_RST_WIDTH": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_AUX_RST_WIDTH": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_EXT_RESET_HIGH": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_AUX_RESET_HIGH": [ { "value": "0", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_NUM_BUS_RST": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_NUM_PERP_RST": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_NUM_INTERCONNECT_ARESETN": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ],
        "C_NUM_PERP_ARESETN": [ { "value": "1", "resolve_type": "generated", "format": "long", "usage": "all" } ]
      },
      "project_parameters": {
        "ARCHITECTURE": [ { "value": "zynq" } ],
        "BASE_BOARD_PART": [ { "value": "xilinx.com:zc702:part0:1.4" } ],
        "BOARD_CONNECTIONS": [ { "value": "" } ],
        "DEVICE": [ { "value": "xc7z020" } ],
        "PACKAGE": [ { "value": "clg484" } ],
        "PREFHDL": [ { "value": "VERILOG" } ],
        "SILICON_REVISION": [ { "value": "" } ],
        "SIMULATOR_LANGUAGE": [ { "value": "MIXED" } ],
        "SPEEDGRADE": [ { "value": "-1" } ],
        "STATIC_POWER": [ { "value": "" } ],
        "TEMPERATURE_GRADE": [ { "value": "" } ]
      },
      "runtime_parameters": {
        "IPCONTEXT": [ { "value": "IP_Flow" } ],
        "IPREVISION": [ { "value": "16" } ],
        "MANAGED": [ { "value": "TRUE" } ],
        "OUTPUTDIR": [ { "value": "../../../../hdl_design.gen/sources_1/ip/reset_gen_xip" } ],
        "SELECTEDSIMMODEL": [ { "value": "" } ],
        "SHAREDDIR": [ { "value": "." } ],
        "SWVERSION": [ { "value": "2024.2" } ],
        "SYNTHESISFLOW": [ { "value": "OUT_OF_CONTEXT" } ]
      }
    },
    "boundary": {
      "ports": {
        "slowest_sync_clk": [ { "direction": "in" } ],
        "ext_reset_in": [ { "direction": "in" } ],
        "aux_reset_in": [ { "direction": "in", "driver_value": "1" } ],
        "mb_debug_sys_rst": [ { "direction": "in", "driver_value": "0" } ],
        "dcm_locked": [ { "direction": "in", "driver_value": "0x1" } ],
        "mb_reset": [ { "direction": "out", "driver_value": "0x0" } ],
        "bus_struct_reset": [ { "direction": "out", "size_left": "0", "size_right": "0", "driver_value": "0" } ],
        "peripheral_reset": [ { "direction": "out", "size_left": "0", "size_right": "0", "driver_value": "0" } ],
        "interconnect_aresetn": [ { "direction": "out", "size_left": "0", "size_right": "0", "driver_value": "1" } ],
        "peripheral_aresetn": [ { "direction": "out", "size_left": "0", "size_right": "0", "driver_value": "1" } ]
      },
      "interfaces": {
        "clock": {
          "vlnv": "xilinx.com:signal:clock:1.0",
          "abstraction_type": "xilinx.com:signal:clock_rtl:1.0",
          "mode": "slave",
          "parameters": {
            "ASSOCIATED_RESET": [ { "value": "mb_reset:bus_struct_reset:interconnect_aresetn:peripheral_aresetn:peripheral_reset", "value_src": "constant", "usage": "all" } ],
            "FREQ_HZ": [ { "value": "100000000", "resolve_type": "user", "format": "long", "usage": "all" } ],
            "FREQ_TOLERANCE_HZ": [ { "value": "0", "resolve_type": "generated", "format": "long", "is_ips_inferred": true, "is_static_object": false } ],
            "PHASE": [ { "value": "0.0", "resolve_type": "generated", "format": "float", "is_ips_inferred": true, "is_static_object": false } ],
            "CLK_DOMAIN": [ { "value": "", "resolve_type": "generated", "is_ips_inferred": true, "is_static_object": false } ],
            "ASSOCIATED_BUSIF": [ { "value": "", "resolve_type": "generated", "is_ips_inferred": true, "is_static_object": false } ],
            "ASSOCIATED_PORT": [ { "value": "", "resolve_type": "generated", "is_ips_inferred": true, "is_static_object": false } ],
            "INSERT_VIP": [ { "value": "0", "resolve_type": "user", "format": "long", "usage": "simulation.rtl", "is_ips_inferred": true, "is_static_object": false } ]
          },
          "port_maps": {
            "CLK": [ { "physical_name": "slowest_sync_clk" } ]
          }
        },
        "ext_reset": {
          "vlnv": "xilinx.com:signal:reset:1.0",
          "abstraction_type": "xilinx.com:signal:reset_rtl:1.0",
          "mode": "slave",
          "parameters": {
            "BOARD.ASSOCIATED_PARAM": [ { "value": "RESET_BOARD_INTERFACE", "value_src": "constant", "usage": "all" } ],
            "POLARITY": [ { "value": "ACTIVE_LOW", "resolve_type": "generated", "is_ips_inferred": true, "is_static_object": false } ],
            "INSERT_VIP": [ { "value": "0", "resolve_type": "user", "format": "long", "usage": "simulation.rtl", "is_ips_inferred": true, "is_static_object": false } ]
          },
          "port_maps": {
            "RST": [ { "physical_name": "ext_reset_in" } ]
          }
        },
        "aux_reset": {
          "vlnv": "xilinx.com:signal:reset:1.0",
          "abstraction_type": "xilinx.com:signal:reset_rtl:1.0",
          "mode": "slave",
          "parameters": {
            "POLARITY": [ { "value": "ACTIVE_LOW", "resolve_type": "generated", "is_ips_inferred": true, "is_static_object": false } ],
            "INSERT_VIP": [ { "value": "0", "resolve_type": "user", "format": "long", "usage": "simulation.rtl", "is_ips_inferred": true, "is_static_object": false } ]
          },
          "port_maps": {
            "RST": [ { "physical_name": "aux_reset_in" } ]
          }
        },
        "dbg_reset": {
          "vlnv": "xilinx.com:signal:reset:1.0",
          "abstraction_type": "xilinx.com:signal:reset_rtl:1.0",
          "mode": "slave",
          "parameters": {
            "POLARITY": [ { "value": "ACTIVE_HIGH", "value_src": "constant", "usage": "all" } ],
            "INSERT_VIP": [ { "value": "0", "resolve_type": "user", "format": "long", "usage": "simulation.rtl", "is_ips_inferred": true, "is_static_object": false } ]
          },
          "port_maps": {
            "RST": [ { "physical_name": "mb_debug_sys_rst" } ]
          }
        },
        "mb_rst": {
          "vlnv": "xilinx.com:signal:reset:1.0",
          "abstraction_type": "xilinx.com:signal:reset_rtl:1.0",
          "mode": "master",
          "parameters": {
            "POLARITY": [ { "value": "ACTIVE_HIGH", "value_src": "constant", "usage": "all" } ],
            "TYPE": [ { "value": "PROCESSOR", "value_src": "constant", "usage": "all" } ],
            "INSERT_VIP": [ { "value": "0", "resolve_type": "user", "format": "long", "usage": "simulation.rtl", "is_ips_inferred": true, "is_static_object": false } ]
          },
          "port_maps": {
            "RST": [ { "physical_name": "mb_reset" } ]
          }
        },
        "bus_struct_reset": {
          "vlnv": "xilinx.com:signal:reset:1.0",
          "abstraction_type": "xilinx.com:signal:reset_rtl:1.0",
          "mode": "master",
          "parameters": {
            "POLARITY": [ { "value": "ACTIVE_HIGH", "value_src": "constant", "usage": "all" } ],
            "TYPE": [ { "value": "INTERCONNECT", "value_src": "constant", "usage": "all" } ],
            "INSERT_VIP": [ { "value": "0", "resolve_type": "user", "format": "long", "usage": "simulation.rtl", "is_ips_inferred": true, "is_static_object": false } ]
          },
          "port_maps": {
            "RST": [ { "physical_name": "bus_struct_reset" } ]
          }
        },
        "interconnect_low_rst": {
          "vlnv": "xilinx.com:signal:reset:1.0",
          "abstraction_type": "xilinx.com:signal:reset_rtl:1.0",
          "mode": "master",
          "parameters": {
            "POLARITY": [ { "value": "ACTIVE_LOW", "value_src": "constant", "usage": "all" } ],
            "TYPE": [ { "value": "INTERCONNECT", "value_src": "constant", "usage": "all" } ],
            "INSERT_VIP": [ { "value": "0", "resolve_type": "user", "format": "long", "usage": "simulation.rtl", "is_ips_inferred": true, "is_static_object": false } ]
          },
          "port_maps": {
            "RST": [ { "physical_name": "interconnect_aresetn" } ]
          }
        },
        "peripheral_high_rst": {
          "vlnv": "xilinx.com:signal:reset:1.0",
          "abstraction_type": "xilinx.com:signal:reset_rtl:1.0",
          "mode": "master",
          "parameters": {
            "POLARITY": [ { "value": "ACTIVE_HIGH", "value_src": "constant", "usage": "all" } ],
            "TYPE": [ { "value": "PERIPHERAL", "value_src": "constant", "usage": "all" } ],
            "INSERT_VIP": [ { "value": "0", "resolve_type": "user", "format": "long", "usage": "simulation.rtl", "is_ips_inferred": true, "is_static_object": false } ]
          },
          "port_maps": {
            "RST": [ { "physical_name": "peripheral_reset" } ]
          }
        },
        "peripheral_low_rst": {
          "vlnv": "xilinx.com:signal:reset:1.0",
          "abstraction_type": "xilinx.com:signal:reset_rtl:1.0",
          "mode": "master",
          "parameters": {
            "POLARITY": [ { "value": "ACTIVE_LOW", "value_src": "constant", "usage": "all" } ],
            "TYPE": [ { "value": "PERIPHERAL", "value_src": "constant", "usage": "all" } ],
            "INSERT_VIP": [ { "value": "0", "resolve_type": "user", "format": "long", "usage": "simulation.rtl", "is_ips_inferred": true, "is_static_object": false } ]
          },
          "port_maps": {
            "RST": [ { "physical_name": "peripheral_aresetn" } ]
          }
        }
      }
    }
  }
}module main_state_machine #(
    parameter N_SAR_BITS = 3
) (
    reg_if.RD rd,
    input logic i_clk,
    input logic i_rst_b,
    input logic i_start,
    output logic [2:0] o_main_state,
    output logic o_sample,
    output logic o_int1,
    output logic o_int2,
    output logic o_incremental_reset
);

    logic [13:0] nfft_counter;
    logic [16:0] current_state_counter;
    logic  [7:0] osr_counter;

    enum logic [2:0] {
        READY=3'h0,
        SAMPLE=3'h1,
        QUANTIZE=3'h2,
        INT1=3'h3,
        INT2=3'h4,
        STOP=3'h5
    } state, next_state;

    // next state logic
    always_comb begin
        case (state)
            READY : begin
                o_main_state = 3'h0;
                next_state = i_start ? SAMPLE : READY;
            end
            SAMPLE : begin
                o_main_state = 3'h1;
                next_state = (current_state_counter == (rd.N_SH_TOTAL_CYCLES - 1)) ? QUANTIZE : SAMPLE;
            end
            QUANTIZE : begin
                o_main_state = 3'h2;
                // stay in QUANTIZE for 4 * N_SAR_CYCLES - 1 for each SAR bit and 1 for DWA
                next_state = (current_state_counter == ((rd.N_SAR_CYCLES * ((N_SAR_BITS * 2) + 1)) - 1)) ? INT1 : QUANTIZE;
            end
            INT1 : begin
                o_main_state = 3'h3;
                next_state = (current_state_counter == (rd.N_INT1_TOTAL_CYCLES - 1)) ? INT2 : INT1;
            end
            INT2 : begin
                o_main_state = 3'h4;
                next_state = (current_state_counter == (rd.N_INT2_TOTAL_CYCLES - 1)) ? 
                                 (nfft_counter == ((1 << rd.NFFT_POWER) - 1)) ? STOP : SAMPLE : INT2;
            end
            STOP : begin
                o_main_state = 3'h5;
                next_state = i_start ? STOP : READY;
            end
            default : begin
                o_main_state = 3'h0;
                next_state = READY;
            end
        endcase
    end

    assign o_sample = (state == SAMPLE) && (current_state_counter <= (rd.N_SH_ACTIVE_CYCLES - 1));
    assign o_int1   = (state == INT1)   && (current_state_counter <= (rd.N_INT1_ACTIVE_CYCLES - 1));
    assign o_int2   = (state == INT2)   && (current_state_counter <= (rd.N_INT2_ACTIVE_CYCLES - 1));
    assign o_incremental_reset = (state == INT2) && (next_state == SAMPLE) && (osr_counter == ((1 << rd.OSR_POWER) - 1));

    always_ff @(posedge i_clk) begin
        if (!i_rst_b) begin
            state <= READY;
            current_state_counter <= 0;
            nfft_counter <= 0;
            osr_counter <= 0;
        end else begin
            state <= next_state;
            if ((state == INT2) && (next_state == READY))
                nfft_counter <= 0;
            else if ((state == INT2) && (next_state == SAMPLE) && (osr_counter == ((1 << rd.OSR_POWER) - 1)))
                nfft_counter <= nfft_counter + 1;
            if (state != next_state)
                current_state_counter <= 0;
            else
                current_state_counter <= (current_state_counter + 1);
            if ((state == INT2) && (next_state != INT2)) begin
                if (osr_counter == ((1 << rd.OSR_POWER) - 1))
                    osr_counter <= 0;
                else
                    osr_counter <= osr_counter + 1;
            end
        end
    end

endmodule// Class: adc_regs_reg_sync
// Instantiates CDC synchronizers for the CSR registers.
// Automatically generated from registers.rdl using PeakRDL.
module #(
	parameter N_SYNC_STAGES=2,
	parameter SRC_INPUT_REG=0
) adc_regs_reg_sync (
	adc_regs__in_t hwif_in_sysclk,
	adc_regs__in_t hwif_in_ifclk,
	adc_regs__out_t hwif_out_sysclk,
	adc_regs__out_t hwif_out_ifclk,
	input logic sysclk,
	input logic ifclk
);

	sync_nstage #(
		.N_SYNC_STAGES(N_SYNC_STAGES),
		.SRC_INPUT_REG(SRC_INPUT_REG),
		.N_BITS(15)
	) sync_NFFT_POWER (
		.src_clk(ifclk),
		.dest_clk(sysclk),
		.src_data(hwif_out_ifclk.NFFT_CTRL.NFFT_POWER.value),
		.dest_data(hwif_out_sysclk.NFFT_CTRL.NFFT_POWER.value)
	);

	sync_nstage #(
		.N_SYNC_STAGES(N_SYNC_STAGES),
		.SRC_INPUT_REG(SRC_INPUT_REG),
		.N_BITS(1)
	) sync_DWA_EN (
		.src_clk(ifclk),
		.dest_clk(sysclk),
		.src_data(hwif_out_ifclk.NFFT_CTRL.DWA_EN.value),
		.dest_data(hwif_out_sysclk.NFFT_CTRL.DWA_EN.value)
	);

	sync_nstage #(
		.N_SYNC_STAGES(N_SYNC_STAGES),
		.SRC_INPUT_REG(SRC_INPUT_REG),
		.N_BITS(8)
	) sync_OSR_POWER (
		.src_clk(ifclk),
		.dest_clk(sysclk),
		.src_data(hwif_out_ifclk.OSR.OSR_POWER.value),
		.dest_data(hwif_out_sysclk.OSR.OSR_POWER.value)
	);

	sync_nstage #(
		.N_SYNC_STAGES(N_SYNC_STAGES),
		.SRC_INPUT_REG(SRC_INPUT_REG),
		.N_BITS(8)
	) sync_N_ACTIVE_CYCLES (
		.src_clk(ifclk),
		.dest_clk(sysclk),
		.src_data(hwif_out_ifclk.SH_CTRL.N_ACTIVE_CYCLES.value),
		.dest_data(hwif_out_sysclk.SH_CTRL.N_ACTIVE_CYCLES.value)
	);

	sync_nstage #(
		.N_SYNC_STAGES(N_SYNC_STAGES),
		.SRC_INPUT_REG(SRC_INPUT_REG),
		.N_BITS(8)
	) sync_N_PASSIVE_CYCLES (
		.src_clk(ifclk),
		.dest_clk(sysclk),
		.src_data(hwif_out_ifclk.SH_CTRL.N_PASSIVE_CYCLES.value),
		.dest_data(hwif_out_sysclk.SH_CTRL.N_PASSIVE_CYCLES.value)
	);

	sync_nstage #(
		.N_SYNC_STAGES(N_SYNC_STAGES),
		.SRC_INPUT_REG(SRC_INPUT_REG),
		.N_BITS(8)
	) sync_N_ACTIVE_CYCLES (
		.src_clk(ifclk),
		.dest_clk(sysclk),
		.src_data(hwif_out_ifclk.INT1_CTRL.N_ACTIVE_CYCLES.value),
		.dest_data(hwif_out_sysclk.INT1_CTRL.N_ACTIVE_CYCLES.value)
	);

	sync_nstage #(
		.N_SYNC_STAGES(N_SYNC_STAGES),
		.SRC_INPUT_REG(SRC_INPUT_REG),
		.N_BITS(8)
	) sync_N_PASSIVE_CYCLES (
		.src_clk(ifclk),
		.dest_clk(sysclk),
		.src_data(hwif_out_ifclk.INT1_CTRL.N_PASSIVE_CYCLES.value),
		.dest_data(hwif_out_sysclk.INT1_CTRL.N_PASSIVE_CYCLES.value)
	);

	sync_nstage #(
		.N_SYNC_STAGES(N_SYNC_STAGES),
		.SRC_INPUT_REG(SRC_INPUT_REG),
		.N_BITS(8)
	) sync_N_ACTIVE_CYCLES (
		.src_clk(ifclk),
		.dest_clk(sysclk),
		.src_data(hwif_out_ifclk.INT2_CTRL.N_ACTIVE_CYCLES.value),
		.dest_data(hwif_out_sysclk.INT2_CTRL.N_ACTIVE_CYCLES.value)
	);

	sync_nstage #(
		.N_SYNC_STAGES(N_SYNC_STAGES),
		.SRC_INPUT_REG(SRC_INPUT_REG),
		.N_BITS(8)
	) sync_N_PASSIVE_CYCLES (
		.src_clk(ifclk),
		.dest_clk(sysclk),
		.src_data(hwif_out_ifclk.INT2_CTRL.N_PASSIVE_CYCLES.value),
		.dest_data(hwif_out_sysclk.INT2_CTRL.N_PASSIVE_CYCLES.value)
	);

	sync_nstage #(
		.N_SYNC_STAGES(N_SYNC_STAGES),
		.SRC_INPUT_REG(SRC_INPUT_REG),
		.N_BITS(1)
	) sync_INPUT_MODE (
		.src_clk(ifclk),
		.dest_clk(sysclk),
		.src_data(hwif_out_ifclk.ADC_CTRL.INPUT_MODE.value),
		.dest_data(hwif_out_sysclk.ADC_CTRL.INPUT_MODE.value)
	);

	sync_nstage #(
		.N_SYNC_STAGES(N_SYNC_STAGES),
		.SRC_INPUT_REG(SRC_INPUT_REG),
		.N_BITS(4)
	) sync_VCM_SINGLE_ENDED (
		.src_clk(ifclk),
		.dest_clk(sysclk),
		.src_data(hwif_out_ifclk.ADC_CTRL.VCM_SINGLE_ENDED.value),
		.dest_data(hwif_out_sysclk.ADC_CTRL.VCM_SINGLE_ENDED.value)
	);

	sync_nstage #(
		.N_SYNC_STAGES(N_SYNC_STAGES),
		.SRC_INPUT_REG(SRC_INPUT_REG),
		.N_BITS(4)
	) sync_DELAY_LINE_CTRL (
		.src_clk(ifclk),
		.dest_clk(sysclk),
		.src_data(hwif_out_ifclk.ADC_CTRL.DELAY_LINE_CTRL.value),
		.dest_data(hwif_out_sysclk.ADC_CTRL.DELAY_LINE_CTRL.value)
	);

	sync_nstage #(
		.N_SYNC_STAGES(N_SYNC_STAGES),
		.SRC_INPUT_REG(SRC_INPUT_REG),
		.N_BITS(2)
	) sync_N_QUANTIZER_BITS (
		.src_clk(ifclk),
		.dest_clk(sysclk),
		.src_data(hwif_out_ifclk.ADC_CTRL.N_QUANTIZER_BITS.value),
		.dest_data(hwif_out_sysclk.ADC_CTRL.N_QUANTIZER_BITS.value)
	);

	sync_nstage #(
		.N_SYNC_STAGES(N_SYNC_STAGES),
		.SRC_INPUT_REG(SRC_INPUT_REG),
		.N_BITS(1)
	) sync_INCREMENTAL_MODE_EN (
		.src_clk(ifclk),
		.dest_clk(sysclk),
		.src_data(hwif_out_ifclk.ADC_CTRL.INCREMENTAL_MODE_EN.value),
		.dest_data(hwif_out_sysclk.ADC_CTRL.INCREMENTAL_MODE_EN.value)
	);

	sync_nstage #(
		.N_SYNC_STAGES(N_SYNC_STAGES),
		.SRC_INPUT_REG(SRC_INPUT_REG),
		.N_BITS(1)
	) sync_NOISE_SHAPING_EN (
		.src_clk(ifclk),
		.dest_clk(sysclk),
		.src_data(hwif_out_ifclk.ADC_CTRL.NOISE_SHAPING_EN.value),
		.dest_data(hwif_out_sysclk.ADC_CTRL.NOISE_SHAPING_EN.value)
	);

	sync_nstage #(
		.N_SYNC_STAGES(N_SYNC_STAGES),
		.SRC_INPUT_REG(SRC_INPUT_REG),
		.N_BITS(1)
	) sync_NFFT_EN (
		.src_clk(ifclk),
		.dest_clk(sysclk),
		.src_data(hwif_out_ifclk.RUN_CTRL.NFFT_EN.value),
		.dest_data(hwif_out_sysclk.RUN_CTRL.NFFT_EN.value)
	);

	sync_nstage #(
		.N_SYNC_STAGES(N_SYNC_STAGES),
		.SRC_INPUT_REG(SRC_INPUT_REG),
		.N_BITS(4)
	) sync_MAIN_STATE_RB (
		.src_clk(ifclk),
		.dest_clk(sysclk),
		.src_data(hwif_in_ifclk.RUN_CTRL.MAIN_STATE_RB.next),
		.dest_data(hwif_in_sysclk.RUN_CTRL.MAIN_STATE_RB.next)
	);

	sync_nstage #(
		.N_SYNC_STAGES(N_SYNC_STAGES),
		.SRC_INPUT_REG(SRC_INPUT_REG),
		.N_BITS(1)
	) sync_CLKGEN_DRP_RD_EN (
		.src_clk(ifclk),
		.dest_clk(sysclk),
		.src_data(hwif_out_ifclk.CLKGEN_DRP_0.CLKGEN_DRP_RD_EN.value),
		.dest_data(hwif_out_sysclk.CLKGEN_DRP_0.CLKGEN_DRP_RD_EN.value)
	);

	sync_nstage #(
		.N_SYNC_STAGES(N_SYNC_STAGES),
		.SRC_INPUT_REG(SRC_INPUT_REG),
		.N_BITS(1)
	) sync_CLKGEN_DRP_WR_EN (
		.src_clk(ifclk),
		.dest_clk(sysclk),
		.src_data(hwif_out_ifclk.CLKGEN_DRP_0.CLKGEN_DRP_WR_EN.value),
		.dest_data(hwif_out_sysclk.CLKGEN_DRP_0.CLKGEN_DRP_WR_EN.value)
	);

	sync_nstage #(
		.N_SYNC_STAGES(N_SYNC_STAGES),
		.SRC_INPUT_REG(SRC_INPUT_REG),
		.N_BITS(1)
	) sync_CLKGEN_DRP_DEN (
		.src_clk(ifclk),
		.dest_clk(sysclk),
		.src_data(hwif_out_ifclk.CLKGEN_DRP_0.CLKGEN_DRP_DEN.value),
		.dest_data(hwif_out_sysclk.CLKGEN_DRP_0.CLKGEN_DRP_DEN.value)
	);

	sync_nstage #(
		.N_SYNC_STAGES(N_SYNC_STAGES),
		.SRC_INPUT_REG(SRC_INPUT_REG),
		.N_BITS(7)
	) sync_CLKGEN_DRP_DADDR (
		.src_clk(ifclk),
		.dest_clk(sysclk),
		.src_data(hwif_out_ifclk.CLKGEN_DRP_0.CLKGEN_DRP_DADDR.value),
		.dest_data(hwif_out_sysclk.CLKGEN_DRP_0.CLKGEN_DRP_DADDR.value)
	);

	sync_nstage #(
		.N_SYNC_STAGES(N_SYNC_STAGES),
		.SRC_INPUT_REG(SRC_INPUT_REG),
		.N_BITS(16)
	) sync_CLKGEN_DRP_DI (
		.src_clk(ifclk),
		.dest_clk(sysclk),
		.src_data(hwif_out_ifclk.CLKGEN_DRP_2.CLKGEN_DRP_DI.value),
		.dest_data(hwif_out_sysclk.CLKGEN_DRP_2.CLKGEN_DRP_DI.value)
	);

	sync_nstage #(
		.N_SYNC_STAGES(N_SYNC_STAGES),
		.SRC_INPUT_REG(SRC_INPUT_REG),
		.N_BITS(16)
	) sync_CLKGEN_DRP_DO (
		.src_clk(ifclk),
		.dest_clk(sysclk),
		.src_data(hwif_in_ifclk.CLKGEN_DRP_3.CLKGEN_DRP_DO.next),
		.dest_data(hwif_in_sysclk.CLKGEN_DRP_3.CLKGEN_DRP_DO.next)
	);

endmodule : adc_regs_reg_sync
// Generated by PeakRDL-regblock - A free and open-source SystemVerilog generator
//  https://github.com/SystemRDL/PeakRDL-regblock

module adc_regs (
        input wire clk,
        input wire rst_n,

        obi_intf.subordinate s_obi,

        input adc_regs_pkg::adc_regs__in_t hwif_in,
        output adc_regs_pkg::adc_regs__out_t hwif_out
    );

    //--------------------------------------------------------------------------
    // CPU Bus interface logic
    //--------------------------------------------------------------------------
    logic cpuif_req;
    logic cpuif_req_is_wr;
    logic [16:0] cpuif_addr;
    logic [15:0] cpuif_wr_data;
    logic [15:0] cpuif_wr_biten;
    logic cpuif_req_stall_wr;
    logic cpuif_req_stall_rd;

    logic cpuif_rd_ack;
    logic cpuif_rd_err;
    logic [15:0] cpuif_rd_data;

    logic cpuif_wr_ack;
    logic cpuif_wr_err;

    `ifndef SYNTHESIS
        initial begin
            assert_bad_addr_width: assert($bits(s_obi.addr) >= adc_regs_pkg::ADC_REGS_MIN_ADDR_WIDTH)
                else $error("Interface address width of %0d is too small. Shall be at least %0d bits", $bits(s_obi.addr), adc_regs_pkg::ADC_REGS_MIN_ADDR_WIDTH);
            assert_bad_data_width: assert($bits(s_obi.wdata) == adc_regs_pkg::ADC_REGS_DATA_WIDTH)
                else $error("Interface data width of %0d is incorrect. Shall be %0d bits", $bits(s_obi.wdata), adc_regs_pkg::ADC_REGS_DATA_WIDTH);
        end
    `endif

    // State & holding regs
    logic is_active; // A request is being served (not yet fully responded)
    logic gnt_q; // one-cycle grant for A-channel
    logic rsp_pending; // response ready but not yet accepted by manager
    logic [15:0] rsp_rdata_q;
    logic rsp_err_q;
    logic [$bits(s_obi.rid)-1:0] rid_q;

    // Latch AID on accept to echo back the response
    always_ff @(posedge clk) begin
        if (~rst_n) begin
            is_active <= 1'b0;
            gnt_q <= 1'b0;
            rsp_pending <= 1'b0;
            rsp_rdata_q <= '0;
            rsp_err_q <= 1'b0;
            rid_q <= '0;

            cpuif_req <= '0;
            cpuif_req_is_wr <= '0;
            cpuif_addr <= '0;
            cpuif_wr_data <= '0;
            cpuif_wr_biten <= '0;
        end else begin
            // defaults
            cpuif_req <= 1'b0;
            gnt_q <= s_obi.req & ~is_active;

            // Accept new request when idle
            if (~is_active) begin
                if (s_obi.req) begin
                    is_active <= 1'b1;
                    cpuif_req <= 1'b1;
                    cpuif_req_is_wr <= s_obi.we;
                    cpuif_addr <= {s_obi.addr[16:1], 1'b0};
                    cpuif_wr_data <= s_obi.wdata;
                    rid_q <= s_obi.aid;
                    for (int i = 0; i < 2; i++) begin
                        cpuif_wr_biten[i*8 +: 8] <= {8{ s_obi.be[i] }};
                    end
                end
            end

            // Capture response
            if (is_active && (cpuif_rd_ack || cpuif_wr_ack)) begin
                rsp_pending <= 1'b1;
                rsp_rdata_q <= cpuif_rd_data;
                rsp_err_q <= cpuif_rd_err | cpuif_wr_err;
                // NOTE: Keep 'is_active' asserted until the external R handshake completes
            end

            // Complete external R-channel handshake only if manager ready
            if (rsp_pending && s_obi.rvalid && s_obi.rready) begin
                rsp_pending <= 1'b0;
                is_active <= 1'b0; // free to accept the next request
            end
        end
    end

    // R-channel outputs (held stable while rsp_pending=1)
    assign s_obi.rvalid = rsp_pending;
    assign s_obi.rdata = rsp_rdata_q;
    assign s_obi.err = rsp_err_q;
    assign s_obi.rid = rid_q;

    // A-channel grant (registered one-cycle pulse when we accept a request)
    assign s_obi.gnt = gnt_q;

    logic cpuif_req_masked;
    logic external_req;
    logic external_pending;
    logic external_wr_ack;
    logic external_rd_ack;
    always_ff @(posedge clk) begin
        if(~rst_n) begin
            external_pending <= '0;
        end else begin
            if(external_req & ~external_wr_ack & ~external_rd_ack) external_pending <= '1;
            else if(external_wr_ack | external_rd_ack) external_pending <= '0;
            `ifndef SYNTHESIS
                assert_bad_ext_wr_ack: assert(!external_wr_ack || (external_pending | external_req))
                    else $error("An external wr_ack strobe was asserted when no external request was active");
                assert_bad_ext_rd_ack: assert(!external_rd_ack || (external_pending | external_req))
                    else $error("An external rd_ack strobe was asserted when no external request was active");
            `endif
        end
    end

    // Read & write latencies are balanced. Stalls not required
    // except if external
    assign cpuif_req_stall_rd = external_pending;
    assign cpuif_req_stall_wr = external_pending;
    assign cpuif_req_masked = cpuif_req
                            & !(!cpuif_req_is_wr & cpuif_req_stall_rd)
                            & !(cpuif_req_is_wr & cpuif_req_stall_wr);

    //--------------------------------------------------------------------------
    // Address Decode
    //--------------------------------------------------------------------------
    typedef struct {
        logic NFFT_CTRL;
        logic OSR;
        logic SH_CTRL;
        logic INT1_CTRL;
        logic INT2_CTRL;
        logic ADC_CTRL;
        logic RUN_CTRL;
        logic CLKGEN_DRP_0;
        logic CLKGEN_DRP_2;
        logic CLKGEN_DRP_3;
        logic adc_output_mem;
    } decoded_reg_strb_t;
    decoded_reg_strb_t decoded_reg_strb;
    logic decoded_err;
    logic decoded_strb_is_external;

    logic [16:0] decoded_addr;

    logic decoded_req;
    logic decoded_req_is_wr;
    logic [15:0] decoded_wr_data;
    logic [15:0] decoded_wr_biten;

    always_comb begin
        automatic logic is_valid_addr;
        automatic logic is_invalid_rw;
        automatic logic is_external;
        is_external = '0;
        is_valid_addr = '1; // No error checking on valid address access
        is_invalid_rw = '0;
        decoded_reg_strb.NFFT_CTRL = cpuif_req_masked & (cpuif_addr == 17'h0);
        decoded_reg_strb.OSR = cpuif_req_masked & (cpuif_addr == 17'h2);
        decoded_reg_strb.SH_CTRL = cpuif_req_masked & (cpuif_addr == 17'h4);
        decoded_reg_strb.INT1_CTRL = cpuif_req_masked & (cpuif_addr == 17'h6);
        decoded_reg_strb.INT2_CTRL = cpuif_req_masked & (cpuif_addr == 17'h8);
        decoded_reg_strb.ADC_CTRL = cpuif_req_masked & (cpuif_addr == 17'ha);
        decoded_reg_strb.RUN_CTRL = cpuif_req_masked & (cpuif_addr == 17'hc);
        decoded_reg_strb.CLKGEN_DRP_0 = cpuif_req_masked & (cpuif_addr == 17'h10);
        decoded_reg_strb.CLKGEN_DRP_2 = cpuif_req_masked & (cpuif_addr == 17'h12);
        decoded_reg_strb.CLKGEN_DRP_3 = cpuif_req_masked & (cpuif_addr == 17'h14) & !cpuif_req_is_wr;
        decoded_reg_strb.adc_output_mem = cpuif_req_masked & (cpuif_addr >= 17'h10000) & (cpuif_addr <= 17'h10000 + 17'hffff) & !cpuif_req_is_wr;
        is_external |= cpuif_req_masked & (cpuif_addr >= 17'h10000) & (cpuif_addr <= 17'h10000 + 17'hffff) & !cpuif_req_is_wr;
        decoded_err = (~is_valid_addr | is_invalid_rw) & decoded_req;
        decoded_strb_is_external = is_external;
        external_req = is_external;
    end

    // Pass down signals to next stage
    assign decoded_addr = cpuif_addr;

    assign decoded_req = cpuif_req_masked;
    assign decoded_req_is_wr = cpuif_req_is_wr;
    assign decoded_wr_data = cpuif_wr_data;
    assign decoded_wr_biten = cpuif_wr_biten;

    //--------------------------------------------------------------------------
    // Field logic
    //--------------------------------------------------------------------------
    typedef struct {
        struct {
            struct {
                logic [14:0] next;
                logic load_next;
            } NFFT_POWER;
            struct {
                logic next;
                logic load_next;
            } DWA_EN;
        } NFFT_CTRL;
        struct {
            struct {
                logic [7:0] next;
                logic load_next;
            } OSR_POWER;
        } OSR;
        struct {
            struct {
                logic [7:0] next;
                logic load_next;
            } N_ACTIVE_CYCLES;
            struct {
                logic [7:0] next;
                logic load_next;
            } N_PASSIVE_CYCLES;
        } SH_CTRL;
        struct {
            struct {
                logic [7:0] next;
                logic load_next;
            } N_ACTIVE_CYCLES;
            struct {
                logic [7:0] next;
                logic load_next;
            } N_PASSIVE_CYCLES;
        } INT1_CTRL;
        struct {
            struct {
                logic [7:0] next;
                logic load_next;
            } N_ACTIVE_CYCLES;
            struct {
                logic [7:0] next;
                logic load_next;
            } N_PASSIVE_CYCLES;
        } INT2_CTRL;
        struct {
            struct {
                logic next;
                logic load_next;
            } INPUT_MODE;
            struct {
                logic [3:0] next;
                logic load_next;
            } VCM_SINGLE_ENDED;
            struct {
                logic [3:0] next;
                logic load_next;
            } DELAY_LINE_CTRL;
            struct {
                logic [1:0] next;
                logic load_next;
            } N_QUANTIZER_BITS;
            struct {
                logic next;
                logic load_next;
            } INCREMENTAL_MODE_EN;
            struct {
                logic next;
                logic load_next;
            } NOISE_SHAPING_EN;
        } ADC_CTRL;
        struct {
            struct {
                logic next;
                logic load_next;
            } NFFT_EN;
        } RUN_CTRL;
        struct {
            struct {
                logic next;
                logic load_next;
            } CLKGEN_DRP_RD_EN;
            struct {
                logic next;
                logic load_next;
            } CLKGEN_DRP_WR_EN;
            struct {
                logic next;
                logic load_next;
            } CLKGEN_DRP_DEN;
            struct {
                logic [6:0] next;
                logic load_next;
            } CLKGEN_DRP_DADDR;
        } CLKGEN_DRP_0;
        struct {
            struct {
                logic [15:0] next;
                logic load_next;
            } CLKGEN_DRP_DI;
        } CLKGEN_DRP_2;
    } field_combo_t;
    field_combo_t field_combo;

    typedef struct {
        struct {
            struct {
                logic [14:0] value;
            } NFFT_POWER;
            struct {
                logic value;
            } DWA_EN;
        } NFFT_CTRL;
        struct {
            struct {
                logic [7:0] value;
            } OSR_POWER;
        } OSR;
        struct {
            struct {
                logic [7:0] value;
            } N_ACTIVE_CYCLES;
            struct {
                logic [7:0] value;
            } N_PASSIVE_CYCLES;
        } SH_CTRL;
        struct {
            struct {
                logic [7:0] value;
            } N_ACTIVE_CYCLES;
            struct {
                logic [7:0] value;
            } N_PASSIVE_CYCLES;
        } INT1_CTRL;
        struct {
            struct {
                logic [7:0] value;
            } N_ACTIVE_CYCLES;
            struct {
                logic [7:0] value;
            } N_PASSIVE_CYCLES;
        } INT2_CTRL;
        struct {
            struct {
                logic value;
            } INPUT_MODE;
            struct {
                logic [3:0] value;
            } VCM_SINGLE_ENDED;
            struct {
                logic [3:0] value;
            } DELAY_LINE_CTRL;
            struct {
                logic [1:0] value;
            } N_QUANTIZER_BITS;
            struct {
                logic value;
            } INCREMENTAL_MODE_EN;
            struct {
                logic value;
            } NOISE_SHAPING_EN;
        } ADC_CTRL;
        struct {
            struct {
                logic value;
            } NFFT_EN;
        } RUN_CTRL;
        struct {
            struct {
                logic value;
            } CLKGEN_DRP_RD_EN;
            struct {
                logic value;
            } CLKGEN_DRP_WR_EN;
            struct {
                logic value;
            } CLKGEN_DRP_DEN;
            struct {
                logic [6:0] value;
            } CLKGEN_DRP_DADDR;
        } CLKGEN_DRP_0;
        struct {
            struct {
                logic [15:0] value;
            } CLKGEN_DRP_DI;
        } CLKGEN_DRP_2;
    } field_storage_t;
    field_storage_t field_storage;

    // Field: adc_regs.NFFT_CTRL.NFFT_POWER
    always_comb begin
        automatic logic [14:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.NFFT_CTRL.NFFT_POWER.value;
        load_next_c = '0;
        if(decoded_reg_strb.NFFT_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.NFFT_CTRL.NFFT_POWER.value & ~decoded_wr_biten[14:0]) | (decoded_wr_data[14:0] & decoded_wr_biten[14:0]);
            load_next_c = '1;
        end
        field_combo.NFFT_CTRL.NFFT_POWER.next = next_c;
        field_combo.NFFT_CTRL.NFFT_POWER.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(~rst_n) begin
            field_storage.NFFT_CTRL.NFFT_POWER.value <= 15'h0;
        end else begin
            if(field_combo.NFFT_CTRL.NFFT_POWER.load_next) begin
                field_storage.NFFT_CTRL.NFFT_POWER.value <= field_combo.NFFT_CTRL.NFFT_POWER.next;
            end
        end
    end
    assign hwif_out.NFFT_CTRL.NFFT_POWER.value = field_storage.NFFT_CTRL.NFFT_POWER.value;
    // Field: adc_regs.NFFT_CTRL.DWA_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.NFFT_CTRL.DWA_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.NFFT_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.NFFT_CTRL.DWA_EN.value & ~decoded_wr_biten[15:15]) | (decoded_wr_data[15:15] & decoded_wr_biten[15:15]);
            load_next_c = '1;
        end
        field_combo.NFFT_CTRL.DWA_EN.next = next_c;
        field_combo.NFFT_CTRL.DWA_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(~rst_n) begin
            field_storage.NFFT_CTRL.DWA_EN.value <= 1'h0;
        end else begin
            if(field_combo.NFFT_CTRL.DWA_EN.load_next) begin
                field_storage.NFFT_CTRL.DWA_EN.value <= field_combo.NFFT_CTRL.DWA_EN.next;
            end
        end
    end
    assign hwif_out.NFFT_CTRL.DWA_EN.value = field_storage.NFFT_CTRL.DWA_EN.value;
    // Field: adc_regs.OSR.OSR_POWER
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.OSR.OSR_POWER.value;
        load_next_c = '0;
        if(decoded_reg_strb.OSR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.OSR.OSR_POWER.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
            load_next_c = '1;
        end
        field_combo.OSR.OSR_POWER.next = next_c;
        field_combo.OSR.OSR_POWER.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(~rst_n) begin
            field_storage.OSR.OSR_POWER.value <= 8'h0;
        end else begin
            if(field_combo.OSR.OSR_POWER.load_next) begin
                field_storage.OSR.OSR_POWER.value <= field_combo.OSR.OSR_POWER.next;
            end
        end
    end
    assign hwif_out.OSR.OSR_POWER.value = field_storage.OSR.OSR_POWER.value;
    // Field: adc_regs.SH_CTRL.N_ACTIVE_CYCLES
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.SH_CTRL.N_ACTIVE_CYCLES.value;
        load_next_c = '0;
        if(decoded_reg_strb.SH_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.SH_CTRL.N_ACTIVE_CYCLES.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
            load_next_c = '1;
        end
        field_combo.SH_CTRL.N_ACTIVE_CYCLES.next = next_c;
        field_combo.SH_CTRL.N_ACTIVE_CYCLES.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(~rst_n) begin
            field_storage.SH_CTRL.N_ACTIVE_CYCLES.value <= 8'h1;
        end else begin
            if(field_combo.SH_CTRL.N_ACTIVE_CYCLES.load_next) begin
                field_storage.SH_CTRL.N_ACTIVE_CYCLES.value <= field_combo.SH_CTRL.N_ACTIVE_CYCLES.next;
            end
        end
    end
    assign hwif_out.SH_CTRL.N_ACTIVE_CYCLES.value = field_storage.SH_CTRL.N_ACTIVE_CYCLES.value;
    // Field: adc_regs.SH_CTRL.N_PASSIVE_CYCLES
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.SH_CTRL.N_PASSIVE_CYCLES.value;
        load_next_c = '0;
        if(decoded_reg_strb.SH_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.SH_CTRL.N_PASSIVE_CYCLES.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
            load_next_c = '1;
        end
        field_combo.SH_CTRL.N_PASSIVE_CYCLES.next = next_c;
        field_combo.SH_CTRL.N_PASSIVE_CYCLES.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(~rst_n) begin
            field_storage.SH_CTRL.N_PASSIVE_CYCLES.value <= 8'h0;
        end else begin
            if(field_combo.SH_CTRL.N_PASSIVE_CYCLES.load_next) begin
                field_storage.SH_CTRL.N_PASSIVE_CYCLES.value <= field_combo.SH_CTRL.N_PASSIVE_CYCLES.next;
            end
        end
    end
    assign hwif_out.SH_CTRL.N_PASSIVE_CYCLES.value = field_storage.SH_CTRL.N_PASSIVE_CYCLES.value;
    // Field: adc_regs.INT1_CTRL.N_ACTIVE_CYCLES
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.INT1_CTRL.N_ACTIVE_CYCLES.value;
        load_next_c = '0;
        if(decoded_reg_strb.INT1_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.INT1_CTRL.N_ACTIVE_CYCLES.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
            load_next_c = '1;
        end
        field_combo.INT1_CTRL.N_ACTIVE_CYCLES.next = next_c;
        field_combo.INT1_CTRL.N_ACTIVE_CYCLES.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(~rst_n) begin
            field_storage.INT1_CTRL.N_ACTIVE_CYCLES.value <= 8'h1;
        end else begin
            if(field_combo.INT1_CTRL.N_ACTIVE_CYCLES.load_next) begin
                field_storage.INT1_CTRL.N_ACTIVE_CYCLES.value <= field_combo.INT1_CTRL.N_ACTIVE_CYCLES.next;
            end
        end
    end
    assign hwif_out.INT1_CTRL.N_ACTIVE_CYCLES.value = field_storage.INT1_CTRL.N_ACTIVE_CYCLES.value;
    // Field: adc_regs.INT1_CTRL.N_PASSIVE_CYCLES
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.INT1_CTRL.N_PASSIVE_CYCLES.value;
        load_next_c = '0;
        if(decoded_reg_strb.INT1_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.INT1_CTRL.N_PASSIVE_CYCLES.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
            load_next_c = '1;
        end
        field_combo.INT1_CTRL.N_PASSIVE_CYCLES.next = next_c;
        field_combo.INT1_CTRL.N_PASSIVE_CYCLES.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(~rst_n) begin
            field_storage.INT1_CTRL.N_PASSIVE_CYCLES.value <= 8'h0;
        end else begin
            if(field_combo.INT1_CTRL.N_PASSIVE_CYCLES.load_next) begin
                field_storage.INT1_CTRL.N_PASSIVE_CYCLES.value <= field_combo.INT1_CTRL.N_PASSIVE_CYCLES.next;
            end
        end
    end
    assign hwif_out.INT1_CTRL.N_PASSIVE_CYCLES.value = field_storage.INT1_CTRL.N_PASSIVE_CYCLES.value;
    // Field: adc_regs.INT2_CTRL.N_ACTIVE_CYCLES
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.INT2_CTRL.N_ACTIVE_CYCLES.value;
        load_next_c = '0;
        if(decoded_reg_strb.INT2_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.INT2_CTRL.N_ACTIVE_CYCLES.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
            load_next_c = '1;
        end
        field_combo.INT2_CTRL.N_ACTIVE_CYCLES.next = next_c;
        field_combo.INT2_CTRL.N_ACTIVE_CYCLES.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(~rst_n) begin
            field_storage.INT2_CTRL.N_ACTIVE_CYCLES.value <= 8'h1;
        end else begin
            if(field_combo.INT2_CTRL.N_ACTIVE_CYCLES.load_next) begin
                field_storage.INT2_CTRL.N_ACTIVE_CYCLES.value <= field_combo.INT2_CTRL.N_ACTIVE_CYCLES.next;
            end
        end
    end
    assign hwif_out.INT2_CTRL.N_ACTIVE_CYCLES.value = field_storage.INT2_CTRL.N_ACTIVE_CYCLES.value;
    // Field: adc_regs.INT2_CTRL.N_PASSIVE_CYCLES
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.INT2_CTRL.N_PASSIVE_CYCLES.value;
        load_next_c = '0;
        if(decoded_reg_strb.INT2_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.INT2_CTRL.N_PASSIVE_CYCLES.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
            load_next_c = '1;
        end
        field_combo.INT2_CTRL.N_PASSIVE_CYCLES.next = next_c;
        field_combo.INT2_CTRL.N_PASSIVE_CYCLES.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(~rst_n) begin
            field_storage.INT2_CTRL.N_PASSIVE_CYCLES.value <= 8'h0;
        end else begin
            if(field_combo.INT2_CTRL.N_PASSIVE_CYCLES.load_next) begin
                field_storage.INT2_CTRL.N_PASSIVE_CYCLES.value <= field_combo.INT2_CTRL.N_PASSIVE_CYCLES.next;
            end
        end
    end
    assign hwif_out.INT2_CTRL.N_PASSIVE_CYCLES.value = field_storage.INT2_CTRL.N_PASSIVE_CYCLES.value;
    // Field: adc_regs.ADC_CTRL.INPUT_MODE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.ADC_CTRL.INPUT_MODE.value;
        load_next_c = '0;
        if(decoded_reg_strb.ADC_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.ADC_CTRL.INPUT_MODE.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end
        field_combo.ADC_CTRL.INPUT_MODE.next = next_c;
        field_combo.ADC_CTRL.INPUT_MODE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(~rst_n) begin
            field_storage.ADC_CTRL.INPUT_MODE.value <= 1'h0;
        end else begin
            if(field_combo.ADC_CTRL.INPUT_MODE.load_next) begin
                field_storage.ADC_CTRL.INPUT_MODE.value <= field_combo.ADC_CTRL.INPUT_MODE.next;
            end
        end
    end
    assign hwif_out.ADC_CTRL.INPUT_MODE.value = field_storage.ADC_CTRL.INPUT_MODE.value;
    // Field: adc_regs.ADC_CTRL.VCM_SINGLE_ENDED
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.ADC_CTRL.VCM_SINGLE_ENDED.value;
        load_next_c = '0;
        if(decoded_reg_strb.ADC_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.ADC_CTRL.VCM_SINGLE_ENDED.value & ~decoded_wr_biten[4:1]) | (decoded_wr_data[4:1] & decoded_wr_biten[4:1]);
            load_next_c = '1;
        end
        field_combo.ADC_CTRL.VCM_SINGLE_ENDED.next = next_c;
        field_combo.ADC_CTRL.VCM_SINGLE_ENDED.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(~rst_n) begin
            field_storage.ADC_CTRL.VCM_SINGLE_ENDED.value <= 4'h0;
        end else begin
            if(field_combo.ADC_CTRL.VCM_SINGLE_ENDED.load_next) begin
                field_storage.ADC_CTRL.VCM_SINGLE_ENDED.value <= field_combo.ADC_CTRL.VCM_SINGLE_ENDED.next;
            end
        end
    end
    assign hwif_out.ADC_CTRL.VCM_SINGLE_ENDED.value = field_storage.ADC_CTRL.VCM_SINGLE_ENDED.value;
    // Field: adc_regs.ADC_CTRL.DELAY_LINE_CTRL
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.ADC_CTRL.DELAY_LINE_CTRL.value;
        load_next_c = '0;
        if(decoded_reg_strb.ADC_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.ADC_CTRL.DELAY_LINE_CTRL.value & ~decoded_wr_biten[8:5]) | (decoded_wr_data[8:5] & decoded_wr_biten[8:5]);
            load_next_c = '1;
        end
        field_combo.ADC_CTRL.DELAY_LINE_CTRL.next = next_c;
        field_combo.ADC_CTRL.DELAY_LINE_CTRL.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(~rst_n) begin
            field_storage.ADC_CTRL.DELAY_LINE_CTRL.value <= 4'h0;
        end else begin
            if(field_combo.ADC_CTRL.DELAY_LINE_CTRL.load_next) begin
                field_storage.ADC_CTRL.DELAY_LINE_CTRL.value <= field_combo.ADC_CTRL.DELAY_LINE_CTRL.next;
            end
        end
    end
    assign hwif_out.ADC_CTRL.DELAY_LINE_CTRL.value = field_storage.ADC_CTRL.DELAY_LINE_CTRL.value;
    // Field: adc_regs.ADC_CTRL.N_QUANTIZER_BITS
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.ADC_CTRL.N_QUANTIZER_BITS.value;
        load_next_c = '0;
        if(decoded_reg_strb.ADC_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.ADC_CTRL.N_QUANTIZER_BITS.value & ~decoded_wr_biten[10:9]) | (decoded_wr_data[10:9] & decoded_wr_biten[10:9]);
            load_next_c = '1;
        end
        field_combo.ADC_CTRL.N_QUANTIZER_BITS.next = next_c;
        field_combo.ADC_CTRL.N_QUANTIZER_BITS.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(~rst_n) begin
            field_storage.ADC_CTRL.N_QUANTIZER_BITS.value <= 2'h0;
        end else begin
            if(field_combo.ADC_CTRL.N_QUANTIZER_BITS.load_next) begin
                field_storage.ADC_CTRL.N_QUANTIZER_BITS.value <= field_combo.ADC_CTRL.N_QUANTIZER_BITS.next;
            end
        end
    end
    assign hwif_out.ADC_CTRL.N_QUANTIZER_BITS.value = field_storage.ADC_CTRL.N_QUANTIZER_BITS.value;
    // Field: adc_regs.ADC_CTRL.INCREMENTAL_MODE_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.ADC_CTRL.INCREMENTAL_MODE_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.ADC_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.ADC_CTRL.INCREMENTAL_MODE_EN.value & ~decoded_wr_biten[11:11]) | (decoded_wr_data[11:11] & decoded_wr_biten[11:11]);
            load_next_c = '1;
        end
        field_combo.ADC_CTRL.INCREMENTAL_MODE_EN.next = next_c;
        field_combo.ADC_CTRL.INCREMENTAL_MODE_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(~rst_n) begin
            field_storage.ADC_CTRL.INCREMENTAL_MODE_EN.value <= 1'h0;
        end else begin
            if(field_combo.ADC_CTRL.INCREMENTAL_MODE_EN.load_next) begin
                field_storage.ADC_CTRL.INCREMENTAL_MODE_EN.value <= field_combo.ADC_CTRL.INCREMENTAL_MODE_EN.next;
            end
        end
    end
    assign hwif_out.ADC_CTRL.INCREMENTAL_MODE_EN.value = field_storage.ADC_CTRL.INCREMENTAL_MODE_EN.value;
    // Field: adc_regs.ADC_CTRL.NOISE_SHAPING_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.ADC_CTRL.NOISE_SHAPING_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.ADC_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.ADC_CTRL.NOISE_SHAPING_EN.value & ~decoded_wr_biten[12:12]) | (decoded_wr_data[12:12] & decoded_wr_biten[12:12]);
            load_next_c = '1;
        end
        field_combo.ADC_CTRL.NOISE_SHAPING_EN.next = next_c;
        field_combo.ADC_CTRL.NOISE_SHAPING_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(~rst_n) begin
            field_storage.ADC_CTRL.NOISE_SHAPING_EN.value <= 1'h0;
        end else begin
            if(field_combo.ADC_CTRL.NOISE_SHAPING_EN.load_next) begin
                field_storage.ADC_CTRL.NOISE_SHAPING_EN.value <= field_combo.ADC_CTRL.NOISE_SHAPING_EN.next;
            end
        end
    end
    assign hwif_out.ADC_CTRL.NOISE_SHAPING_EN.value = field_storage.ADC_CTRL.NOISE_SHAPING_EN.value;
    // Field: adc_regs.RUN_CTRL.NFFT_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.RUN_CTRL.NFFT_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.RUN_CTRL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.RUN_CTRL.NFFT_EN.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
            load_next_c = '1;
        end else if(hwif_in.RUN_CTRL.NFFT_EN.hwclr) begin // HW Clear
            next_c = '0;
            load_next_c = '1;
        end
        field_combo.RUN_CTRL.NFFT_EN.next = next_c;
        field_combo.RUN_CTRL.NFFT_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(~rst_n) begin
            field_storage.RUN_CTRL.NFFT_EN.value <= 1'h0;
        end else begin
            if(field_combo.RUN_CTRL.NFFT_EN.load_next) begin
                field_storage.RUN_CTRL.NFFT_EN.value <= field_combo.RUN_CTRL.NFFT_EN.next;
            end
        end
    end
    assign hwif_out.RUN_CTRL.NFFT_EN.value = field_storage.RUN_CTRL.NFFT_EN.value;
    // Field: adc_regs.CLKGEN_DRP_0.CLKGEN_DRP_RD_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CLKGEN_DRP_0.CLKGEN_DRP_RD_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.CLKGEN_DRP_0 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CLKGEN_DRP_0.CLKGEN_DRP_RD_EN.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end
        field_combo.CLKGEN_DRP_0.CLKGEN_DRP_RD_EN.next = next_c;
        field_combo.CLKGEN_DRP_0.CLKGEN_DRP_RD_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(~rst_n) begin
            field_storage.CLKGEN_DRP_0.CLKGEN_DRP_RD_EN.value <= 1'h0;
        end else begin
            if(field_combo.CLKGEN_DRP_0.CLKGEN_DRP_RD_EN.load_next) begin
                field_storage.CLKGEN_DRP_0.CLKGEN_DRP_RD_EN.value <= field_combo.CLKGEN_DRP_0.CLKGEN_DRP_RD_EN.next;
            end
        end
    end
    assign hwif_out.CLKGEN_DRP_0.CLKGEN_DRP_RD_EN.value = field_storage.CLKGEN_DRP_0.CLKGEN_DRP_RD_EN.value;
    // Field: adc_regs.CLKGEN_DRP_0.CLKGEN_DRP_WR_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CLKGEN_DRP_0.CLKGEN_DRP_WR_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.CLKGEN_DRP_0 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CLKGEN_DRP_0.CLKGEN_DRP_WR_EN.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
            load_next_c = '1;
        end
        field_combo.CLKGEN_DRP_0.CLKGEN_DRP_WR_EN.next = next_c;
        field_combo.CLKGEN_DRP_0.CLKGEN_DRP_WR_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(~rst_n) begin
            field_storage.CLKGEN_DRP_0.CLKGEN_DRP_WR_EN.value <= 1'h0;
        end else begin
            if(field_combo.CLKGEN_DRP_0.CLKGEN_DRP_WR_EN.load_next) begin
                field_storage.CLKGEN_DRP_0.CLKGEN_DRP_WR_EN.value <= field_combo.CLKGEN_DRP_0.CLKGEN_DRP_WR_EN.next;
            end
        end
    end
    assign hwif_out.CLKGEN_DRP_0.CLKGEN_DRP_WR_EN.value = field_storage.CLKGEN_DRP_0.CLKGEN_DRP_WR_EN.value;
    // Field: adc_regs.CLKGEN_DRP_0.CLKGEN_DRP_DEN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CLKGEN_DRP_0.CLKGEN_DRP_DEN.value;
        load_next_c = '0;
        if(decoded_reg_strb.CLKGEN_DRP_0 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CLKGEN_DRP_0.CLKGEN_DRP_DEN.value & ~decoded_wr_biten[2:2]) | (decoded_wr_data[2:2] & decoded_wr_biten[2:2]);
            load_next_c = '1;
        end
        field_combo.CLKGEN_DRP_0.CLKGEN_DRP_DEN.next = next_c;
        field_combo.CLKGEN_DRP_0.CLKGEN_DRP_DEN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(~rst_n) begin
            field_storage.CLKGEN_DRP_0.CLKGEN_DRP_DEN.value <= 1'h0;
        end else begin
            if(field_combo.CLKGEN_DRP_0.CLKGEN_DRP_DEN.load_next) begin
                field_storage.CLKGEN_DRP_0.CLKGEN_DRP_DEN.value <= field_combo.CLKGEN_DRP_0.CLKGEN_DRP_DEN.next;
            end
        end
    end
    assign hwif_out.CLKGEN_DRP_0.CLKGEN_DRP_DEN.value = field_storage.CLKGEN_DRP_0.CLKGEN_DRP_DEN.value;
    // Field: adc_regs.CLKGEN_DRP_0.CLKGEN_DRP_DADDR
    always_comb begin
        automatic logic [6:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CLKGEN_DRP_0.CLKGEN_DRP_DADDR.value;
        load_next_c = '0;
        if(decoded_reg_strb.CLKGEN_DRP_0 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CLKGEN_DRP_0.CLKGEN_DRP_DADDR.value & ~decoded_wr_biten[9:3]) | (decoded_wr_data[9:3] & decoded_wr_biten[9:3]);
            load_next_c = '1;
        end
        field_combo.CLKGEN_DRP_0.CLKGEN_DRP_DADDR.next = next_c;
        field_combo.CLKGEN_DRP_0.CLKGEN_DRP_DADDR.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(~rst_n) begin
            field_storage.CLKGEN_DRP_0.CLKGEN_DRP_DADDR.value <= 7'h0;
        end else begin
            if(field_combo.CLKGEN_DRP_0.CLKGEN_DRP_DADDR.load_next) begin
                field_storage.CLKGEN_DRP_0.CLKGEN_DRP_DADDR.value <= field_combo.CLKGEN_DRP_0.CLKGEN_DRP_DADDR.next;
            end
        end
    end
    assign hwif_out.CLKGEN_DRP_0.CLKGEN_DRP_DADDR.value = field_storage.CLKGEN_DRP_0.CLKGEN_DRP_DADDR.value;
    // Field: adc_regs.CLKGEN_DRP_2.CLKGEN_DRP_DI
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CLKGEN_DRP_2.CLKGEN_DRP_DI.value;
        load_next_c = '0;
        if(decoded_reg_strb.CLKGEN_DRP_2 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CLKGEN_DRP_2.CLKGEN_DRP_DI.value & ~decoded_wr_biten[15:0]) | (decoded_wr_data[15:0] & decoded_wr_biten[15:0]);
            load_next_c = '1;
        end
        field_combo.CLKGEN_DRP_2.CLKGEN_DRP_DI.next = next_c;
        field_combo.CLKGEN_DRP_2.CLKGEN_DRP_DI.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(~rst_n) begin
            field_storage.CLKGEN_DRP_2.CLKGEN_DRP_DI.value <= 16'h0;
        end else begin
            if(field_combo.CLKGEN_DRP_2.CLKGEN_DRP_DI.load_next) begin
                field_storage.CLKGEN_DRP_2.CLKGEN_DRP_DI.value <= field_combo.CLKGEN_DRP_2.CLKGEN_DRP_DI.next;
            end
        end
    end
    assign hwif_out.CLKGEN_DRP_2.CLKGEN_DRP_DI.value = field_storage.CLKGEN_DRP_2.CLKGEN_DRP_DI.value;
    // External region: adc_regs.adc_output_mem
    assign hwif_out.adc_output_mem.req = decoded_reg_strb.adc_output_mem;
    assign hwif_out.adc_output_mem.addr = decoded_addr[15:0];
    assign hwif_out.adc_output_mem.req_is_wr = decoded_req_is_wr;
    assign hwif_out.adc_output_mem.wr_data = decoded_wr_data;
    assign hwif_out.adc_output_mem.wr_biten = decoded_wr_biten;

    //--------------------------------------------------------------------------
    // Write response
    //--------------------------------------------------------------------------
    always_comb begin
        automatic logic wr_ack;
        wr_ack = '0;
        wr_ack |= hwif_in.adc_output_mem.wr_ack;
        external_wr_ack = wr_ack;
    end
    assign cpuif_wr_ack = external_wr_ack | (decoded_req & decoded_req_is_wr & ~decoded_strb_is_external);
    // Writes are always granted with no error response
    assign cpuif_wr_err = '0;

    //--------------------------------------------------------------------------
    // Readback
    //--------------------------------------------------------------------------
    logic readback_external_rd_ack_c;
    always_comb begin
        automatic logic rd_ack;
        rd_ack = '0;
        rd_ack |= hwif_in.adc_output_mem.rd_ack;
        readback_external_rd_ack_c = rd_ack;
    end

    logic readback_external_rd_ack;

    assign readback_external_rd_ack = readback_external_rd_ack_c;

    logic readback_err;
    logic readback_done;
    logic [15:0] readback_data;

    // Assign readback values to a flattened array
    logic [15:0] readback_array[11];
    assign readback_array[0][14:0] = (decoded_reg_strb.NFFT_CTRL && !decoded_req_is_wr) ? field_storage.NFFT_CTRL.NFFT_POWER.value : '0;
    assign readback_array[0][15:15] = (decoded_reg_strb.NFFT_CTRL && !decoded_req_is_wr) ? field_storage.NFFT_CTRL.DWA_EN.value : '0;
    assign readback_array[1][7:0] = (decoded_reg_strb.OSR && !decoded_req_is_wr) ? field_storage.OSR.OSR_POWER.value : '0;
    assign readback_array[1][15:8] = '0;
    assign readback_array[2][7:0] = (decoded_reg_strb.SH_CTRL && !decoded_req_is_wr) ? field_storage.SH_CTRL.N_ACTIVE_CYCLES.value : '0;
    assign readback_array[2][15:8] = (decoded_reg_strb.SH_CTRL && !decoded_req_is_wr) ? field_storage.SH_CTRL.N_PASSIVE_CYCLES.value : '0;
    assign readback_array[3][7:0] = (decoded_reg_strb.INT1_CTRL && !decoded_req_is_wr) ? field_storage.INT1_CTRL.N_ACTIVE_CYCLES.value : '0;
    assign readback_array[3][15:8] = (decoded_reg_strb.INT1_CTRL && !decoded_req_is_wr) ? field_storage.INT1_CTRL.N_PASSIVE_CYCLES.value : '0;
    assign readback_array[4][7:0] = (decoded_reg_strb.INT2_CTRL && !decoded_req_is_wr) ? field_storage.INT2_CTRL.N_ACTIVE_CYCLES.value : '0;
    assign readback_array[4][15:8] = (decoded_reg_strb.INT2_CTRL && !decoded_req_is_wr) ? field_storage.INT2_CTRL.N_PASSIVE_CYCLES.value : '0;
    assign readback_array[5][0:0] = (decoded_reg_strb.ADC_CTRL && !decoded_req_is_wr) ? field_storage.ADC_CTRL.INPUT_MODE.value : '0;
    assign readback_array[5][4:1] = (decoded_reg_strb.ADC_CTRL && !decoded_req_is_wr) ? field_storage.ADC_CTRL.VCM_SINGLE_ENDED.value : '0;
    assign readback_array[5][8:5] = (decoded_reg_strb.ADC_CTRL && !decoded_req_is_wr) ? field_storage.ADC_CTRL.DELAY_LINE_CTRL.value : '0;
    assign readback_array[5][10:9] = (decoded_reg_strb.ADC_CTRL && !decoded_req_is_wr) ? field_storage.ADC_CTRL.N_QUANTIZER_BITS.value : '0;
    assign readback_array[5][11:11] = (decoded_reg_strb.ADC_CTRL && !decoded_req_is_wr) ? field_storage.ADC_CTRL.INCREMENTAL_MODE_EN.value : '0;
    assign readback_array[5][12:12] = (decoded_reg_strb.ADC_CTRL && !decoded_req_is_wr) ? field_storage.ADC_CTRL.NOISE_SHAPING_EN.value : '0;
    assign readback_array[5][15:13] = '0;
    assign readback_array[6][0:0] = '0;
    assign readback_array[6][1:1] = (decoded_reg_strb.RUN_CTRL && !decoded_req_is_wr) ? field_storage.RUN_CTRL.NFFT_EN.value : '0;
    assign readback_array[6][5:2] = (decoded_reg_strb.RUN_CTRL && !decoded_req_is_wr) ? hwif_in.RUN_CTRL.MAIN_STATE_RB.next : '0;
    assign readback_array[6][15:6] = '0;
    assign readback_array[7][0:0] = (decoded_reg_strb.CLKGEN_DRP_0 && !decoded_req_is_wr) ? field_storage.CLKGEN_DRP_0.CLKGEN_DRP_RD_EN.value : '0;
    assign readback_array[7][1:1] = (decoded_reg_strb.CLKGEN_DRP_0 && !decoded_req_is_wr) ? field_storage.CLKGEN_DRP_0.CLKGEN_DRP_WR_EN.value : '0;
    assign readback_array[7][2:2] = (decoded_reg_strb.CLKGEN_DRP_0 && !decoded_req_is_wr) ? field_storage.CLKGEN_DRP_0.CLKGEN_DRP_DEN.value : '0;
    assign readback_array[7][9:3] = (decoded_reg_strb.CLKGEN_DRP_0 && !decoded_req_is_wr) ? field_storage.CLKGEN_DRP_0.CLKGEN_DRP_DADDR.value : '0;
    assign readback_array[7][15:10] = '0;
    assign readback_array[8][15:0] = (decoded_reg_strb.CLKGEN_DRP_2 && !decoded_req_is_wr) ? field_storage.CLKGEN_DRP_2.CLKGEN_DRP_DI.value : '0;
    assign readback_array[9][15:0] = (decoded_reg_strb.CLKGEN_DRP_3 && !decoded_req_is_wr) ? hwif_in.CLKGEN_DRP_3.CLKGEN_DRP_DO.next : '0;
    assign readback_array[10] = hwif_in.adc_output_mem.rd_ack ? hwif_in.adc_output_mem.rd_data : '0;

    // Reduce the array
    always_comb begin
        automatic logic [15:0] readback_data_var;
        readback_done = decoded_req & ~decoded_req_is_wr & ~decoded_strb_is_external;
        readback_err = '0;
        readback_data_var = '0;
        for(int i=0; i<11; i++) readback_data_var |= readback_array[i];
        readback_data = readback_data_var;
    end

    assign external_rd_ack = readback_external_rd_ack;
    assign cpuif_rd_ack = readback_done | readback_external_rd_ack;
    assign cpuif_rd_data = readback_data;
    assign cpuif_rd_err = readback_err;
endmodule
hwif_in.RUN_CTRL.NFFT_EN.hwclr
hwif_in.RUN_CTRL.MAIN_STATE_RB.next[3:0]
hwif_in.CLKGEN_DRP_3.CLKGEN_DRP_DO.next[15:0]
hwif_in.adc_output_mem.rd_ack
hwif_in.adc_output_mem.rd_data[15:0]
hwif_in.adc_output_mem.wr_ack
hwif_out.NFFT_CTRL.NFFT_POWER.value[14:0]
hwif_out.NFFT_CTRL.DWA_EN.value
hwif_out.OSR.OSR_POWER.value[7:0]
hwif_out.SH_CTRL.N_ACTIVE_CYCLES.value[7:0]
hwif_out.SH_CTRL.N_PASSIVE_CYCLES.value[7:0]
hwif_out.INT1_CTRL.N_ACTIVE_CYCLES.value[7:0]
hwif_out.INT1_CTRL.N_PASSIVE_CYCLES.value[7:0]
hwif_out.INT2_CTRL.N_ACTIVE_CYCLES.value[7:0]
hwif_out.INT2_CTRL.N_PASSIVE_CYCLES.value[7:0]
hwif_out.ADC_CTRL.INPUT_MODE.value
hwif_out.ADC_CTRL.VCM_SINGLE_ENDED.value[3:0]
hwif_out.ADC_CTRL.DELAY_LINE_CTRL.value[3:0]
hwif_out.ADC_CTRL.N_QUANTIZER_BITS.value[1:0]
hwif_out.ADC_CTRL.INCREMENTAL_MODE_EN.value
hwif_out.ADC_CTRL.NOISE_SHAPING_EN.value
hwif_out.RUN_CTRL.NFFT_EN.value
hwif_out.CLKGEN_DRP_0.CLKGEN_DRP_RD_EN.value
hwif_out.CLKGEN_DRP_0.CLKGEN_DRP_WR_EN.value
hwif_out.CLKGEN_DRP_0.CLKGEN_DRP_DEN.value
hwif_out.CLKGEN_DRP_0.CLKGEN_DRP_DADDR.value[6:0]
hwif_out.CLKGEN_DRP_2.CLKGEN_DRP_DI.value[15:0]
hwif_out.adc_output_mem.req
hwif_out.adc_output_mem.addr[15:0]
hwif_out.adc_output_mem.req_is_wr
hwif_out.adc_output_mem.wr_data[15:0]
hwif_out.adc_output_mem.wr_biten[15:0]
// Generated by PeakRDL-regblock - A free and open-source SystemVerilog generator
//  https://github.com/SystemRDL/PeakRDL-regblock

package adc_regs_pkg;

    localparam ADC_REGS_DATA_WIDTH = 16;
    localparam ADC_REGS_MIN_ADDR_WIDTH = 17;
    localparam ADC_REGS_SIZE = 'h20000;

    typedef struct {
        logic hwclr;
    } adc_regs__RUN_CTRL__NFFT_EN__in_t;

    typedef struct {
        logic [3:0] next;
    } adc_regs__RUN_CTRL__MAIN_STATE_RB__in_t;

    typedef struct {
        adc_regs__RUN_CTRL__NFFT_EN__in_t NFFT_EN;
        adc_regs__RUN_CTRL__MAIN_STATE_RB__in_t MAIN_STATE_RB;
    } adc_regs__RUN_CTRL__in_t;

    typedef struct {
        logic [15:0] next;
    } adc_regs__CLKGEN_DRP_3__CLKGEN_DRP_DO__in_t;

    typedef struct {
        adc_regs__CLKGEN_DRP_3__CLKGEN_DRP_DO__in_t CLKGEN_DRP_DO;
    } adc_regs__CLKGEN_DRP_3__in_t;

    typedef struct {
        logic rd_ack;
        logic [15:0] rd_data;
        logic wr_ack;
    } adc_regs__adc_output_mem__external__in_t;

    typedef struct {
        adc_regs__RUN_CTRL__in_t RUN_CTRL;
        adc_regs__CLKGEN_DRP_3__in_t CLKGEN_DRP_3;
        adc_regs__adc_output_mem__external__in_t adc_output_mem;
    } adc_regs__in_t;

    typedef struct {
        logic [14:0] value;
    } adc_regs__NFFT_CTRL__NFFT_POWER__out_t;

    typedef struct {
        logic value;
    } adc_regs__NFFT_CTRL__DWA_EN__out_t;

    typedef struct {
        adc_regs__NFFT_CTRL__NFFT_POWER__out_t NFFT_POWER;
        adc_regs__NFFT_CTRL__DWA_EN__out_t DWA_EN;
    } adc_regs__NFFT_CTRL__out_t;

    typedef struct {
        logic [7:0] value;
    } adc_regs__OSR__OSR_POWER__out_t;

    typedef struct {
        adc_regs__OSR__OSR_POWER__out_t OSR_POWER;
    } adc_regs__OSR__out_t;

    typedef struct {
        logic [7:0] value;
    } adc_regs__active_passive_reg__N_ACTIVE_CYCLES__out_t;

    typedef struct {
        logic [7:0] value;
    } adc_regs__active_passive_reg__N_PASSIVE_CYCLES__out_t;

    typedef struct {
        adc_regs__active_passive_reg__N_ACTIVE_CYCLES__out_t N_ACTIVE_CYCLES;
        adc_regs__active_passive_reg__N_PASSIVE_CYCLES__out_t N_PASSIVE_CYCLES;
    } adc_regs__active_passive_reg__out_t;

    typedef struct {
        logic value;
    } adc_regs__ADC_CTRL__INPUT_MODE__out_t;

    typedef struct {
        logic [3:0] value;
    } adc_regs__ADC_CTRL__VCM_SINGLE_ENDED__out_t;

    typedef struct {
        logic [3:0] value;
    } adc_regs__ADC_CTRL__DELAY_LINE_CTRL__out_t;

    typedef struct {
        logic [1:0] value;
    } adc_regs__ADC_CTRL__N_QUANTIZER_BITS__out_t;

    typedef struct {
        logic value;
    } adc_regs__ADC_CTRL__INCREMENTAL_MODE_EN__out_t;

    typedef struct {
        logic value;
    } adc_regs__ADC_CTRL__NOISE_SHAPING_EN__out_t;

    typedef struct {
        adc_regs__ADC_CTRL__INPUT_MODE__out_t INPUT_MODE;
        adc_regs__ADC_CTRL__VCM_SINGLE_ENDED__out_t VCM_SINGLE_ENDED;
        adc_regs__ADC_CTRL__DELAY_LINE_CTRL__out_t DELAY_LINE_CTRL;
        adc_regs__ADC_CTRL__N_QUANTIZER_BITS__out_t N_QUANTIZER_BITS;
        adc_regs__ADC_CTRL__INCREMENTAL_MODE_EN__out_t INCREMENTAL_MODE_EN;
        adc_regs__ADC_CTRL__NOISE_SHAPING_EN__out_t NOISE_SHAPING_EN;
    } adc_regs__ADC_CTRL__out_t;

    typedef struct {
        logic value;
    } adc_regs__RUN_CTRL__NFFT_EN__out_t;

    typedef struct {
        adc_regs__RUN_CTRL__NFFT_EN__out_t NFFT_EN;
    } adc_regs__RUN_CTRL__out_t;

    typedef struct {
        logic value;
    } adc_regs__CLKGEN_DRP_0__CLKGEN_DRP_RD_EN__out_t;

    typedef struct {
        logic value;
    } adc_regs__CLKGEN_DRP_0__CLKGEN_DRP_WR_EN__out_t;

    typedef struct {
        logic value;
    } adc_regs__CLKGEN_DRP_0__CLKGEN_DRP_DEN__out_t;

    typedef struct {
        logic [6:0] value;
    } adc_regs__CLKGEN_DRP_0__CLKGEN_DRP_DADDR__out_t;

    typedef struct {
        adc_regs__CLKGEN_DRP_0__CLKGEN_DRP_RD_EN__out_t CLKGEN_DRP_RD_EN;
        adc_regs__CLKGEN_DRP_0__CLKGEN_DRP_WR_EN__out_t CLKGEN_DRP_WR_EN;
        adc_regs__CLKGEN_DRP_0__CLKGEN_DRP_DEN__out_t CLKGEN_DRP_DEN;
        adc_regs__CLKGEN_DRP_0__CLKGEN_DRP_DADDR__out_t CLKGEN_DRP_DADDR;
    } adc_regs__CLKGEN_DRP_0__out_t;

    typedef struct {
        logic [15:0] value;
    } adc_regs__CLKGEN_DRP_2__CLKGEN_DRP_DI__out_t;

    typedef struct {
        adc_regs__CLKGEN_DRP_2__CLKGEN_DRP_DI__out_t CLKGEN_DRP_DI;
    } adc_regs__CLKGEN_DRP_2__out_t;

    typedef struct {
        logic req;
        logic [15:0] addr;
        logic req_is_wr;
        logic [15:0] wr_data;
        logic [15:0] wr_biten;
    } adc_regs__adc_output_mem__external__out_t;

    typedef struct {
        adc_regs__NFFT_CTRL__out_t NFFT_CTRL;
        adc_regs__OSR__out_t OSR;
        adc_regs__active_passive_reg__out_t SH_CTRL;
        adc_regs__active_passive_reg__out_t INT1_CTRL;
        adc_regs__active_passive_reg__out_t INT2_CTRL;
        adc_regs__ADC_CTRL__out_t ADC_CTRL;
        adc_regs__RUN_CTRL__out_t RUN_CTRL;
        adc_regs__CLKGEN_DRP_0__out_t CLKGEN_DRP_0;
        adc_regs__CLKGEN_DRP_2__out_t CLKGEN_DRP_2;
        adc_regs__adc_output_mem__external__out_t adc_output_mem;
    } adc_regs__out_t;

    typedef enum logic {
        adc_regs__input_mode_e__SINGLE_ENDED = 'h0,
        adc_regs__input_mode_e__DIFFERENTIAL = 'h1
    } adc_regs__input_mode_e_e;
endpackage
interface obi_intf #(
    parameter DATA_WIDTH = 32,
    parameter ADDR_WIDTH = 32,
    parameter ID_WIDTH = 1
);
    logic req;
    logic gnt;
    logic [ADDR_WIDTH-1:0] addr;
    logic we;
    logic [DATA_WIDTH/8-1:0] be;
    logic [DATA_WIDTH-1:0] wdata;
    logic [ID_WIDTH-1:0] aid;

    logic rvalid;
    logic rready;
    logic [DATA_WIDTH-1:0] rdata;
    logic err;
    logic [ID_WIDTH-1:0] rid;

    modport manager (
        output req,
        input gnt,
        output addr,
        output we,
        output be,
        output wdata,
        output aid,

        input rvalid,
        output rready,
        input rdata,
        input err,
        input rid
    );

    modport subordinate (
        input req,
        output gnt,
        input addr,
        input we,
        input be,
        input wdata,
        input aid,

        output rvalid,
        input rready,
        output rdata,
        output err,
        output rid
    );
endinterface
module #(
    parameter N_BITS=1,
    parameter N_SYNC_STAGES=2,
    parameter SRC_INPUT_REG=0
) sync_nstage (
    logic [N_BITS-1:0] src_data,
    logic [N_BITS-1:0] dest_data,
    logic src_clk,
    logic dest_clk
);

    `ifdef VIVADO

    xpm_cdc_array_single #(
        .DEST_SYNC_FF(N_SYNC_STAGES),
        .WIDTH(N_BITS),
        .SRC_INPUT_REG(SRC_INPUT_REG)
    ) cdc_sync (
        .src_in  (src_data),
        .dest_out(dest_data),
        .dest_clk(dest_clk),
        .src_clk(src_clk)
    );

    `else

    logic [N_BITS-1:0] sync_to_dest_clk [(N_SYNC_STAGES-1):0];
    logic [N_BITS-1:0] sync_to_src_clk;
    genvar i;
    for (i = 0; i < N_SYNC_STAGES; i++) begin
        always_ff @(posedge dest_clk) begin
            if (i == 0)
                sync_to_dest_clk[i] <= sync_to_src_clk;
            else
                sync_to_dest_clk[i] <= sync_to_dest_clk[i - 1];
        end
    end
    assign dest_data = sync_to_dest_clk[N_SYNC_STAGES - 1];

    if (SRC_INPUT_REG) begin
        always_ff @(posedge src_clk)
            sync_to_src_clk <= src_data;
    end else begin
        always_comb
            sync_to_src_clk = src_data;
    end
    
    `endif

endmodulemodule barrel_shifter #(
    parameter N_SAR_BITS=3
) (
    input  logic [(1<<N_SAR_BITS)-1:0] i_data,
    input  logic [N_SAR_BITS-1:0]      i_shift,
    output logic [(1<<N_SAR_BITS)-1:0] o_data
);

    logic [(1<<(N_SAR_BITS+1))-1:0] input_shift_data;
    
    assign input_shift_data = {i_data, {(1<<N_SAR_BITS){1'b0}}} >> i_shift;

    assign o_data = input_shift_data[(1<<(N_SAR_BITS+1))-1:(1<<(N_SAR_BITS))] |
                    input_shift_data[(1<<(N_SAR_BITS))-1:0];

endmodulemodule binary_to_thermometer #(
    parameter N_BINARY_BITS=3
) (
    input logic [N_BINARY_BITS-1:0] i_binary,
    output logic [(1<<N_BINARY_BITS)-1:0] o_thermometer;
);

    genvar i;

    always_comb begin
        for (i = 0; i < (1 << N_BINARY_BITS); i++) begin
            o_thermometer[i] = i < i_binary;
        end
    end

endmodulemodule sar_state_machine #(
    parameter N_SAR_BITS=3
) (
    reg_if.RD rd,
    input logic i_sar_compare,
    input logic i_reset_pointer,
    input logic i_en_sar,
    output logic [(1 << N_SAR_BITS)-1:0] o_caps_set,
    output logic [(1 << N_SAR_BITS)-1:0] o_cap_voltages,
    input logic i_clk,
    input logic i_rst_b
);

    enum logic [1:0] {
        CONVERT_LOW=2'h0,
        CONVERT_HIGH=2'h1,
        DWA=2'h2
    } state, next_state;

    logic [13:0]                   sar_counter;
    logic [$clog2(N_SAR_BITS)-1:0] sar_bit_counter;
    logic [N_SAR_BITS-1:0] dwa_pointer;
    logic                  previous_en_sar;

    // next state logic
    always_comb begin
        case (state)
            CONVERT_LOW  : next_state = (sar_counter == (rd.N_SAR_CYCLES - 1)) ? CONVERT_HIGH : CONVERT_LOW;
            CONVERT_HIGH : next_state = (sar_counter == (rd.N_SAR_CYCLES - 1)) && (sar_bit_counter == (N_SAR_BITS - 1)) ? DWA : CONVERT_LOW;
            DWA          : next_state = (sar_counter == (2 * (rd.N_SAR_CYCLES - 1))) ? CONVERT_LOW : DWA;
        endcase
    end

    always_ff @(posedge i_clk) begin
        if (!i_rst_b) begin
            state <= CONVERT_LOW;
            sar_counter <= 0;
            sar_bit_counter <= 0;
            dwa_pointer <= 0;
            previous_en_sar <= 0;
        end else begin
            previous_en_sar <= i_en_sar;
            if (i_en_sar && (state == next_state))
                sar_counter <= sar_counter + 1;
            else
                sar_counter <= 0;
            if (i_en_sar && (state == CONVERT_HIGH) && (next_state != CONVERT_HIGH))
                sar_bit_counter <= sar_bit_counter + 1;
            else if (i_en_sar && (state == DWA) && (next_state == CONVERT_LOW))
                sar_bit_counter <= 0;
        end
    end

endmodulemodule spi #(
    parameter ADDR_WIDTH = 16,
    parameter DATA_WIDTH = 8
)(
    input  logic        scl,        // SPI clock
    input  logic        mosi,       // Master Out Slave In
    output logic        miso,       // Master In Slave Out
    input  logic        cs_b,       // Chip Select (active low)

    obi_intf.manager if_reg
);

    typedef enum logic [1:0] {
        RESET,
        ADDR_DECODE,
        REG_RECEIVE,
        REG_SEND
    } spi_state_e;

    spi_state_e state, next_state;

    logic [$clog2(ADDR_WIDTH+1)-1:0] addr_count;
    logic [ADDR_WIDTH:0] addr_shift;
    logic [DATA_WIDTH-1:0] rx_shift, tx_shift;
    logic [$clog2(DATA_WIDTH)-1:0] bit_cnt;
    logic miso_n;

    // FSM state transition
    always_ff @(posedge scl or posedge cs_b) begin
        if (cs_b)
            state <= ADDR_DECODE;
        else
            state <= next_state;
    end

    // FSM next state logic
    always_comb begin
        case (state)
            ADDR_DECODE: begin
                if (addr_count == ADDR_WIDTH)
                    next_state = addr_shift[ADDR_WIDTH-1] ? REG_SEND : REG_RECEIVE;
                else
                    next_state = ADDR_DECODE;
            end
            REG_RECEIVE: next_state = REG_RECEIVE; // burst mode write
            REG_SEND   : next_state = REG_SEND;    // burst mode read
            RESET      : next_state = ADDR_DECODE;
            default    : next_state = RESET;
        endcase
    end

    // Shift logic reset on cs_b deassertion
    always_ff @(posedge scl or posedge cs_b) begin
        if (cs_b) begin
            addr_count  <= 0;
            addr_shift  <= 0;
            rx_shift    <= 0;
            tx_shift    <= 0;
            bit_cnt     <= 0;
            reg_rd_en   <= 0;
            reg_wr_en   <= 0;
        end else begin
            case (state)

                ADDR_DECODE: begin
                    addr_shift <= {addr_shift[ADDR_WIDTH-1:0], mosi};
                    if (addr_count < ADDR_WIDTH)
                        addr_count <= addr_count + 1;
                end

                REG_RECEIVE: begin
                    rx_shift <= {rx_shift[DATA_WIDTH-2:0], mosi};
                    if (bit_cnt == DATA_WIDTH-1) begin
                        bit_cnt <= 0;
                        addr_shift <= addr_shift + 1;
                    end else begin
                        bit_cnt  <= bit_cnt + 1;
                    end
                end

                REG_SEND: begin
                    if (bit_cnt == 0)
                        tx_shift <= {reg_rd_data[DATA_WIDTH-2:0], 1'b0};
                    else
                        tx_shift <= {tx_shift[DATA_WIDTH-2:0], 1'b0};
                    bit_cnt  <= bit_cnt + 1;
                    if ((bit_cnt == (DATA_WIDTH-1)))
                        addr_shift <= addr_shift + 1;
                end
            endcase
        end
    end

    always_ff @(negedge scl or posedge cs_b) begin
        if (cs_b)
            miso <= 0;
        else
            miso <= miso_n;
    end

    assign reg_rd_en   = ((state == ADDR_DECODE) && (next_state == REG_SEND)) ||
                         ((state == REG_SEND)    && (bit_cnt == DATA_WIDTH-1));
    assign reg_wr_en   = ((state == REG_RECEIVE) && (bit_cnt == DATA_WIDTH-1));
    assign reg_wr_data = {rx_shift[DATA_WIDTH-2:0], mosi};
    assign miso_n      = (state == REG_SEND) && (bit_cnt == 0) ? reg_rd_data[DATA_WIDTH-1] : 
                         (state == REG_SEND)                   ? tx_shift[DATA_WIDTH-1]    : 0;
    assign reg_addr    = (state == ADDR_DECODE) ? {addr_shift[ADDR_WIDTH-1:0], mosi} : 
                         (state == REG_RECEIVE) ? addr_shift                         : addr_shift + 1;

endmodule# Noise-Shaping SAR PCB
The goal of this project is to create a 2nd-order, noise shaping SAR on a printed circuit board (PCB).
This has several goals:
1) Understand, design, and build a mixed-signal PCB using SMD components
1) Go through the process of FPGA design and synthesis, including asynchronous RTL design
1) Become better at reading datasheets for discrete components
1) Build a UVM testbench that includes real-number modeling.
1) Using IEEE SystemRDL to describe a register model.
1) Design an analog/mixed-signal circuit using LTSpice, instead of my usual Spectre.
1) Implement a system that includes some kind of bus communication protocol, likely i2c or SPI.

## Architecture
This PCB follows the Silva-Steensgard architecture detailed in [1], shown below:

![Silva-Steensgard ADC](./img/silva_steensgard_architecture.png)

The quantizer is implemented as a 4-bit SAR ADC with redundancy to reduce quantization noise. This introduces a number of design challenges, the main ones being:
1) The SAR ADC requires a multi-tail comparator, which will have to be implemented 
2) The feedback DAC requires several bits, which are most easily sent from the FPGA with discrete shift registers, instead of buying an FPGA with more IO pins.

## Controls
By using control registers, it will be possible to set several things about the ADC:
1) The oversampling rate (OSR), which is only applicable for incremental mode
2) The total number of analysis samples (nfft)
3) Whether the ADC is in incremental or continous mode
4) The clock division ratio (dividing down from a master clock in the FPGA)
5) Turning DEM on and off
6) The number of 'warmup' samples
7) The 2nd-order filter coefficients for continuous mode

The controls and communication will be done via I2C. This means the setting of the control registers, beginning ADC operation, reading control registers, and reading data.

## Design
The digital side of the ADC, including communication and potentially clocking, is implemented on an FPGA. However, this design is meant to imitate a tapeout, so industry standard verification methodology is used, as far as free or open-source tools are available. This will include SystemVerilog real number modeling (SV-RNM) of the analog core. This is also an opportunity to do a deep-dive into Universal Verification Methodology (UVM). Therefore, the design process is as follows:
| Step | Tool |
| :--- | :--- |
| Initial Modeling | Python |
| Digital Logic Design | Xilinx Vivado |
| Analog SV Model | Xilinx Vivado |
| UVM Testbench | Xilinx Vivado |
| Analog Design | LTSpice |
| PCB Design | Altium Designer/KiCAD |
| Analog Verification | LTSpice/Altium |
| PCB Testing | Arduino/Electrical Test Bench |
| Analysis | Python |
| Documentation | Microsoft Office Online |

### Initial Block Diagram
The analog circuitry is on the left, and the digital on the right. The digital logic has all the control logic and the digital filters both for continuous mode and for incremental mode. It also has the storage and communication logic that will communicate directly with the tester, since the terminations are already handled.

![Block Diagram](./img/block_diagram.png)


## Python Simulation
The Python simulation shows an SNR of over 40 dB. This is discounting mismatch
noise, but DWA is shown to significantly reduce harmonics introduced by
capacitor mismatch, which is significant on discrete components.

![IADC Simulation](./img/dwa_compare.png)

This is with a single stage IADC.

## Verification Environment
The UVM verification environment consists of 3 UVCs:
1) Analog Input: UVM-MS only agent that can drive a single value or a sine wave. Since it will never
be operated in passive mode, the standard UVM principles are relaxed, i.e. the monitor will "know"
in which mode it is being operated. It shall be in single-ended or differential, so must be
configurable with supply voltage.
2) Bus interface: Either SPI or I2C. Must be register-compatible, that is, have additional support
for a register layer (adapter, additional subscribers/packet splitters, etc.)
3) Clock/reset: The FPGA will be supplied via a crystal oscillator, but reset should be internal.
Therefore, there is a single clock agent with single-ended or differential clocks.

### UVM Testcases
| Testcase Name | Purpose | Procedure |
| :--- | :--- | :--- |
| `test_reg_access` | Test that registers write and read correctly | Write a register, then read it back. The values should match. This  |
| `test_input_values` | Test that individual values are converted correctly | Generate `NFFT` random values and convert them, check that they match within the specified ENOB (effective number of bits). |

### Analog Simulation
It will be necessary to show that the analog frontend matches the SV-RNM model. This will be the focus of the analog design and simulation.